{"ast":null,"code":"// src/utils/Logger.ts\nvar nopLogger = {\n  debug: () => void 0,\n  info: () => void 0,\n  warn: () => void 0,\n  error: () => void 0\n};\nvar level;\nvar logger;\nvar Log = /* @__PURE__ */(Log2 => {\n  Log2[Log2[\"NONE\"] = 0] = \"NONE\";\n  Log2[Log2[\"ERROR\"] = 1] = \"ERROR\";\n  Log2[Log2[\"WARN\"] = 2] = \"WARN\";\n  Log2[Log2[\"INFO\"] = 3] = \"INFO\";\n  Log2[Log2[\"DEBUG\"] = 4] = \"DEBUG\";\n  return Log2;\n})(Log || {});\n(Log2 => {\n  function reset() {\n    level = 3 /* INFO */;\n    logger = nopLogger;\n  }\n  Log2.reset = reset;\n  function setLevel(value) {\n    if (!(0 /* NONE */ <= value && value <= 4 /* DEBUG */)) {\n      throw new Error(\"Invalid log level\");\n    }\n    level = value;\n  }\n  Log2.setLevel = setLevel;\n  function setLogger(value) {\n    logger = value;\n  }\n  Log2.setLogger = setLogger;\n})(Log || (Log = {}));\nvar Logger = class _Logger {\n  constructor(_name) {\n    this._name = _name;\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n  debug(...args) {\n    if (level >= 4 /* DEBUG */) {\n      logger.debug(_Logger._format(this._name, this._method), ...args);\n    }\n  }\n  info(...args) {\n    if (level >= 3 /* INFO */) {\n      logger.info(_Logger._format(this._name, this._method), ...args);\n    }\n  }\n  warn(...args) {\n    if (level >= 2 /* WARN */) {\n      logger.warn(_Logger._format(this._name, this._method), ...args);\n    }\n  }\n  error(...args) {\n    if (level >= 1 /* ERROR */) {\n      logger.error(_Logger._format(this._name, this._method), ...args);\n    }\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n  throw(err) {\n    this.error(err);\n    throw err;\n  }\n  create(method) {\n    const methodLogger = Object.create(this);\n    methodLogger._method = method;\n    methodLogger.debug(\"begin\");\n    return methodLogger;\n  }\n  static createStatic(name, staticMethod) {\n    const staticLogger = new _Logger(`${name}.${staticMethod}`);\n    staticLogger.debug(\"begin\");\n    return staticLogger;\n  }\n  static _format(name, method) {\n    const prefix = `[${name}]`;\n    return method ? `${prefix} ${method}:` : prefix;\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n  // helpers for static class methods\n  static debug(name, ...args) {\n    if (level >= 4 /* DEBUG */) {\n      logger.debug(_Logger._format(name), ...args);\n    }\n  }\n  static info(name, ...args) {\n    if (level >= 3 /* INFO */) {\n      logger.info(_Logger._format(name), ...args);\n    }\n  }\n  static warn(name, ...args) {\n    if (level >= 2 /* WARN */) {\n      logger.warn(_Logger._format(name), ...args);\n    }\n  }\n  static error(name, ...args) {\n    if (level >= 1 /* ERROR */) {\n      logger.error(_Logger._format(name), ...args);\n    }\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n};\nLog.reset();\n\n// src/utils/JwtUtils.ts\nimport { jwtDecode } from \"jwt-decode\";\nvar JwtUtils = class {\n  // IMPORTANT: doesn't validate the token\n  static decode(token) {\n    try {\n      return jwtDecode(token);\n    } catch (err) {\n      Logger.error(\"JwtUtils.decode\", err);\n      throw err;\n    }\n  }\n  static async generateSignedJwt(header, payload, privateKey) {\n    const encodedHeader = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(header)));\n    const encodedPayload = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(payload)));\n    const encodedToken = `${encodedHeader}.${encodedPayload}`;\n    const signature = await window.crypto.subtle.sign({\n      name: \"ECDSA\",\n      hash: {\n        name: \"SHA-256\"\n      }\n    }, privateKey, new TextEncoder().encode(encodedToken));\n    const encodedSignature = CryptoUtils.encodeBase64Url(new Uint8Array(signature));\n    return `${encodedToken}.${encodedSignature}`;\n  }\n  static async generateSignedJwtWithHmac(header, payload, secretKey) {\n    const encodedHeader = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(header)));\n    const encodedPayload = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(payload)));\n    const encodedToken = `${encodedHeader}.${encodedPayload}`;\n    const signature = await window.crypto.subtle.sign(\"HMAC\", secretKey, new TextEncoder().encode(encodedToken));\n    const encodedSignature = CryptoUtils.encodeBase64Url(new Uint8Array(signature));\n    return `${encodedToken}.${encodedSignature}`;\n  }\n};\n\n// src/utils/CryptoUtils.ts\nvar UUID_V4_TEMPLATE = \"10000000-1000-4000-8000-100000000000\";\nvar toBase64 = val => btoa([...new Uint8Array(val)].map(chr => String.fromCharCode(chr)).join(\"\"));\nvar _CryptoUtils = class _CryptoUtils {\n  static _randomWord() {\n    const arr = new Uint32Array(1);\n    crypto.getRandomValues(arr);\n    return arr[0];\n  }\n  /**\n   * Generates RFC4122 version 4 guid\n   */\n  static generateUUIDv4() {\n    const uuid = UUID_V4_TEMPLATE.replace(/[018]/g, c => (+c ^ _CryptoUtils._randomWord() & 15 >> +c / 4).toString(16));\n    return uuid.replace(/-/g, \"\");\n  }\n  /**\n   * PKCE: Generate a code verifier\n   */\n  static generateCodeVerifier() {\n    return _CryptoUtils.generateUUIDv4() + _CryptoUtils.generateUUIDv4() + _CryptoUtils.generateUUIDv4();\n  }\n  /**\n   * PKCE: Generate a code challenge\n   */\n  static async generateCodeChallenge(code_verifier) {\n    if (!crypto.subtle) {\n      throw new Error(\"Crypto.subtle is available only in secure contexts (HTTPS).\");\n    }\n    try {\n      const encoder = new TextEncoder();\n      const data = encoder.encode(code_verifier);\n      const hashed = await crypto.subtle.digest(\"SHA-256\", data);\n      return toBase64(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n    } catch (err) {\n      Logger.error(\"CryptoUtils.generateCodeChallenge\", err);\n      throw err;\n    }\n  }\n  /**\n   * Generates a base64-encoded string for a basic auth header\n   */\n  static generateBasicAuth(client_id, client_secret) {\n    const encoder = new TextEncoder();\n    const data = encoder.encode([client_id, client_secret].join(\":\"));\n    return toBase64(data);\n  }\n  /**\n   * Generates a hash of a string using a given algorithm\n   * @param alg\n   * @param message\n   */\n  static async hash(alg, message) {\n    const msgUint8 = new TextEncoder().encode(message);\n    const hashBuffer = await crypto.subtle.digest(alg, msgUint8);\n    return new Uint8Array(hashBuffer);\n  }\n  /**\n   * Generates a rfc7638 compliant jwk thumbprint\n   * @param jwk\n   */\n  static async customCalculateJwkThumbprint(jwk) {\n    let jsonObject;\n    switch (jwk.kty) {\n      case \"RSA\":\n        jsonObject = {\n          \"e\": jwk.e,\n          \"kty\": jwk.kty,\n          \"n\": jwk.n\n        };\n        break;\n      case \"EC\":\n        jsonObject = {\n          \"crv\": jwk.crv,\n          \"kty\": jwk.kty,\n          \"x\": jwk.x,\n          \"y\": jwk.y\n        };\n        break;\n      case \"OKP\":\n        jsonObject = {\n          \"crv\": jwk.crv,\n          \"kty\": jwk.kty,\n          \"x\": jwk.x\n        };\n        break;\n      case \"oct\":\n        jsonObject = {\n          \"crv\": jwk.k,\n          \"kty\": jwk.kty\n        };\n        break;\n      default:\n        throw new Error(\"Unknown jwk type\");\n    }\n    const utf8encodedAndHashed = await _CryptoUtils.hash(\"SHA-256\", JSON.stringify(jsonObject));\n    return _CryptoUtils.encodeBase64Url(utf8encodedAndHashed);\n  }\n  static async generateDPoPProof({\n    url,\n    accessToken,\n    httpMethod,\n    keyPair,\n    nonce\n  }) {\n    let hashedToken;\n    let encodedHash;\n    const payload = {\n      \"jti\": window.crypto.randomUUID(),\n      \"htm\": httpMethod != null ? httpMethod : \"GET\",\n      \"htu\": url,\n      \"iat\": Math.floor(Date.now() / 1e3)\n    };\n    if (accessToken) {\n      hashedToken = await _CryptoUtils.hash(\"SHA-256\", accessToken);\n      encodedHash = _CryptoUtils.encodeBase64Url(hashedToken);\n      payload.ath = encodedHash;\n    }\n    if (nonce) {\n      payload.nonce = nonce;\n    }\n    try {\n      const publicJwk = await crypto.subtle.exportKey(\"jwk\", keyPair.publicKey);\n      const header = {\n        \"alg\": \"ES256\",\n        \"typ\": \"dpop+jwt\",\n        \"jwk\": {\n          \"crv\": publicJwk.crv,\n          \"kty\": publicJwk.kty,\n          \"x\": publicJwk.x,\n          \"y\": publicJwk.y\n        }\n      };\n      return await JwtUtils.generateSignedJwt(header, payload, keyPair.privateKey);\n    } catch (err) {\n      if (err instanceof TypeError) {\n        throw new Error(`Error exporting dpop public key: ${err.message}`);\n      } else {\n        throw err;\n      }\n    }\n  }\n  static async generateDPoPJkt(keyPair) {\n    try {\n      const publicJwk = await crypto.subtle.exportKey(\"jwk\", keyPair.publicKey);\n      return await _CryptoUtils.customCalculateJwkThumbprint(publicJwk);\n    } catch (err) {\n      if (err instanceof TypeError) {\n        throw new Error(`Could not retrieve dpop keys from storage: ${err.message}`);\n      } else {\n        throw err;\n      }\n    }\n  }\n  static async generateDPoPKeys() {\n    return await window.crypto.subtle.generateKey({\n      name: \"ECDSA\",\n      namedCurve: \"P-256\"\n    }, false, [\"sign\", \"verify\"]);\n  }\n  /**\n   * Generates a client assertion JWT for client_secret_jwt authentication\n   * @param client_id The client identifier\n   * @param client_secret The client secret\n   * @param audience The token endpoint URL (audience)\n   * @param algorithm The HMAC algorithm to use (HS256, HS384, HS512). Defaults to HS256\n   */\n  static async generateClientAssertionJwt(client_id, client_secret, audience, algorithm = \"HS256\") {\n    const now = Math.floor(Date.now() / 1e3);\n    const header = {\n      \"alg\": algorithm,\n      \"typ\": \"JWT\"\n    };\n    const payload = {\n      \"iss\": client_id,\n      \"sub\": client_id,\n      \"aud\": audience,\n      \"jti\": _CryptoUtils.generateUUIDv4(),\n      \"exp\": now + 300,\n      // 5 minutes\n      \"iat\": now\n    };\n    const hashMap = {\n      \"HS256\": \"SHA-256\",\n      \"HS384\": \"SHA-384\",\n      \"HS512\": \"SHA-512\"\n    };\n    const hashFunction = hashMap[algorithm];\n    if (!hashFunction) {\n      throw new Error(`Unsupported algorithm: ${algorithm}. Supported algorithms are: HS256, HS384, HS512`);\n    }\n    const encoder = new TextEncoder();\n    const secretKey = await crypto.subtle.importKey(\"raw\", encoder.encode(client_secret), {\n      name: \"HMAC\",\n      hash: hashFunction\n    }, false, [\"sign\"]);\n    return await JwtUtils.generateSignedJwtWithHmac(header, payload, secretKey);\n  }\n};\n/**\n * Generates a base64url encoded string\n */\n_CryptoUtils.encodeBase64Url = input => {\n  return toBase64(input).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n};\nvar CryptoUtils = _CryptoUtils;\n\n// src/utils/Event.ts\nvar Event = class {\n  constructor(_name) {\n    this._name = _name;\n    this._callbacks = [];\n    this._logger = new Logger(`Event('${this._name}')`);\n  }\n  addHandler(cb) {\n    this._callbacks.push(cb);\n    return () => this.removeHandler(cb);\n  }\n  removeHandler(cb) {\n    const idx = this._callbacks.lastIndexOf(cb);\n    if (idx >= 0) {\n      this._callbacks.splice(idx, 1);\n    }\n  }\n  async raise(...ev) {\n    this._logger.debug(\"raise:\", ...ev);\n    for (const cb of this._callbacks) {\n      await cb(...ev);\n    }\n  }\n};\n\n// src/utils/PopupUtils.ts\nvar PopupUtils = class {\n  /**\n   * Populates a map of window features with a placement centered in front of\n   * the current window. If no explicit width is given, a default value is\n   * binned into [800, 720, 600, 480, 360] based on the current window's width.\n   */\n  static center({\n    ...features\n  }) {\n    var _a, _b, _c;\n    if (features.width == null) features.width = (_a = [800, 720, 600, 480].find(width => width <= window.outerWidth / 1.618)) != null ? _a : 360;\n    (_b = features.left) != null ? _b : features.left = Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));\n    if (features.height != null) (_c = features.top) != null ? _c : features.top = Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));\n    return features;\n  }\n  static serialize(features) {\n    return Object.entries(features).filter(([, value]) => value != null).map(([key, value]) => `${key}=${typeof value !== \"boolean\" ? value : value ? \"yes\" : \"no\"}`).join(\",\");\n  }\n};\n\n// src/utils/Timer.ts\nvar Timer = class _Timer extends Event {\n  constructor() {\n    super(...arguments);\n    this._logger = new Logger(`Timer('${this._name}')`);\n    this._timerHandle = null;\n    this._expiration = 0;\n    this._callback = () => {\n      const diff = this._expiration - _Timer.getEpochTime();\n      this._logger.debug(\"timer completes in\", diff);\n      if (this._expiration <= _Timer.getEpochTime()) {\n        this.cancel();\n        void super.raise();\n      }\n    };\n  }\n  // get the time\n  static getEpochTime() {\n    return Math.floor(Date.now() / 1e3);\n  }\n  init(durationInSeconds) {\n    const logger2 = this._logger.create(\"init\");\n    durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);\n    const expiration = _Timer.getEpochTime() + durationInSeconds;\n    if (this.expiration === expiration && this._timerHandle) {\n      logger2.debug(\"skipping since already initialized for expiration at\", this.expiration);\n      return;\n    }\n    this.cancel();\n    logger2.debug(\"using duration\", durationInSeconds);\n    this._expiration = expiration;\n    const timerDurationInSeconds = Math.min(durationInSeconds, 5);\n    this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1e3);\n  }\n  get expiration() {\n    return this._expiration;\n  }\n  cancel() {\n    this._logger.create(\"cancel\");\n    if (this._timerHandle) {\n      clearInterval(this._timerHandle);\n      this._timerHandle = null;\n    }\n  }\n};\n\n// src/utils/UrlUtils.ts\nvar UrlUtils = class {\n  static readParams(url, responseMode = \"query\") {\n    if (!url) throw new TypeError(\"Invalid URL\");\n    const parsedUrl = new URL(url, \"http://127.0.0.1\");\n    const params = parsedUrl[responseMode === \"fragment\" ? \"hash\" : \"search\"];\n    return new URLSearchParams(params.slice(1));\n  }\n};\nvar URL_STATE_DELIMITER = \";\";\n\n// src/errors/ErrorResponse.ts\nvar ErrorResponse = class extends Error {\n  constructor(args, form) {\n    var _a, _b, _c;\n    super(args.error_description || args.error || \"\");\n    this.form = form;\n    /** Marker to detect class: \"ErrorResponse\" */\n    this.name = \"ErrorResponse\";\n    if (!args.error) {\n      Logger.error(\"ErrorResponse\", \"No error passed\");\n      throw new Error(\"No error passed\");\n    }\n    this.error = args.error;\n    this.error_description = (_a = args.error_description) != null ? _a : null;\n    this.error_uri = (_b = args.error_uri) != null ? _b : null;\n    this.state = args.userState;\n    this.session_state = (_c = args.session_state) != null ? _c : null;\n    this.url_state = args.url_state;\n  }\n};\n\n// src/errors/ErrorTimeout.ts\nvar ErrorTimeout = class extends Error {\n  constructor(message) {\n    super(message);\n    /** Marker to detect class: \"ErrorTimeout\" */\n    this.name = \"ErrorTimeout\";\n  }\n};\n\n// src/AccessTokenEvents.ts\nvar AccessTokenEvents = class {\n  constructor(args) {\n    this._logger = new Logger(\"AccessTokenEvents\");\n    this._expiringTimer = new Timer(\"Access token expiring\");\n    this._expiredTimer = new Timer(\"Access token expired\");\n    this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;\n  }\n  async load(container) {\n    const logger2 = this._logger.create(\"load\");\n    if (container.access_token && container.expires_in !== void 0) {\n      const duration = container.expires_in;\n      logger2.debug(\"access token present, remaining duration:\", duration);\n      if (duration > 0) {\n        let expiring = duration - this._expiringNotificationTimeInSeconds;\n        if (expiring <= 0) {\n          expiring = 1;\n        }\n        logger2.debug(\"registering expiring timer, raising in\", expiring, \"seconds\");\n        this._expiringTimer.init(expiring);\n      } else {\n        logger2.debug(\"canceling existing expiring timer because we're past expiration.\");\n        this._expiringTimer.cancel();\n      }\n      const expired = duration + 1;\n      logger2.debug(\"registering expired timer, raising in\", expired, \"seconds\");\n      this._expiredTimer.init(expired);\n    } else {\n      this._expiringTimer.cancel();\n      this._expiredTimer.cancel();\n    }\n  }\n  async unload() {\n    this._logger.debug(\"unload: canceling existing access token timers\");\n    this._expiringTimer.cancel();\n    this._expiredTimer.cancel();\n  }\n  /**\n   * Add callback: Raised prior to the access token expiring.\n   */\n  addAccessTokenExpiring(cb) {\n    return this._expiringTimer.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised prior to the access token expiring.\n   */\n  removeAccessTokenExpiring(cb) {\n    this._expiringTimer.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised after the access token has expired.\n   */\n  addAccessTokenExpired(cb) {\n    return this._expiredTimer.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised after the access token has expired.\n   */\n  removeAccessTokenExpired(cb) {\n    this._expiredTimer.removeHandler(cb);\n  }\n};\n\n// src/CheckSessionIFrame.ts\nvar CheckSessionIFrame = class {\n  constructor(_callback, _client_id, url, _intervalInSeconds, _stopOnError) {\n    this._callback = _callback;\n    this._client_id = _client_id;\n    this._intervalInSeconds = _intervalInSeconds;\n    this._stopOnError = _stopOnError;\n    this._logger = new Logger(\"CheckSessionIFrame\");\n    this._timer = null;\n    this._session_state = null;\n    this._message = e => {\n      if (e.origin === this._frame_origin && e.source === this._frame.contentWindow) {\n        if (e.data === \"error\") {\n          this._logger.error(\"error message from check session op iframe\");\n          if (this._stopOnError) {\n            this.stop();\n          }\n        } else if (e.data === \"changed\") {\n          this._logger.debug(\"changed message from check session op iframe\");\n          this.stop();\n          void this._callback();\n        } else {\n          this._logger.debug(e.data + \" message from check session op iframe\");\n        }\n      }\n    };\n    const parsedUrl = new URL(url);\n    this._frame_origin = parsedUrl.origin;\n    this._frame = window.document.createElement(\"iframe\");\n    this._frame.style.visibility = \"hidden\";\n    this._frame.style.position = \"fixed\";\n    this._frame.style.left = \"-1000px\";\n    this._frame.style.top = \"0\";\n    this._frame.width = \"0\";\n    this._frame.height = \"0\";\n    this._frame.src = parsedUrl.href;\n  }\n  load() {\n    return new Promise(resolve => {\n      this._frame.onload = () => {\n        resolve();\n      };\n      window.document.body.appendChild(this._frame);\n      window.addEventListener(\"message\", this._message, false);\n    });\n  }\n  start(session_state) {\n    if (this._session_state === session_state) {\n      return;\n    }\n    this._logger.create(\"start\");\n    this.stop();\n    this._session_state = session_state;\n    const send = () => {\n      if (!this._frame.contentWindow || !this._session_state) {\n        return;\n      }\n      this._frame.contentWindow.postMessage(this._client_id + \" \" + this._session_state, this._frame_origin);\n    };\n    send();\n    this._timer = setInterval(send, this._intervalInSeconds * 1e3);\n  }\n  stop() {\n    this._logger.create(\"stop\");\n    this._session_state = null;\n    if (this._timer) {\n      clearInterval(this._timer);\n      this._timer = null;\n    }\n  }\n};\n\n// src/InMemoryWebStorage.ts\nvar InMemoryWebStorage = class {\n  constructor() {\n    this._logger = new Logger(\"InMemoryWebStorage\");\n    this._data = {};\n  }\n  clear() {\n    this._logger.create(\"clear\");\n    this._data = {};\n  }\n  getItem(key) {\n    this._logger.create(`getItem('${key}')`);\n    return this._data[key];\n  }\n  setItem(key, value) {\n    this._logger.create(`setItem('${key}')`);\n    this._data[key] = value;\n  }\n  removeItem(key) {\n    this._logger.create(`removeItem('${key}')`);\n    delete this._data[key];\n  }\n  get length() {\n    return Object.getOwnPropertyNames(this._data).length;\n  }\n  key(index) {\n    return Object.getOwnPropertyNames(this._data)[index];\n  }\n};\n\n// src/errors/ErrorDPoPNonce.ts\nvar ErrorDPoPNonce = class extends Error {\n  constructor(nonce, message) {\n    super(message);\n    /** Marker to detect class: \"ErrorDPoPNonce\" */\n    this.name = \"ErrorDPoPNonce\";\n    this.nonce = nonce;\n  }\n};\n\n// src/JsonService.ts\nvar JsonService = class {\n  constructor(additionalContentTypes = [], _jwtHandler = null, _extraHeaders = {}) {\n    this._jwtHandler = _jwtHandler;\n    this._extraHeaders = _extraHeaders;\n    this._logger = new Logger(\"JsonService\");\n    this._contentTypes = [];\n    this._contentTypes.push(...additionalContentTypes, \"application/json\");\n    if (_jwtHandler) {\n      this._contentTypes.push(\"application/jwt\");\n    }\n  }\n  async fetchWithTimeout(input, init = {}) {\n    const {\n      timeoutInSeconds,\n      ...initFetch\n    } = init;\n    if (!timeoutInSeconds) {\n      return await fetch(input, initFetch);\n    }\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeoutInSeconds * 1e3);\n    try {\n      const response = await fetch(input, {\n        ...init,\n        signal: controller.signal\n      });\n      return response;\n    } catch (err) {\n      if (err instanceof DOMException && err.name === \"AbortError\") {\n        throw new ErrorTimeout(\"Network timed out\");\n      }\n      throw err;\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n  async getJson(url, {\n    token,\n    credentials,\n    timeoutInSeconds\n  } = {}) {\n    const logger2 = this._logger.create(\"getJson\");\n    const headers = {\n      \"Accept\": this._contentTypes.join(\", \")\n    };\n    if (token) {\n      logger2.debug(\"token passed, setting Authorization header\");\n      headers[\"Authorization\"] = \"Bearer \" + token;\n    }\n    this._appendExtraHeaders(headers);\n    let response;\n    try {\n      logger2.debug(\"url:\", url);\n      response = await this.fetchWithTimeout(url, {\n        method: \"GET\",\n        headers,\n        timeoutInSeconds,\n        credentials\n      });\n    } catch (err) {\n      logger2.error(\"Network Error\");\n      throw err;\n    }\n    logger2.debug(\"HTTP response received, status\", response.status);\n    const contentType = response.headers.get(\"Content-Type\");\n    if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n      logger2.throw(new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`));\n    }\n    if (response.ok && this._jwtHandler && (contentType == null ? void 0 : contentType.startsWith(\"application/jwt\"))) {\n      return await this._jwtHandler(await response.text());\n    }\n    let json;\n    try {\n      json = await response.json();\n    } catch (err) {\n      logger2.error(\"Error parsing JSON response\", err);\n      if (response.ok) throw err;\n      throw new Error(`${response.statusText} (${response.status})`);\n    }\n    if (!response.ok) {\n      logger2.error(\"Error from server:\", json);\n      if (json.error) {\n        throw new ErrorResponse(json);\n      }\n      throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n    }\n    return json;\n  }\n  async postForm(url, {\n    body,\n    basicAuth,\n    timeoutInSeconds,\n    initCredentials,\n    extraHeaders\n  }) {\n    const logger2 = this._logger.create(\"postForm\");\n    const headers = {\n      \"Accept\": this._contentTypes.join(\", \"),\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n      ...extraHeaders\n    };\n    if (basicAuth !== void 0) {\n      headers[\"Authorization\"] = \"Basic \" + basicAuth;\n    }\n    this._appendExtraHeaders(headers);\n    let response;\n    try {\n      logger2.debug(\"url:\", url);\n      response = await this.fetchWithTimeout(url, {\n        method: \"POST\",\n        headers,\n        body,\n        timeoutInSeconds,\n        credentials: initCredentials\n      });\n    } catch (err) {\n      logger2.error(\"Network error\");\n      throw err;\n    }\n    logger2.debug(\"HTTP response received, status\", response.status);\n    const contentType = response.headers.get(\"Content-Type\");\n    if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n      throw new Error(`Invalid response Content-Type: ${contentType != null ? contentType : \"undefined\"}, from URL: ${url}`);\n    }\n    const responseText = await response.text();\n    let json = {};\n    if (responseText) {\n      try {\n        json = JSON.parse(responseText);\n      } catch (err) {\n        logger2.error(\"Error parsing JSON response\", err);\n        if (response.ok) throw err;\n        throw new Error(`${response.statusText} (${response.status})`);\n      }\n    }\n    if (!response.ok) {\n      logger2.error(\"Error from server:\", json);\n      if (response.headers.has(\"dpop-nonce\")) {\n        const nonce = response.headers.get(\"dpop-nonce\");\n        throw new ErrorDPoPNonce(nonce, `${JSON.stringify(json)}`);\n      }\n      if (json.error) {\n        throw new ErrorResponse(json, body);\n      }\n      throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n    }\n    return json;\n  }\n  _appendExtraHeaders(headers) {\n    const logger2 = this._logger.create(\"appendExtraHeaders\");\n    const customKeys = Object.keys(this._extraHeaders);\n    const protectedHeaders = [\"accept\", \"content-type\"];\n    const preventOverride = [\"authorization\"];\n    if (customKeys.length === 0) {\n      return;\n    }\n    customKeys.forEach(headerName => {\n      if (protectedHeaders.includes(headerName.toLocaleLowerCase())) {\n        logger2.warn(\"Protected header could not be set\", headerName, protectedHeaders);\n        return;\n      }\n      if (preventOverride.includes(headerName.toLocaleLowerCase()) && Object.keys(headers).includes(headerName)) {\n        logger2.warn(\"Header could not be overridden\", headerName, preventOverride);\n        return;\n      }\n      const content = typeof this._extraHeaders[headerName] === \"function\" ? this._extraHeaders[headerName]() : this._extraHeaders[headerName];\n      if (content && content !== \"\") {\n        headers[headerName] = content;\n      }\n    });\n  }\n};\n\n// src/MetadataService.ts\nvar MetadataService = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"MetadataService\");\n    this._signingKeys = null;\n    this._metadata = null;\n    this._metadataUrl = this._settings.metadataUrl;\n    this._jsonService = new JsonService([\"application/jwk-set+json\"], null, this._settings.extraHeaders);\n    if (this._settings.signingKeys) {\n      this._logger.debug(\"using signingKeys from settings\");\n      this._signingKeys = this._settings.signingKeys;\n    }\n    if (this._settings.metadata) {\n      this._logger.debug(\"using metadata from settings\");\n      this._metadata = this._settings.metadata;\n    }\n    if (this._settings.fetchRequestCredentials) {\n      this._logger.debug(\"using fetchRequestCredentials from settings\");\n      this._fetchRequestCredentials = this._settings.fetchRequestCredentials;\n    }\n  }\n  resetSigningKeys() {\n    this._signingKeys = null;\n  }\n  async getMetadata() {\n    const logger2 = this._logger.create(\"getMetadata\");\n    if (this._metadata) {\n      logger2.debug(\"using cached values\");\n      return this._metadata;\n    }\n    if (!this._metadataUrl) {\n      logger2.throw(new Error(\"No authority or metadataUrl configured on settings\"));\n      throw null;\n    }\n    logger2.debug(\"getting metadata from\", this._metadataUrl);\n    const metadata = await this._jsonService.getJson(this._metadataUrl, {\n      credentials: this._fetchRequestCredentials,\n      timeoutInSeconds: this._settings.requestTimeoutInSeconds\n    });\n    logger2.debug(\"merging remote JSON with seed metadata\");\n    this._metadata = Object.assign({}, metadata, this._settings.metadataSeed);\n    return this._metadata;\n  }\n  getIssuer() {\n    return this._getMetadataProperty(\"issuer\");\n  }\n  getAuthorizationEndpoint() {\n    return this._getMetadataProperty(\"authorization_endpoint\");\n  }\n  getUserInfoEndpoint() {\n    return this._getMetadataProperty(\"userinfo_endpoint\");\n  }\n  getTokenEndpoint(optional = true) {\n    return this._getMetadataProperty(\"token_endpoint\", optional);\n  }\n  getCheckSessionIframe() {\n    return this._getMetadataProperty(\"check_session_iframe\", true);\n  }\n  getEndSessionEndpoint() {\n    return this._getMetadataProperty(\"end_session_endpoint\", true);\n  }\n  getRevocationEndpoint(optional = true) {\n    return this._getMetadataProperty(\"revocation_endpoint\", optional);\n  }\n  getKeysEndpoint(optional = true) {\n    return this._getMetadataProperty(\"jwks_uri\", optional);\n  }\n  async _getMetadataProperty(name, optional = false) {\n    const logger2 = this._logger.create(`_getMetadataProperty('${name}')`);\n    const metadata = await this.getMetadata();\n    logger2.debug(\"resolved\");\n    if (metadata[name] === void 0) {\n      if (optional === true) {\n        logger2.warn(\"Metadata does not contain optional property\");\n        return void 0;\n      }\n      logger2.throw(new Error(\"Metadata does not contain property \" + name));\n    }\n    return metadata[name];\n  }\n  async getSigningKeys() {\n    const logger2 = this._logger.create(\"getSigningKeys\");\n    if (this._signingKeys) {\n      logger2.debug(\"returning signingKeys from cache\");\n      return this._signingKeys;\n    }\n    const jwks_uri = await this.getKeysEndpoint(false);\n    logger2.debug(\"got jwks_uri\", jwks_uri);\n    const keySet = await this._jsonService.getJson(jwks_uri, {\n      timeoutInSeconds: this._settings.requestTimeoutInSeconds\n    });\n    logger2.debug(\"got key set\", keySet);\n    if (!Array.isArray(keySet.keys)) {\n      logger2.throw(new Error(\"Missing keys on keyset\"));\n      throw null;\n    }\n    this._signingKeys = keySet.keys;\n    return this._signingKeys;\n  }\n};\n\n// src/WebStorageStateStore.ts\nvar WebStorageStateStore = class {\n  constructor({\n    prefix = \"oidc.\",\n    store = localStorage\n  } = {}) {\n    this._logger = new Logger(\"WebStorageStateStore\");\n    this._store = store;\n    this._prefix = prefix;\n  }\n  async set(key, value) {\n    this._logger.create(`set('${key}')`);\n    key = this._prefix + key;\n    await this._store.setItem(key, value);\n  }\n  async get(key) {\n    this._logger.create(`get('${key}')`);\n    key = this._prefix + key;\n    const item = await this._store.getItem(key);\n    return item;\n  }\n  async remove(key) {\n    this._logger.create(`remove('${key}')`);\n    key = this._prefix + key;\n    const item = await this._store.getItem(key);\n    await this._store.removeItem(key);\n    return item;\n  }\n  async getAllKeys() {\n    this._logger.create(\"getAllKeys\");\n    const len = await this._store.length;\n    const keys = [];\n    for (let index = 0; index < len; index++) {\n      const key = await this._store.key(index);\n      if (key && key.indexOf(this._prefix) === 0) {\n        keys.push(key.substr(this._prefix.length));\n      }\n    }\n    return keys;\n  }\n};\n\n// src/OidcClientSettings.ts\nvar DefaultResponseType = \"code\";\nvar DefaultScope = \"openid\";\nvar DefaultClientAuthentication = \"client_secret_post\";\nvar DefaultStaleStateAgeInSeconds = 60 * 15;\nvar OidcClientSettingsStore = class {\n  constructor({\n    // metadata related\n    authority,\n    metadataUrl,\n    metadata,\n    signingKeys,\n    metadataSeed,\n    // client related\n    client_id,\n    client_secret,\n    response_type = DefaultResponseType,\n    scope = DefaultScope,\n    redirect_uri,\n    post_logout_redirect_uri,\n    client_authentication = DefaultClientAuthentication,\n    token_endpoint_auth_signing_alg = \"HS256\",\n    // optional protocol\n    prompt,\n    display,\n    max_age,\n    ui_locales,\n    acr_values,\n    resource,\n    response_mode,\n    // behavior flags\n    filterProtocolClaims = true,\n    loadUserInfo = false,\n    requestTimeoutInSeconds,\n    staleStateAgeInSeconds = DefaultStaleStateAgeInSeconds,\n    mergeClaimsStrategy = {\n      array: \"replace\"\n    },\n    disablePKCE = false,\n    // other behavior\n    stateStore,\n    revokeTokenAdditionalContentTypes,\n    fetchRequestCredentials,\n    refreshTokenAllowedScope,\n    // extra\n    extraQueryParams = {},\n    extraTokenParams = {},\n    extraHeaders = {},\n    dpop,\n    omitScopeWhenRequesting = false\n  }) {\n    var _a;\n    this.authority = authority;\n    if (metadataUrl) {\n      this.metadataUrl = metadataUrl;\n    } else {\n      this.metadataUrl = authority;\n      if (authority) {\n        if (!this.metadataUrl.endsWith(\"/\")) {\n          this.metadataUrl += \"/\";\n        }\n        this.metadataUrl += \".well-known/openid-configuration\";\n      }\n    }\n    this.metadata = metadata;\n    this.metadataSeed = metadataSeed;\n    this.signingKeys = signingKeys;\n    this.client_id = client_id;\n    this.client_secret = client_secret;\n    this.response_type = response_type;\n    this.scope = scope;\n    this.redirect_uri = redirect_uri;\n    this.post_logout_redirect_uri = post_logout_redirect_uri;\n    this.client_authentication = client_authentication;\n    this.token_endpoint_auth_signing_alg = token_endpoint_auth_signing_alg;\n    this.prompt = prompt;\n    this.display = display;\n    this.max_age = max_age;\n    this.ui_locales = ui_locales;\n    this.acr_values = acr_values;\n    this.resource = resource;\n    this.response_mode = response_mode;\n    this.filterProtocolClaims = filterProtocolClaims != null ? filterProtocolClaims : true;\n    this.loadUserInfo = !!loadUserInfo;\n    this.staleStateAgeInSeconds = staleStateAgeInSeconds;\n    this.mergeClaimsStrategy = mergeClaimsStrategy;\n    this.omitScopeWhenRequesting = omitScopeWhenRequesting;\n    this.disablePKCE = !!disablePKCE;\n    this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;\n    this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials : \"same-origin\";\n    this.requestTimeoutInSeconds = requestTimeoutInSeconds;\n    if (stateStore) {\n      this.stateStore = stateStore;\n    } else {\n      const store = typeof window !== \"undefined\" ? window.localStorage : new InMemoryWebStorage();\n      this.stateStore = new WebStorageStateStore({\n        store\n      });\n    }\n    this.refreshTokenAllowedScope = refreshTokenAllowedScope;\n    this.extraQueryParams = extraQueryParams;\n    this.extraTokenParams = extraTokenParams;\n    this.extraHeaders = extraHeaders;\n    this.dpop = dpop;\n    if (this.dpop && !((_a = this.dpop) == null ? void 0 : _a.store)) {\n      throw new Error(\"A DPoPStore is required when dpop is enabled\");\n    }\n  }\n};\n\n// src/UserInfoService.ts\nvar UserInfoService = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"UserInfoService\");\n    this._getClaimsFromJwt = async responseText => {\n      const logger2 = this._logger.create(\"_getClaimsFromJwt\");\n      try {\n        const payload = JwtUtils.decode(responseText);\n        logger2.debug(\"JWT decoding successful\");\n        return payload;\n      } catch (err) {\n        logger2.error(\"Error parsing JWT response\");\n        throw err;\n      }\n    };\n    this._jsonService = new JsonService(void 0, this._getClaimsFromJwt, this._settings.extraHeaders);\n  }\n  async getClaims(token) {\n    const logger2 = this._logger.create(\"getClaims\");\n    if (!token) {\n      this._logger.throw(new Error(\"No token passed\"));\n    }\n    const url = await this._metadataService.getUserInfoEndpoint();\n    logger2.debug(\"got userinfo url\", url);\n    const claims = await this._jsonService.getJson(url, {\n      token,\n      credentials: this._settings.fetchRequestCredentials,\n      timeoutInSeconds: this._settings.requestTimeoutInSeconds\n    });\n    logger2.debug(\"got claims\", claims);\n    return claims;\n  }\n};\n\n// src/TokenClient.ts\nvar TokenClient = class {\n  constructor(_settings, _metadataService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._logger = new Logger(\"TokenClient\");\n    this._jsonService = new JsonService(this._settings.revokeTokenAdditionalContentTypes, null, this._settings.extraHeaders);\n  }\n  /**\n   * Exchange code.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3\n   */\n  async exchangeCode({\n    grant_type = \"authorization_code\",\n    redirect_uri = this._settings.redirect_uri,\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    extraHeaders,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeCode\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    if (!redirect_uri) {\n      logger2.throw(new Error(\"A redirect_uri is required\"));\n    }\n    if (!args.code) {\n      logger2.throw(new Error(\"A code is required\"));\n    }\n    const params = new URLSearchParams({\n      grant_type,\n      redirect_uri\n    });\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    if ((this._settings.client_authentication === \"client_secret_basic\" || this._settings.client_authentication === \"client_secret_jwt\") && (client_secret === void 0 || client_secret === null)) {\n      logger2.throw(new Error(\"A client_secret is required\"));\n      throw null;\n    }\n    let basicAuth;\n    const url = await this._metadataService.getTokenEndpoint(false);\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n      case \"client_secret_jwt\":\n        {\n          const clientAssertion = await CryptoUtils.generateClientAssertionJwt(client_id, client_secret, url, this._settings.token_endpoint_auth_signing_alg);\n          params.append(\"client_id\", client_id);\n          params.append(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n          params.append(\"client_assertion\", clientAssertion);\n          break;\n        }\n    }\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, {\n      body: params,\n      basicAuth,\n      timeoutInSeconds: this._settings.requestTimeoutInSeconds,\n      initCredentials: this._settings.fetchRequestCredentials,\n      extraHeaders\n    });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Exchange credentials.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.3.2\n   */\n  async exchangeCredentials({\n    grant_type = \"password\",\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    scope = this._settings.scope,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeCredentials\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    const params = new URLSearchParams({\n      grant_type\n    });\n    if (!this._settings.omitScopeWhenRequesting) {\n      params.set(\"scope\", scope);\n    }\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    if ((this._settings.client_authentication === \"client_secret_basic\" || this._settings.client_authentication === \"client_secret_jwt\") && (client_secret === void 0 || client_secret === null)) {\n      logger2.throw(new Error(\"A client_secret is required\"));\n      throw null;\n    }\n    let basicAuth;\n    const url = await this._metadataService.getTokenEndpoint(false);\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n      case \"client_secret_jwt\":\n        {\n          const clientAssertion = await CryptoUtils.generateClientAssertionJwt(client_id, client_secret, url, this._settings.token_endpoint_auth_signing_alg);\n          params.append(\"client_id\", client_id);\n          params.append(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n          params.append(\"client_assertion\", clientAssertion);\n          break;\n        }\n    }\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, {\n      body: params,\n      basicAuth,\n      timeoutInSeconds: this._settings.requestTimeoutInSeconds,\n      initCredentials: this._settings.fetchRequestCredentials\n    });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Exchange a refresh token.\n   *\n   * @see https://www.rfc-editor.org/rfc/rfc6749#section-6\n   */\n  async exchangeRefreshToken({\n    grant_type = \"refresh_token\",\n    client_id = this._settings.client_id,\n    client_secret = this._settings.client_secret,\n    timeoutInSeconds,\n    extraHeaders,\n    ...args\n  }) {\n    const logger2 = this._logger.create(\"exchangeRefreshToken\");\n    if (!client_id) {\n      logger2.throw(new Error(\"A client_id is required\"));\n    }\n    if (!args.refresh_token) {\n      logger2.throw(new Error(\"A refresh_token is required\"));\n    }\n    const params = new URLSearchParams({\n      grant_type\n    });\n    for (const [key, value] of Object.entries(args)) {\n      if (Array.isArray(value)) {\n        value.forEach(param => params.append(key, param));\n      } else if (value != null) {\n        params.set(key, value);\n      }\n    }\n    if ((this._settings.client_authentication === \"client_secret_basic\" || this._settings.client_authentication === \"client_secret_jwt\") && (client_secret === void 0 || client_secret === null)) {\n      logger2.throw(new Error(\"A client_secret is required\"));\n      throw null;\n    }\n    let basicAuth;\n    const url = await this._metadataService.getTokenEndpoint(false);\n    switch (this._settings.client_authentication) {\n      case \"client_secret_basic\":\n        basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret);\n        break;\n      case \"client_secret_post\":\n        params.append(\"client_id\", client_id);\n        if (client_secret) {\n          params.append(\"client_secret\", client_secret);\n        }\n        break;\n      case \"client_secret_jwt\":\n        {\n          const clientAssertion = await CryptoUtils.generateClientAssertionJwt(client_id, client_secret, url, this._settings.token_endpoint_auth_signing_alg);\n          params.append(\"client_id\", client_id);\n          params.append(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n          params.append(\"client_assertion\", clientAssertion);\n          break;\n        }\n    }\n    logger2.debug(\"got token endpoint\");\n    const response = await this._jsonService.postForm(url, {\n      body: params,\n      basicAuth,\n      timeoutInSeconds,\n      initCredentials: this._settings.fetchRequestCredentials,\n      extraHeaders\n    });\n    logger2.debug(\"got response\");\n    return response;\n  }\n  /**\n   * Revoke an access or refresh token.\n   *\n   * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1\n   */\n  async revoke(args) {\n    var _a;\n    const logger2 = this._logger.create(\"revoke\");\n    if (!args.token) {\n      logger2.throw(new Error(\"A token is required\"));\n    }\n    const url = await this._metadataService.getRevocationEndpoint(false);\n    logger2.debug(`got revocation endpoint, revoking ${(_a = args.token_type_hint) != null ? _a : \"default token type\"}`);\n    const params = new URLSearchParams();\n    for (const [key, value] of Object.entries(args)) {\n      if (value != null) {\n        params.set(key, value);\n      }\n    }\n    params.set(\"client_id\", this._settings.client_id);\n    if (this._settings.client_secret) {\n      params.set(\"client_secret\", this._settings.client_secret);\n    }\n    await this._jsonService.postForm(url, {\n      body: params,\n      timeoutInSeconds: this._settings.requestTimeoutInSeconds\n    });\n    logger2.debug(\"got response\");\n  }\n};\n\n// src/ResponseValidator.ts\nvar ResponseValidator = class {\n  constructor(_settings, _metadataService, _claimsService) {\n    this._settings = _settings;\n    this._metadataService = _metadataService;\n    this._claimsService = _claimsService;\n    this._logger = new Logger(\"ResponseValidator\");\n    this._userInfoService = new UserInfoService(this._settings, this._metadataService);\n    this._tokenClient = new TokenClient(this._settings, this._metadataService);\n  }\n  async validateSigninResponse(response, state, extraHeaders) {\n    const logger2 = this._logger.create(\"validateSigninResponse\");\n    this._processSigninState(response, state);\n    logger2.debug(\"state processed\");\n    await this._processCode(response, state, extraHeaders);\n    logger2.debug(\"code processed\");\n    if (response.isOpenId) {\n      this._validateIdTokenAttributes(response);\n    }\n    logger2.debug(\"tokens validated\");\n    await this._processClaims(response, state == null ? void 0 : state.skipUserInfo, response.isOpenId);\n    logger2.debug(\"claims processed\");\n  }\n  async validateCredentialsResponse(response, skipUserInfo) {\n    const logger2 = this._logger.create(\"validateCredentialsResponse\");\n    const shouldValidateSubClaim = response.isOpenId && !!response.id_token;\n    if (shouldValidateSubClaim) {\n      this._validateIdTokenAttributes(response);\n    }\n    logger2.debug(\"tokens validated\");\n    await this._processClaims(response, skipUserInfo, shouldValidateSubClaim);\n    logger2.debug(\"claims processed\");\n  }\n  async validateRefreshResponse(response, state) {\n    var _a, _b;\n    const logger2 = this._logger.create(\"validateRefreshResponse\");\n    response.userState = state.data;\n    (_a = response.session_state) != null ? _a : response.session_state = state.session_state;\n    (_b = response.scope) != null ? _b : response.scope = state.scope;\n    if (response.isOpenId && !!response.id_token) {\n      this._validateIdTokenAttributes(response, state.id_token);\n      logger2.debug(\"ID Token validated\");\n    }\n    if (!response.id_token) {\n      response.id_token = state.id_token;\n      response.profile = state.profile;\n    }\n    const hasIdToken = response.isOpenId && !!response.id_token;\n    await this._processClaims(response, false, hasIdToken);\n    logger2.debug(\"claims processed\");\n  }\n  validateSignoutResponse(response, state) {\n    const logger2 = this._logger.create(\"validateSignoutResponse\");\n    if (state.id !== response.state) {\n      logger2.throw(new Error(\"State does not match\"));\n    }\n    logger2.debug(\"state validated\");\n    response.userState = state.data;\n    if (response.error) {\n      logger2.warn(\"Response was error\", response.error);\n      throw new ErrorResponse(response);\n    }\n  }\n  _processSigninState(response, state) {\n    var _a;\n    const logger2 = this._logger.create(\"_processSigninState\");\n    if (state.id !== response.state) {\n      logger2.throw(new Error(\"State does not match\"));\n    }\n    if (!state.client_id) {\n      logger2.throw(new Error(\"No client_id on state\"));\n    }\n    if (!state.authority) {\n      logger2.throw(new Error(\"No authority on state\"));\n    }\n    if (this._settings.authority !== state.authority) {\n      logger2.throw(new Error(\"authority mismatch on settings vs. signin state\"));\n    }\n    if (this._settings.client_id && this._settings.client_id !== state.client_id) {\n      logger2.throw(new Error(\"client_id mismatch on settings vs. signin state\"));\n    }\n    logger2.debug(\"state validated\");\n    response.userState = state.data;\n    response.url_state = state.url_state;\n    (_a = response.scope) != null ? _a : response.scope = state.scope;\n    if (response.error) {\n      logger2.warn(\"Response was error\", response.error);\n      throw new ErrorResponse(response);\n    }\n    if (state.code_verifier && !response.code) {\n      logger2.throw(new Error(\"Expected code in response\"));\n    }\n  }\n  async _processClaims(response, skipUserInfo = false, validateSub = true) {\n    const logger2 = this._logger.create(\"_processClaims\");\n    response.profile = this._claimsService.filterProtocolClaims(response.profile);\n    if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {\n      logger2.debug(\"not loading user info\");\n      return;\n    }\n    logger2.debug(\"loading user info\");\n    const claims = await this._userInfoService.getClaims(response.access_token);\n    logger2.debug(\"user info claims received from user info endpoint\");\n    if (validateSub && claims.sub !== response.profile.sub) {\n      logger2.throw(new Error(\"subject from UserInfo response does not match subject in ID Token\"));\n    }\n    response.profile = this._claimsService.mergeClaims(response.profile, this._claimsService.filterProtocolClaims(claims));\n    logger2.debug(\"user info claims received, updated profile:\", response.profile);\n  }\n  async _processCode(response, state, extraHeaders) {\n    const logger2 = this._logger.create(\"_processCode\");\n    if (response.code) {\n      logger2.debug(\"Validating code\");\n      const tokenResponse = await this._tokenClient.exchangeCode({\n        client_id: state.client_id,\n        client_secret: state.client_secret,\n        code: response.code,\n        redirect_uri: state.redirect_uri,\n        code_verifier: state.code_verifier,\n        extraHeaders,\n        ...state.extraTokenParams\n      });\n      Object.assign(response, tokenResponse);\n    } else {\n      logger2.debug(\"No code to process\");\n    }\n  }\n  _validateIdTokenAttributes(response, existingToken) {\n    var _a;\n    const logger2 = this._logger.create(\"_validateIdTokenAttributes\");\n    logger2.debug(\"decoding ID Token JWT\");\n    const incoming = JwtUtils.decode((_a = response.id_token) != null ? _a : \"\");\n    if (!incoming.sub) {\n      logger2.throw(new Error(\"ID Token is missing a subject claim\"));\n    }\n    if (existingToken) {\n      const existing = JwtUtils.decode(existingToken);\n      if (incoming.sub !== existing.sub) {\n        logger2.throw(new Error(\"sub in id_token does not match current sub\"));\n      }\n      if (incoming.auth_time && incoming.auth_time !== existing.auth_time) {\n        logger2.throw(new Error(\"auth_time in id_token does not match original auth_time\"));\n      }\n      if (incoming.azp && incoming.azp !== existing.azp) {\n        logger2.throw(new Error(\"azp in id_token does not match original azp\"));\n      }\n      if (!incoming.azp && existing.azp) {\n        logger2.throw(new Error(\"azp not in id_token, but present in original id_token\"));\n      }\n    }\n    response.profile = incoming;\n  }\n};\n\n// src/State.ts\nvar State = class _State {\n  constructor(args) {\n    this.id = args.id || CryptoUtils.generateUUIDv4();\n    this.data = args.data;\n    if (args.created && args.created > 0) {\n      this.created = args.created;\n    } else {\n      this.created = Timer.getEpochTime();\n    }\n    this.request_type = args.request_type;\n    this.url_state = args.url_state;\n  }\n  toStorageString() {\n    new Logger(\"State\").create(\"toStorageString\");\n    return JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type,\n      url_state: this.url_state\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"State\", \"fromStorageString\");\n    return Promise.resolve(new _State(JSON.parse(storageString)));\n  }\n  static async clearStaleState(storage, age) {\n    const logger2 = Logger.createStatic(\"State\", \"clearStaleState\");\n    const cutoff = Timer.getEpochTime() - age;\n    const keys = await storage.getAllKeys();\n    logger2.debug(\"got keys\", keys);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const item = await storage.get(key);\n      let remove = false;\n      if (item) {\n        try {\n          const state = await _State.fromStorageString(item);\n          logger2.debug(\"got item from key:\", key, state.created);\n          if (state.created <= cutoff) {\n            remove = true;\n          }\n        } catch (err) {\n          logger2.error(\"Error parsing state for key:\", key, err);\n          remove = true;\n        }\n      } else {\n        logger2.debug(\"no item in storage for key:\", key);\n        remove = true;\n      }\n      if (remove) {\n        logger2.debug(\"removed item for key:\", key);\n        void storage.remove(key);\n      }\n    }\n  }\n};\n\n// src/SigninState.ts\nvar SigninState = class _SigninState extends State {\n  constructor(args) {\n    super(args);\n    this.code_verifier = args.code_verifier;\n    this.code_challenge = args.code_challenge;\n    this.authority = args.authority;\n    this.client_id = args.client_id;\n    this.redirect_uri = args.redirect_uri;\n    this.scope = args.scope;\n    this.client_secret = args.client_secret;\n    this.extraTokenParams = args.extraTokenParams;\n    this.response_mode = args.response_mode;\n    this.skipUserInfo = args.skipUserInfo;\n  }\n  static async create(args) {\n    const code_verifier = args.code_verifier === true ? CryptoUtils.generateCodeVerifier() : args.code_verifier || void 0;\n    const code_challenge = code_verifier ? await CryptoUtils.generateCodeChallenge(code_verifier) : void 0;\n    return new _SigninState({\n      ...args,\n      code_verifier,\n      code_challenge\n    });\n  }\n  toStorageString() {\n    new Logger(\"SigninState\").create(\"toStorageString\");\n    return JSON.stringify({\n      id: this.id,\n      data: this.data,\n      created: this.created,\n      request_type: this.request_type,\n      url_state: this.url_state,\n      code_verifier: this.code_verifier,\n      authority: this.authority,\n      client_id: this.client_id,\n      redirect_uri: this.redirect_uri,\n      scope: this.scope,\n      client_secret: this.client_secret,\n      extraTokenParams: this.extraTokenParams,\n      response_mode: this.response_mode,\n      skipUserInfo: this.skipUserInfo\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"SigninState\", \"fromStorageString\");\n    const data = JSON.parse(storageString);\n    return _SigninState.create(data);\n  }\n};\n\n// src/SigninRequest.ts\nvar _SigninRequest = class _SigninRequest {\n  constructor(args) {\n    this.url = args.url;\n    this.state = args.state;\n  }\n  static async create({\n    // mandatory\n    url,\n    authority,\n    client_id,\n    redirect_uri,\n    response_type,\n    scope,\n    // optional\n    state_data,\n    response_mode,\n    request_type,\n    client_secret,\n    nonce,\n    url_state,\n    resource,\n    skipUserInfo,\n    extraQueryParams,\n    extraTokenParams,\n    disablePKCE,\n    dpopJkt,\n    omitScopeWhenRequesting,\n    ...optionalParams\n  }) {\n    if (!url) {\n      this._logger.error(\"create: No url passed\");\n      throw new Error(\"url\");\n    }\n    if (!client_id) {\n      this._logger.error(\"create: No client_id passed\");\n      throw new Error(\"client_id\");\n    }\n    if (!redirect_uri) {\n      this._logger.error(\"create: No redirect_uri passed\");\n      throw new Error(\"redirect_uri\");\n    }\n    if (!response_type) {\n      this._logger.error(\"create: No response_type passed\");\n      throw new Error(\"response_type\");\n    }\n    if (!scope) {\n      this._logger.error(\"create: No scope passed\");\n      throw new Error(\"scope\");\n    }\n    if (!authority) {\n      this._logger.error(\"create: No authority passed\");\n      throw new Error(\"authority\");\n    }\n    const state = await SigninState.create({\n      data: state_data,\n      request_type,\n      url_state,\n      code_verifier: !disablePKCE,\n      client_id,\n      authority,\n      redirect_uri,\n      response_mode,\n      client_secret,\n      scope,\n      extraTokenParams,\n      skipUserInfo\n    });\n    const parsedUrl = new URL(url);\n    parsedUrl.searchParams.append(\"client_id\", client_id);\n    parsedUrl.searchParams.append(\"redirect_uri\", redirect_uri);\n    parsedUrl.searchParams.append(\"response_type\", response_type);\n    if (!omitScopeWhenRequesting) {\n      parsedUrl.searchParams.append(\"scope\", scope);\n    }\n    if (nonce) {\n      parsedUrl.searchParams.append(\"nonce\", nonce);\n    }\n    if (dpopJkt) {\n      parsedUrl.searchParams.append(\"dpop_jkt\", dpopJkt);\n    }\n    let stateParam = state.id;\n    if (url_state) {\n      stateParam = `${stateParam}${URL_STATE_DELIMITER}${url_state}`;\n    }\n    parsedUrl.searchParams.append(\"state\", stateParam);\n    if (state.code_challenge) {\n      parsedUrl.searchParams.append(\"code_challenge\", state.code_challenge);\n      parsedUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n    }\n    if (resource) {\n      const resources = Array.isArray(resource) ? resource : [resource];\n      resources.forEach(r => parsedUrl.searchParams.append(\"resource\", r));\n    }\n    for (const [key, value] of Object.entries({\n      response_mode,\n      ...optionalParams,\n      ...extraQueryParams\n    })) {\n      if (value != null) {\n        parsedUrl.searchParams.append(key, value.toString());\n      }\n    }\n    return new _SigninRequest({\n      url: parsedUrl.href,\n      state\n    });\n  }\n};\n_SigninRequest._logger = new Logger(\"SigninRequest\");\nvar SigninRequest = _SigninRequest;\n\n// src/SigninResponse.ts\nvar OidcScope = \"openid\";\nvar SigninResponse = class {\n  constructor(params) {\n    /** @see {@link User.access_token} */\n    this.access_token = \"\";\n    /** @see {@link User.token_type} */\n    this.token_type = \"\";\n    /** @see {@link User.profile} */\n    this.profile = {};\n    this.state = params.get(\"state\");\n    this.session_state = params.get(\"session_state\");\n    if (this.state) {\n      const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);\n      this.state = splitState[0];\n      if (splitState.length > 1) {\n        this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);\n      }\n    }\n    this.error = params.get(\"error\");\n    this.error_description = params.get(\"error_description\");\n    this.error_uri = params.get(\"error_uri\");\n    this.code = params.get(\"code\");\n  }\n  get expires_in() {\n    if (this.expires_at === void 0) {\n      return void 0;\n    }\n    return this.expires_at - Timer.getEpochTime();\n  }\n  set expires_in(value) {\n    if (typeof value === \"string\") value = Number(value);\n    if (value !== void 0 && value >= 0) {\n      this.expires_at = Math.floor(value) + Timer.getEpochTime();\n    }\n  }\n  get isOpenId() {\n    var _a;\n    return ((_a = this.scope) == null ? void 0 : _a.split(\" \").includes(OidcScope)) || !!this.id_token;\n  }\n};\n\n// src/SignoutRequest.ts\nvar SignoutRequest = class {\n  constructor({\n    url,\n    state_data,\n    id_token_hint,\n    post_logout_redirect_uri,\n    extraQueryParams,\n    request_type,\n    client_id,\n    url_state\n  }) {\n    this._logger = new Logger(\"SignoutRequest\");\n    if (!url) {\n      this._logger.error(\"ctor: No url passed\");\n      throw new Error(\"url\");\n    }\n    const parsedUrl = new URL(url);\n    if (id_token_hint) {\n      parsedUrl.searchParams.append(\"id_token_hint\", id_token_hint);\n    }\n    if (client_id) {\n      parsedUrl.searchParams.append(\"client_id\", client_id);\n    }\n    if (post_logout_redirect_uri) {\n      parsedUrl.searchParams.append(\"post_logout_redirect_uri\", post_logout_redirect_uri);\n      if (state_data || url_state) {\n        this.state = new State({\n          data: state_data,\n          request_type,\n          url_state\n        });\n        let stateParam = this.state.id;\n        if (url_state) {\n          stateParam = `${stateParam}${URL_STATE_DELIMITER}${url_state}`;\n        }\n        parsedUrl.searchParams.append(\"state\", stateParam);\n      }\n    }\n    for (const [key, value] of Object.entries({\n      ...extraQueryParams\n    })) {\n      if (value != null) {\n        parsedUrl.searchParams.append(key, value.toString());\n      }\n    }\n    this.url = parsedUrl.href;\n  }\n};\n\n// src/SignoutResponse.ts\nvar SignoutResponse = class {\n  constructor(params) {\n    this.state = params.get(\"state\");\n    if (this.state) {\n      const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);\n      this.state = splitState[0];\n      if (splitState.length > 1) {\n        this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);\n      }\n    }\n    this.error = params.get(\"error\");\n    this.error_description = params.get(\"error_description\");\n    this.error_uri = params.get(\"error_uri\");\n  }\n};\n\n// src/ClaimsService.ts\nvar DefaultProtocolClaims = [\"nbf\", \"jti\", \"auth_time\", \"nonce\", \"acr\", \"amr\", \"azp\", \"at_hash\"\n// https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken\n];\nvar InternalRequiredProtocolClaims = [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"];\nvar ClaimsService = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"ClaimsService\");\n  }\n  filterProtocolClaims(claims) {\n    const result = {\n      ...claims\n    };\n    if (this._settings.filterProtocolClaims) {\n      let protocolClaims;\n      if (Array.isArray(this._settings.filterProtocolClaims)) {\n        protocolClaims = this._settings.filterProtocolClaims;\n      } else {\n        protocolClaims = DefaultProtocolClaims;\n      }\n      for (const claim of protocolClaims) {\n        if (!InternalRequiredProtocolClaims.includes(claim)) {\n          delete result[claim];\n        }\n      }\n    }\n    return result;\n  }\n  mergeClaims(claims1, claims2) {\n    const result = {\n      ...claims1\n    };\n    for (const [claim, values] of Object.entries(claims2)) {\n      if (result[claim] !== values) {\n        if (Array.isArray(result[claim]) || Array.isArray(values)) {\n          if (this._settings.mergeClaimsStrategy.array == \"replace\") {\n            result[claim] = values;\n          } else {\n            const mergedValues = Array.isArray(result[claim]) ? result[claim] : [result[claim]];\n            for (const value of Array.isArray(values) ? values : [values]) {\n              if (!mergedValues.includes(value)) {\n                mergedValues.push(value);\n              }\n            }\n            result[claim] = mergedValues;\n          }\n        } else if (typeof result[claim] === \"object\" && typeof values === \"object\") {\n          result[claim] = this.mergeClaims(result[claim], values);\n        } else {\n          result[claim] = values;\n        }\n      }\n    }\n    return result;\n  }\n};\n\n// src/DPoPStore.ts\nvar DPoPState = class {\n  constructor(keys, nonce) {\n    this.keys = keys;\n    this.nonce = nonce;\n  }\n};\n\n// src/OidcClient.ts\nvar OidcClient = class {\n  constructor(settings, metadataService) {\n    this._logger = new Logger(\"OidcClient\");\n    this.settings = settings instanceof OidcClientSettingsStore ? settings : new OidcClientSettingsStore(settings);\n    this.metadataService = metadataService != null ? metadataService : new MetadataService(this.settings);\n    this._claimsService = new ClaimsService(this.settings);\n    this._validator = new ResponseValidator(this.settings, this.metadataService, this._claimsService);\n    this._tokenClient = new TokenClient(this.settings, this.metadataService);\n  }\n  async createSigninRequest({\n    state,\n    request,\n    request_uri,\n    request_type,\n    id_token_hint,\n    login_hint,\n    skipUserInfo,\n    nonce,\n    url_state,\n    response_type = this.settings.response_type,\n    scope = this.settings.scope,\n    redirect_uri = this.settings.redirect_uri,\n    prompt = this.settings.prompt,\n    display = this.settings.display,\n    max_age = this.settings.max_age,\n    ui_locales = this.settings.ui_locales,\n    acr_values = this.settings.acr_values,\n    resource = this.settings.resource,\n    response_mode = this.settings.response_mode,\n    extraQueryParams = this.settings.extraQueryParams,\n    extraTokenParams = this.settings.extraTokenParams,\n    dpopJkt,\n    omitScopeWhenRequesting = this.settings.omitScopeWhenRequesting\n  }) {\n    const logger2 = this._logger.create(\"createSigninRequest\");\n    if (response_type !== \"code\") {\n      throw new Error(\"Only the Authorization Code flow (with PKCE) is supported\");\n    }\n    const url = await this.metadataService.getAuthorizationEndpoint();\n    logger2.debug(\"Received authorization endpoint\", url);\n    const signinRequest = await SigninRequest.create({\n      url,\n      authority: this.settings.authority,\n      client_id: this.settings.client_id,\n      redirect_uri,\n      response_type,\n      scope,\n      state_data: state,\n      url_state,\n      prompt,\n      display,\n      max_age,\n      ui_locales,\n      id_token_hint,\n      login_hint,\n      acr_values,\n      dpopJkt,\n      resource,\n      request,\n      request_uri,\n      extraQueryParams,\n      extraTokenParams,\n      request_type,\n      response_mode,\n      client_secret: this.settings.client_secret,\n      skipUserInfo,\n      nonce,\n      disablePKCE: this.settings.disablePKCE,\n      omitScopeWhenRequesting\n    });\n    await this.clearStaleState();\n    const signinState = signinRequest.state;\n    await this.settings.stateStore.set(signinState.id, signinState.toStorageString());\n    return signinRequest;\n  }\n  async readSigninResponseState(url, removeState = false) {\n    const logger2 = this._logger.create(\"readSigninResponseState\");\n    const response = new SigninResponse(UrlUtils.readParams(url, this.settings.response_mode));\n    if (!response.state) {\n      logger2.throw(new Error(\"No state in response\"));\n      throw null;\n    }\n    const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n    if (!storedStateString) {\n      logger2.throw(new Error(\"No matching state found in storage\"));\n      throw null;\n    }\n    const state = await SigninState.fromStorageString(storedStateString);\n    return {\n      state,\n      response\n    };\n  }\n  async processSigninResponse(url, extraHeaders, removeState = true) {\n    const logger2 = this._logger.create(\"processSigninResponse\");\n    const {\n      state,\n      response\n    } = await this.readSigninResponseState(url, removeState);\n    logger2.debug(\"received state from storage; validating response\");\n    if (this.settings.dpop && this.settings.dpop.store) {\n      const dpopProof = await this.getDpopProof(this.settings.dpop.store);\n      extraHeaders = {\n        ...extraHeaders,\n        \"DPoP\": dpopProof\n      };\n    }\n    try {\n      await this._validator.validateSigninResponse(response, state, extraHeaders);\n    } catch (err) {\n      if (err instanceof ErrorDPoPNonce && this.settings.dpop) {\n        const dpopProof = await this.getDpopProof(this.settings.dpop.store, err.nonce);\n        extraHeaders[\"DPoP\"] = dpopProof;\n        await this._validator.validateSigninResponse(response, state, extraHeaders);\n      } else {\n        throw err;\n      }\n    }\n    return response;\n  }\n  async getDpopProof(dpopStore, nonce) {\n    let keyPair;\n    let dpopState;\n    if (!(await dpopStore.getAllKeys()).includes(this.settings.client_id)) {\n      keyPair = await CryptoUtils.generateDPoPKeys();\n      dpopState = new DPoPState(keyPair, nonce);\n      await dpopStore.set(this.settings.client_id, dpopState);\n    } else {\n      dpopState = await dpopStore.get(this.settings.client_id);\n      if (dpopState.nonce !== nonce && nonce) {\n        dpopState.nonce = nonce;\n        await dpopStore.set(this.settings.client_id, dpopState);\n      }\n    }\n    return await CryptoUtils.generateDPoPProof({\n      url: await this.metadataService.getTokenEndpoint(false),\n      httpMethod: \"POST\",\n      keyPair: dpopState.keys,\n      nonce: dpopState.nonce\n    });\n  }\n  async processResourceOwnerPasswordCredentials({\n    username,\n    password,\n    skipUserInfo = false,\n    extraTokenParams = {}\n  }) {\n    const tokenResponse = await this._tokenClient.exchangeCredentials({\n      username,\n      password,\n      ...extraTokenParams\n    });\n    const signinResponse = new SigninResponse(new URLSearchParams());\n    Object.assign(signinResponse, tokenResponse);\n    await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);\n    return signinResponse;\n  }\n  async useRefreshToken({\n    state,\n    redirect_uri,\n    resource,\n    timeoutInSeconds,\n    extraHeaders,\n    extraTokenParams\n  }) {\n    var _a;\n    const logger2 = this._logger.create(\"useRefreshToken\");\n    let scope;\n    if (this.settings.refreshTokenAllowedScope === void 0) {\n      scope = state.scope;\n    } else {\n      const allowableScopes = this.settings.refreshTokenAllowedScope.split(\" \");\n      const providedScopes = ((_a = state.scope) == null ? void 0 : _a.split(\" \")) || [];\n      scope = providedScopes.filter(s => allowableScopes.includes(s)).join(\" \");\n    }\n    if (this.settings.dpop && this.settings.dpop.store) {\n      const dpopProof = await this.getDpopProof(this.settings.dpop.store);\n      extraHeaders = {\n        ...extraHeaders,\n        \"DPoP\": dpopProof\n      };\n    }\n    let result;\n    try {\n      result = await this._tokenClient.exchangeRefreshToken({\n        refresh_token: state.refresh_token,\n        // provide the (possible filtered) scope list\n        scope,\n        redirect_uri,\n        resource,\n        timeoutInSeconds,\n        extraHeaders,\n        ...extraTokenParams\n      });\n    } catch (err) {\n      if (err instanceof ErrorDPoPNonce && this.settings.dpop) {\n        extraHeaders[\"DPoP\"] = await this.getDpopProof(this.settings.dpop.store, err.nonce);\n        result = await this._tokenClient.exchangeRefreshToken({\n          refresh_token: state.refresh_token,\n          // provide the (possible filtered) scope list\n          scope,\n          redirect_uri,\n          resource,\n          timeoutInSeconds,\n          extraHeaders,\n          ...extraTokenParams\n        });\n      } else {\n        throw err;\n      }\n    }\n    const response = new SigninResponse(new URLSearchParams());\n    Object.assign(response, result);\n    logger2.debug(\"validating response\", response);\n    await this._validator.validateRefreshResponse(response, {\n      ...state,\n      // override the scope in the state handed over to the validator\n      // so it can set the granted scope to the requested scope in case none is included in the response\n      scope\n    });\n    return response;\n  }\n  async createSignoutRequest({\n    state,\n    id_token_hint,\n    client_id,\n    request_type,\n    url_state,\n    post_logout_redirect_uri = this.settings.post_logout_redirect_uri,\n    extraQueryParams = this.settings.extraQueryParams\n  } = {}) {\n    const logger2 = this._logger.create(\"createSignoutRequest\");\n    const url = await this.metadataService.getEndSessionEndpoint();\n    if (!url) {\n      logger2.throw(new Error(\"No end session endpoint\"));\n      throw null;\n    }\n    logger2.debug(\"Received end session endpoint\", url);\n    if (!client_id && post_logout_redirect_uri && !id_token_hint) {\n      client_id = this.settings.client_id;\n    }\n    const request = new SignoutRequest({\n      url,\n      id_token_hint,\n      client_id,\n      post_logout_redirect_uri,\n      state_data: state,\n      extraQueryParams,\n      request_type,\n      url_state\n    });\n    await this.clearStaleState();\n    const signoutState = request.state;\n    if (signoutState) {\n      logger2.debug(\"Signout request has state to persist\");\n      await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());\n    }\n    return request;\n  }\n  async readSignoutResponseState(url, removeState = false) {\n    const logger2 = this._logger.create(\"readSignoutResponseState\");\n    const response = new SignoutResponse(UrlUtils.readParams(url, this.settings.response_mode));\n    if (!response.state) {\n      logger2.debug(\"No state in response\");\n      if (response.error) {\n        logger2.warn(\"Response was error:\", response.error);\n        throw new ErrorResponse(response);\n      }\n      return {\n        state: void 0,\n        response\n      };\n    }\n    const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n    if (!storedStateString) {\n      logger2.throw(new Error(\"No matching state found in storage\"));\n      throw null;\n    }\n    const state = await State.fromStorageString(storedStateString);\n    return {\n      state,\n      response\n    };\n  }\n  async processSignoutResponse(url) {\n    const logger2 = this._logger.create(\"processSignoutResponse\");\n    const {\n      state,\n      response\n    } = await this.readSignoutResponseState(url, true);\n    if (state) {\n      logger2.debug(\"Received state from storage; validating response\");\n      this._validator.validateSignoutResponse(response, state);\n    } else {\n      logger2.debug(\"No state from storage; skipping response validation\");\n    }\n    return response;\n  }\n  clearStaleState() {\n    this._logger.create(\"clearStaleState\");\n    return State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);\n  }\n  async revokeToken(token, type) {\n    this._logger.create(\"revokeToken\");\n    return await this._tokenClient.revoke({\n      token,\n      token_type_hint: type\n    });\n  }\n};\n\n// src/SessionMonitor.ts\nvar SessionMonitor = class {\n  constructor(_userManager) {\n    this._userManager = _userManager;\n    this._logger = new Logger(\"SessionMonitor\");\n    this._start = async user => {\n      const session_state = user.session_state;\n      if (!session_state) {\n        return;\n      }\n      const logger2 = this._logger.create(\"_start\");\n      if (user.profile) {\n        this._sub = user.profile.sub;\n        logger2.debug(\"session_state\", session_state, \", sub\", this._sub);\n      } else {\n        this._sub = void 0;\n        logger2.debug(\"session_state\", session_state, \", anonymous user\");\n      }\n      if (this._checkSessionIFrame) {\n        this._checkSessionIFrame.start(session_state);\n        return;\n      }\n      try {\n        const url = await this._userManager.metadataService.getCheckSessionIframe();\n        if (url) {\n          logger2.debug(\"initializing check session iframe\");\n          const client_id = this._userManager.settings.client_id;\n          const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;\n          const stopOnError = this._userManager.settings.stopCheckSessionOnError;\n          const checkSessionIFrame = new CheckSessionIFrame(this._callback, client_id, url, intervalInSeconds, stopOnError);\n          await checkSessionIFrame.load();\n          this._checkSessionIFrame = checkSessionIFrame;\n          checkSessionIFrame.start(session_state);\n        } else {\n          logger2.warn(\"no check session iframe found in the metadata\");\n        }\n      } catch (err) {\n        logger2.error(\"Error from getCheckSessionIframe:\", err instanceof Error ? err.message : err);\n      }\n    };\n    this._stop = () => {\n      const logger2 = this._logger.create(\"_stop\");\n      this._sub = void 0;\n      if (this._checkSessionIFrame) {\n        this._checkSessionIFrame.stop();\n      }\n      if (this._userManager.settings.monitorAnonymousSession) {\n        const timerHandle = setInterval(async () => {\n          clearInterval(timerHandle);\n          try {\n            const session = await this._userManager.querySessionStatus();\n            if (session) {\n              const tmpUser = {\n                session_state: session.session_state,\n                profile: session.sub ? {\n                  sub: session.sub\n                } : null\n              };\n              void this._start(tmpUser);\n            }\n          } catch (err) {\n            logger2.error(\"error from querySessionStatus\", err instanceof Error ? err.message : err);\n          }\n        }, 1e3);\n      }\n    };\n    this._callback = async () => {\n      const logger2 = this._logger.create(\"_callback\");\n      try {\n        const session = await this._userManager.querySessionStatus();\n        let raiseEvent = true;\n        if (session && this._checkSessionIFrame) {\n          if (session.sub === this._sub) {\n            raiseEvent = false;\n            this._checkSessionIFrame.start(session.session_state);\n            logger2.debug(\"same sub still logged in at OP, session state has changed, restarting check session iframe; session_state\", session.session_state);\n            await this._userManager.events._raiseUserSessionChanged();\n          } else {\n            logger2.debug(\"different subject signed into OP\", session.sub);\n          }\n        } else {\n          logger2.debug(\"subject no longer signed into OP\");\n        }\n        if (raiseEvent) {\n          if (this._sub) {\n            await this._userManager.events._raiseUserSignedOut();\n          } else {\n            await this._userManager.events._raiseUserSignedIn();\n          }\n        } else {\n          logger2.debug(\"no change in session detected, no event to raise\");\n        }\n      } catch (err) {\n        if (this._sub) {\n          logger2.debug(\"Error calling queryCurrentSigninSession; raising signed out event\", err);\n          await this._userManager.events._raiseUserSignedOut();\n        }\n      }\n    };\n    if (!_userManager) {\n      this._logger.throw(new Error(\"No user manager passed\"));\n    }\n    this._userManager.events.addUserLoaded(this._start);\n    this._userManager.events.addUserUnloaded(this._stop);\n    this._init().catch(err => {\n      this._logger.error(err);\n    });\n  }\n  async _init() {\n    this._logger.create(\"_init\");\n    const user = await this._userManager.getUser();\n    if (user) {\n      void this._start(user);\n    } else if (this._userManager.settings.monitorAnonymousSession) {\n      const session = await this._userManager.querySessionStatus();\n      if (session) {\n        const tmpUser = {\n          session_state: session.session_state,\n          profile: session.sub ? {\n            sub: session.sub\n          } : null\n        };\n        void this._start(tmpUser);\n      }\n    }\n  }\n};\n\n// src/User.ts\nvar User = class _User {\n  constructor(args) {\n    var _a;\n    this.id_token = args.id_token;\n    this.session_state = (_a = args.session_state) != null ? _a : null;\n    this.access_token = args.access_token;\n    this.refresh_token = args.refresh_token;\n    this.token_type = args.token_type;\n    this.scope = args.scope;\n    this.profile = args.profile;\n    this.expires_at = args.expires_at;\n    this.state = args.userState;\n    this.url_state = args.url_state;\n  }\n  /** Computed number of seconds the access token has remaining. */\n  get expires_in() {\n    if (this.expires_at === void 0) {\n      return void 0;\n    }\n    return this.expires_at - Timer.getEpochTime();\n  }\n  set expires_in(value) {\n    if (value !== void 0) {\n      this.expires_at = Math.floor(value) + Timer.getEpochTime();\n    }\n  }\n  /** Computed value indicating if the access token is expired. */\n  get expired() {\n    const expires_in = this.expires_in;\n    if (expires_in === void 0) {\n      return void 0;\n    }\n    return expires_in <= 0;\n  }\n  /** Array representing the parsed values from the `scope`. */\n  get scopes() {\n    var _a, _b;\n    return (_b = (_a = this.scope) == null ? void 0 : _a.split(\" \")) != null ? _b : [];\n  }\n  toStorageString() {\n    new Logger(\"User\").create(\"toStorageString\");\n    return JSON.stringify({\n      id_token: this.id_token,\n      session_state: this.session_state,\n      access_token: this.access_token,\n      refresh_token: this.refresh_token,\n      token_type: this.token_type,\n      scope: this.scope,\n      profile: this.profile,\n      expires_at: this.expires_at\n    });\n  }\n  static fromStorageString(storageString) {\n    Logger.createStatic(\"User\", \"fromStorageString\");\n    return new _User(JSON.parse(storageString));\n  }\n};\n\n// src/navigators/AbstractChildWindow.ts\nvar messageSource = \"oidc-client\";\nvar AbstractChildWindow = class {\n  constructor() {\n    this._abort = new Event(\"Window navigation aborted\");\n    this._disposeHandlers = /* @__PURE__ */new Set();\n    this._window = null;\n  }\n  async navigate(params) {\n    const logger2 = this._logger.create(\"navigate\");\n    if (!this._window) {\n      throw new Error(\"Attempted to navigate on a disposed window\");\n    }\n    logger2.debug(\"setting URL in window\");\n    this._window.location.replace(params.url);\n    const {\n      url,\n      keepOpen\n    } = await new Promise((resolve, reject) => {\n      const listener = e => {\n        var _a;\n        const data = e.data;\n        const origin = (_a = params.scriptOrigin) != null ? _a : window.location.origin;\n        if (e.origin !== origin || (data == null ? void 0 : data.source) !== messageSource) {\n          return;\n        }\n        try {\n          const state = UrlUtils.readParams(data.url, params.response_mode).get(\"state\");\n          if (!state) {\n            logger2.warn(\"no state found in response url\");\n          }\n          if (e.source !== this._window && state !== params.state) {\n            return;\n          }\n        } catch {\n          this._dispose();\n          reject(new Error(\"Invalid response from window\"));\n        }\n        resolve(data);\n      };\n      window.addEventListener(\"message\", listener, false);\n      this._disposeHandlers.add(() => window.removeEventListener(\"message\", listener, false));\n      const channel = new BroadcastChannel(`oidc-client-popup-${params.state}`);\n      channel.addEventListener(\"message\", listener, false);\n      this._disposeHandlers.add(() => channel.close());\n      this._disposeHandlers.add(this._abort.addHandler(reason => {\n        this._dispose();\n        reject(reason);\n      }));\n    });\n    logger2.debug(\"got response from window\");\n    this._dispose();\n    if (!keepOpen) {\n      this.close();\n    }\n    return {\n      url\n    };\n  }\n  _dispose() {\n    this._logger.create(\"_dispose\");\n    for (const dispose of this._disposeHandlers) {\n      dispose();\n    }\n    this._disposeHandlers.clear();\n  }\n  static _notifyParent(parent, url, keepOpen = false, targetOrigin = window.location.origin) {\n    const msgData = {\n      source: messageSource,\n      url,\n      keepOpen\n    };\n    const logger2 = new Logger(\"_notifyParent\");\n    if (parent) {\n      logger2.debug(\"With parent. Using parent.postMessage.\");\n      parent.postMessage(msgData, targetOrigin);\n    } else {\n      logger2.debug(\"No parent. Using BroadcastChannel.\");\n      const state = new URL(url).searchParams.get(\"state\");\n      if (!state) {\n        throw new Error(\"No parent and no state in URL. Can't complete notification.\");\n      }\n      const channel = new BroadcastChannel(`oidc-client-popup-${state}`);\n      channel.postMessage(msgData);\n      channel.close();\n    }\n  }\n};\n\n// src/UserManagerSettings.ts\nvar DefaultPopupWindowFeatures = {\n  location: false,\n  toolbar: false,\n  height: 640,\n  closePopupWindowAfterInSeconds: -1\n};\nvar DefaultPopupTarget = \"_blank\";\nvar DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;\nvar DefaultCheckSessionIntervalInSeconds = 2;\nvar DefaultSilentRequestTimeoutInSeconds = 10;\nvar UserManagerSettingsStore = class extends OidcClientSettingsStore {\n  constructor(args) {\n    const {\n      popup_redirect_uri = args.redirect_uri,\n      popup_post_logout_redirect_uri = args.post_logout_redirect_uri,\n      popupWindowFeatures = DefaultPopupWindowFeatures,\n      popupWindowTarget = DefaultPopupTarget,\n      redirectMethod = \"assign\",\n      redirectTarget = \"self\",\n      iframeNotifyParentOrigin = args.iframeNotifyParentOrigin,\n      iframeScriptOrigin = args.iframeScriptOrigin,\n      requestTimeoutInSeconds,\n      silent_redirect_uri = args.redirect_uri,\n      silentRequestTimeoutInSeconds,\n      automaticSilentRenew = true,\n      validateSubOnSilentRenew = true,\n      includeIdTokenInSilentRenew = false,\n      monitorSession = false,\n      monitorAnonymousSession = false,\n      checkSessionIntervalInSeconds = DefaultCheckSessionIntervalInSeconds,\n      query_status_response_type = \"code\",\n      stopCheckSessionOnError = true,\n      revokeTokenTypes = [\"access_token\", \"refresh_token\"],\n      revokeTokensOnSignout = false,\n      includeIdTokenInSilentSignout = false,\n      accessTokenExpiringNotificationTimeInSeconds = DefaultAccessTokenExpiringNotificationTimeInSeconds,\n      userStore\n    } = args;\n    super(args);\n    this.popup_redirect_uri = popup_redirect_uri;\n    this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;\n    this.popupWindowFeatures = popupWindowFeatures;\n    this.popupWindowTarget = popupWindowTarget;\n    this.redirectMethod = redirectMethod;\n    this.redirectTarget = redirectTarget;\n    this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;\n    this.iframeScriptOrigin = iframeScriptOrigin;\n    this.silent_redirect_uri = silent_redirect_uri;\n    this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds || requestTimeoutInSeconds || DefaultSilentRequestTimeoutInSeconds;\n    this.automaticSilentRenew = automaticSilentRenew;\n    this.validateSubOnSilentRenew = validateSubOnSilentRenew;\n    this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;\n    this.monitorSession = monitorSession;\n    this.monitorAnonymousSession = monitorAnonymousSession;\n    this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;\n    this.stopCheckSessionOnError = stopCheckSessionOnError;\n    this.query_status_response_type = query_status_response_type;\n    this.revokeTokenTypes = revokeTokenTypes;\n    this.revokeTokensOnSignout = revokeTokensOnSignout;\n    this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;\n    this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;\n    if (userStore) {\n      this.userStore = userStore;\n    } else {\n      const store = typeof window !== \"undefined\" ? window.sessionStorage : new InMemoryWebStorage();\n      this.userStore = new WebStorageStateStore({\n        store\n      });\n    }\n  }\n};\n\n// src/navigators/IFrameWindow.ts\nvar IFrameWindow = class _IFrameWindow extends AbstractChildWindow {\n  constructor({\n    silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds\n  }) {\n    super();\n    this._logger = new Logger(\"IFrameWindow\");\n    this._timeoutInSeconds = silentRequestTimeoutInSeconds;\n    this._frame = _IFrameWindow.createHiddenIframe();\n    this._window = this._frame.contentWindow;\n  }\n  static createHiddenIframe() {\n    const iframe = window.document.createElement(\"iframe\");\n    iframe.style.visibility = \"hidden\";\n    iframe.style.position = \"fixed\";\n    iframe.style.left = \"-1000px\";\n    iframe.style.top = \"0\";\n    iframe.width = \"0\";\n    iframe.height = \"0\";\n    window.document.body.appendChild(iframe);\n    return iframe;\n  }\n  async navigate(params) {\n    this._logger.debug(\"navigate: Using timeout of:\", this._timeoutInSeconds);\n    const timer = setTimeout(() => void this._abort.raise(new ErrorTimeout(\"IFrame timed out without a response\")), this._timeoutInSeconds * 1e3);\n    this._disposeHandlers.add(() => clearTimeout(timer));\n    return await super.navigate(params);\n  }\n  close() {\n    var _a;\n    if (this._frame) {\n      if (this._frame.parentNode) {\n        this._frame.addEventListener(\"load\", ev => {\n          var _a2;\n          const frame = ev.target;\n          (_a2 = frame.parentNode) == null ? void 0 : _a2.removeChild(frame);\n          void this._abort.raise(new Error(\"IFrame removed from DOM\"));\n        }, true);\n        (_a = this._frame.contentWindow) == null ? void 0 : _a.location.replace(\"about:blank\");\n      }\n      this._frame = null;\n    }\n    this._window = null;\n  }\n  static notifyParent(url, targetOrigin) {\n    return super._notifyParent(window.parent, url, false, targetOrigin);\n  }\n};\n\n// src/navigators/IFrameNavigator.ts\nvar IFrameNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"IFrameNavigator\");\n  }\n  async prepare({\n    silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds\n  }) {\n    return new IFrameWindow({\n      silentRequestTimeoutInSeconds\n    });\n  }\n  async callback(url) {\n    this._logger.create(\"callback\");\n    IFrameWindow.notifyParent(url, this._settings.iframeNotifyParentOrigin);\n  }\n};\n\n// src/navigators/PopupWindow.ts\nvar checkForPopupClosedInterval = 500;\nvar second = 1e3;\nvar PopupWindow = class extends AbstractChildWindow {\n  constructor({\n    popupWindowTarget = DefaultPopupTarget,\n    popupWindowFeatures = {},\n    popupSignal,\n    popupAbortOnClose\n  }) {\n    super();\n    this._logger = new Logger(\"PopupWindow\");\n    const centeredPopup = PopupUtils.center({\n      ...DefaultPopupWindowFeatures,\n      ...popupWindowFeatures\n    });\n    this._window = window.open(void 0, popupWindowTarget, PopupUtils.serialize(centeredPopup));\n    this.abortOnClose = Boolean(popupAbortOnClose);\n    if (popupSignal) {\n      popupSignal.addEventListener(\"abort\", () => {\n        var _a;\n        void this._abort.raise(new Error((_a = popupSignal.reason) != null ? _a : \"Popup aborted\"));\n      });\n    }\n    if (popupWindowFeatures.closePopupWindowAfterInSeconds && popupWindowFeatures.closePopupWindowAfterInSeconds > 0) {\n      setTimeout(() => {\n        if (!this._window || typeof this._window.closed !== \"boolean\" || this._window.closed) {\n          void this._abort.raise(new Error(\"Popup blocked by user\"));\n          return;\n        }\n        this.close();\n      }, popupWindowFeatures.closePopupWindowAfterInSeconds * second);\n    }\n  }\n  async navigate(params) {\n    var _a;\n    (_a = this._window) == null ? void 0 : _a.focus();\n    const popupClosedInterval = setInterval(() => {\n      if (!this._window || this._window.closed) {\n        this._logger.debug(\"Popup closed by user or isolated by redirect\");\n        clearPopupClosedInterval();\n        this._disposeHandlers.delete(clearPopupClosedInterval);\n        if (this.abortOnClose) {\n          void this._abort.raise(new Error(\"Popup closed by user\"));\n        }\n      }\n    }, checkForPopupClosedInterval);\n    const clearPopupClosedInterval = () => clearInterval(popupClosedInterval);\n    this._disposeHandlers.add(clearPopupClosedInterval);\n    return await super.navigate(params);\n  }\n  close() {\n    if (this._window) {\n      if (!this._window.closed) {\n        this._window.close();\n        void this._abort.raise(new Error(\"Popup closed\"));\n      }\n    }\n    this._window = null;\n  }\n  static notifyOpener(url, keepOpen) {\n    super._notifyParent(window.opener, url, keepOpen);\n    if (!keepOpen && !window.opener) {\n      window.close();\n    }\n  }\n};\n\n// src/navigators/PopupNavigator.ts\nvar PopupNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"PopupNavigator\");\n  }\n  async prepare({\n    popupWindowFeatures = this._settings.popupWindowFeatures,\n    popupWindowTarget = this._settings.popupWindowTarget,\n    popupSignal,\n    popupAbortOnClose\n  }) {\n    return new PopupWindow({\n      popupWindowFeatures,\n      popupWindowTarget,\n      popupSignal,\n      popupAbortOnClose\n    });\n  }\n  async callback(url, {\n    keepOpen = false\n  }) {\n    this._logger.create(\"callback\");\n    PopupWindow.notifyOpener(url, keepOpen);\n  }\n};\n\n// src/navigators/RedirectNavigator.ts\nvar RedirectNavigator = class {\n  constructor(_settings) {\n    this._settings = _settings;\n    this._logger = new Logger(\"RedirectNavigator\");\n  }\n  async prepare({\n    redirectMethod = this._settings.redirectMethod,\n    redirectTarget = this._settings.redirectTarget\n  }) {\n    var _a;\n    this._logger.create(\"prepare\");\n    let targetWindow = window.self;\n    if (redirectTarget === \"top\") {\n      targetWindow = (_a = window.top) != null ? _a : window.self;\n    }\n    const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location);\n    let abort;\n    return {\n      navigate: async params => {\n        this._logger.create(\"navigate\");\n        const promise = new Promise((resolve, reject) => {\n          abort = reject;\n          window.addEventListener(\"pageshow\", () => resolve(window.location.href));\n          redirect(params.url);\n        });\n        return await promise;\n      },\n      close: () => {\n        this._logger.create(\"close\");\n        abort == null ? void 0 : abort(new Error(\"Redirect aborted\"));\n        targetWindow.stop();\n      }\n    };\n  }\n  async callback() {\n    return;\n  }\n};\n\n// src/UserManagerEvents.ts\nvar UserManagerEvents = class extends AccessTokenEvents {\n  constructor(settings) {\n    super({\n      expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds\n    });\n    this._logger = new Logger(\"UserManagerEvents\");\n    this._userLoaded = new Event(\"User loaded\");\n    this._userUnloaded = new Event(\"User unloaded\");\n    this._silentRenewError = new Event(\"Silent renew error\");\n    this._userSignedIn = new Event(\"User signed in\");\n    this._userSignedOut = new Event(\"User signed out\");\n    this._userSessionChanged = new Event(\"User session changed\");\n  }\n  async load(user, raiseEvent = true) {\n    await super.load(user);\n    if (raiseEvent) {\n      await this._userLoaded.raise(user);\n    }\n  }\n  async unload() {\n    await super.unload();\n    await this._userUnloaded.raise();\n  }\n  /**\n   * Add callback: Raised when a user session has been established (or re-established).\n   */\n  addUserLoaded(cb) {\n    return this._userLoaded.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when a user session has been established (or re-established).\n   */\n  removeUserLoaded(cb) {\n    return this._userLoaded.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised when a user session has been terminated.\n   */\n  addUserUnloaded(cb) {\n    return this._userUnloaded.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when a user session has been terminated.\n   */\n  removeUserUnloaded(cb) {\n    return this._userUnloaded.removeHandler(cb);\n  }\n  /**\n   * Add callback: Raised when the automatic silent renew has failed.\n   */\n  addSilentRenewError(cb) {\n    return this._silentRenewError.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the automatic silent renew has failed.\n   */\n  removeSilentRenewError(cb) {\n    return this._silentRenewError.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  async _raiseSilentRenewError(e) {\n    await this._silentRenewError.raise(e);\n  }\n  /**\n   * Add callback: Raised when the user is signed in (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSignedIn(cb) {\n    return this._userSignedIn.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user is signed in (when `monitorSession` is set).\n   */\n  removeUserSignedIn(cb) {\n    this._userSignedIn.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  async _raiseUserSignedIn() {\n    await this._userSignedIn.raise();\n  }\n  /**\n   * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSignedOut(cb) {\n    return this._userSignedOut.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n   */\n  removeUserSignedOut(cb) {\n    this._userSignedOut.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  async _raiseUserSignedOut() {\n    await this._userSignedOut.raise();\n  }\n  /**\n   * Add callback: Raised when the user session changed (when `monitorSession` is set).\n   * @see {@link UserManagerSettings.monitorSession}\n   */\n  addUserSessionChanged(cb) {\n    return this._userSessionChanged.addHandler(cb);\n  }\n  /**\n   * Remove callback: Raised when the user session changed (when `monitorSession` is set).\n   */\n  removeUserSessionChanged(cb) {\n    this._userSessionChanged.removeHandler(cb);\n  }\n  /**\n   * @internal\n   */\n  async _raiseUserSessionChanged() {\n    await this._userSessionChanged.raise();\n  }\n};\n\n// src/SilentRenewService.ts\nvar SilentRenewService = class {\n  constructor(_userManager) {\n    this._userManager = _userManager;\n    this._logger = new Logger(\"SilentRenewService\");\n    this._isStarted = false;\n    this._retryTimer = new Timer(\"Retry Silent Renew\");\n    this._tokenExpiring = async () => {\n      const logger2 = this._logger.create(\"_tokenExpiring\");\n      try {\n        await this._userManager.signinSilent();\n        logger2.debug(\"silent token renewal successful\");\n      } catch (err) {\n        if (err instanceof ErrorTimeout) {\n          logger2.warn(\"ErrorTimeout from signinSilent:\", err, \"retry in 5s\");\n          this._retryTimer.init(5);\n          return;\n        }\n        logger2.error(\"Error from signinSilent:\", err);\n        await this._userManager.events._raiseSilentRenewError(err);\n      }\n    };\n  }\n  async start() {\n    const logger2 = this._logger.create(\"start\");\n    if (!this._isStarted) {\n      this._isStarted = true;\n      this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);\n      this._retryTimer.addHandler(this._tokenExpiring);\n      try {\n        await this._userManager.getUser();\n      } catch (err) {\n        logger2.error(\"getUser error\", err);\n      }\n    }\n  }\n  stop() {\n    if (this._isStarted) {\n      this._retryTimer.cancel();\n      this._retryTimer.removeHandler(this._tokenExpiring);\n      this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);\n      this._isStarted = false;\n    }\n  }\n};\n\n// src/RefreshState.ts\nvar RefreshState = class {\n  constructor(args) {\n    this.refresh_token = args.refresh_token;\n    this.id_token = args.id_token;\n    this.session_state = args.session_state;\n    this.scope = args.scope;\n    this.profile = args.profile;\n    this.data = args.state;\n  }\n};\n\n// src/UserManager.ts\nvar UserManager = class {\n  constructor(settings, redirectNavigator, popupNavigator, iframeNavigator) {\n    this._logger = new Logger(\"UserManager\");\n    this.settings = new UserManagerSettingsStore(settings);\n    this._client = new OidcClient(settings);\n    this._redirectNavigator = redirectNavigator != null ? redirectNavigator : new RedirectNavigator(this.settings);\n    this._popupNavigator = popupNavigator != null ? popupNavigator : new PopupNavigator(this.settings);\n    this._iframeNavigator = iframeNavigator != null ? iframeNavigator : new IFrameNavigator(this.settings);\n    this._events = new UserManagerEvents(this.settings);\n    this._silentRenewService = new SilentRenewService(this);\n    if (this.settings.automaticSilentRenew) {\n      this.startSilentRenew();\n    }\n    this._sessionMonitor = null;\n    if (this.settings.monitorSession) {\n      this._sessionMonitor = new SessionMonitor(this);\n    }\n  }\n  /**\n   * Get object used to register for events raised by the `UserManager`.\n   */\n  get events() {\n    return this._events;\n  }\n  /**\n   * Get object used to access the metadata configuration of the identity provider.\n   */\n  get metadataService() {\n    return this._client.metadataService;\n  }\n  /**\n   * Load the `User` object for the currently authenticated user.\n   *\n   * @param raiseEvent - If `true`, the `UserLoaded` event will be raised. Defaults to false.\n   * @returns A promise\n   */\n  async getUser(raiseEvent = false) {\n    const logger2 = this._logger.create(\"getUser\");\n    const user = await this._loadUser();\n    if (user) {\n      logger2.info(\"user loaded\");\n      await this._events.load(user, raiseEvent);\n      return user;\n    }\n    logger2.info(\"user not found in storage\");\n    return null;\n  }\n  /**\n   * Remove from any storage the currently authenticated user.\n   *\n   * @returns A promise\n   */\n  async removeUser() {\n    const logger2 = this._logger.create(\"removeUser\");\n    await this.storeUser(null);\n    logger2.info(\"user removed from storage\");\n    await this._events.unload();\n  }\n  /**\n   * Trigger a redirect of the current window to the authorization endpoint.\n   *\n   * @returns A promise\n   *\n   * @throws `Error` In cases of wrong authentication.\n   */\n  async signinRedirect(args = {}) {\n    var _a;\n    this._logger.create(\"signinRedirect\");\n    const {\n      redirectMethod,\n      ...requestArgs\n    } = args;\n    let dpopJkt;\n    if ((_a = this.settings.dpop) == null ? void 0 : _a.bind_authorization_code) {\n      dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n    }\n    const handle = await this._redirectNavigator.prepare({\n      redirectMethod\n    });\n    await this._signinStart({\n      request_type: \"si:r\",\n      dpopJkt,\n      ...requestArgs\n    }, handle);\n  }\n  /**\n   * Process the response (callback) from the authorization endpoint.\n   * It is recommended to use {@link UserManager.signinCallback} instead.\n   *\n   * @returns A promise containing the authenticated `User`.\n   *\n   * @see {@link UserManager.signinCallback}\n   */\n  async signinRedirectCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signinRedirectCallback\");\n    const user = await this._signinEnd(url);\n    if (user.profile && user.profile.sub) {\n      logger2.info(\"success, signed in subject\", user.profile.sub);\n    } else {\n      logger2.info(\"no subject\");\n    }\n    return user;\n  }\n  /**\n   * Trigger the signin with user/password.\n   *\n   * @returns A promise containing the authenticated `User`.\n   * @throws {@link ErrorResponse} In cases of wrong authentication.\n   */\n  async signinResourceOwnerCredentials({\n    username,\n    password,\n    skipUserInfo = false\n  }) {\n    const logger2 = this._logger.create(\"signinResourceOwnerCredential\");\n    const signinResponse = await this._client.processResourceOwnerPasswordCredentials({\n      username,\n      password,\n      skipUserInfo,\n      extraTokenParams: this.settings.extraTokenParams\n    });\n    logger2.debug(\"got signin response\");\n    const user = await this._buildUser(signinResponse);\n    if (user.profile && user.profile.sub) {\n      logger2.info(\"success, signed in subject\", user.profile.sub);\n    } else {\n      logger2.info(\"no subject\");\n    }\n    return user;\n  }\n  /**\n   * Trigger a request (via a popup window) to the authorization endpoint.\n   *\n   * @returns A promise containing the authenticated `User`.\n   * @throws `Error` In cases of wrong authentication.\n   */\n  async signinPopup(args = {}) {\n    var _a;\n    const logger2 = this._logger.create(\"signinPopup\");\n    let dpopJkt;\n    if ((_a = this.settings.dpop) == null ? void 0 : _a.bind_authorization_code) {\n      dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n    }\n    const {\n      popupWindowFeatures,\n      popupWindowTarget,\n      popupSignal,\n      popupAbortOnClose,\n      ...requestArgs\n    } = args;\n    const url = this.settings.popup_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No popup_redirect_uri configured\"));\n    }\n    const handle = await this._popupNavigator.prepare({\n      popupWindowFeatures,\n      popupWindowTarget,\n      popupSignal,\n      popupAbortOnClose\n    });\n    const user = await this._signin({\n      request_type: \"si:p\",\n      redirect_uri: url,\n      display: \"popup\",\n      dpopJkt,\n      ...requestArgs\n    }, handle);\n    if (user) {\n      if (user.profile && user.profile.sub) {\n        logger2.info(\"success, signed in subject\", user.profile.sub);\n      } else {\n        logger2.info(\"no subject\");\n      }\n    }\n    return user;\n  }\n  /**\n   * Notify the opening window of response (callback) from the authorization endpoint.\n   * It is recommended to use {@link UserManager.signinCallback} instead.\n   *\n   * @returns A promise\n   *\n   * @see {@link UserManager.signinCallback}\n   */\n  async signinPopupCallback(url = window.location.href, keepOpen = false) {\n    const logger2 = this._logger.create(\"signinPopupCallback\");\n    await this._popupNavigator.callback(url, {\n      keepOpen\n    });\n    logger2.info(\"success\");\n  }\n  /**\n   * Trigger a silent request (via refresh token or an iframe) to the authorization endpoint.\n   *\n   * @returns A promise that contains the authenticated `User`.\n   */\n  async signinSilent(args = {}) {\n    var _a, _b;\n    const logger2 = this._logger.create(\"signinSilent\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    let user = await this._loadUser();\n    if (!args.forceIframeAuth && (user == null ? void 0 : user.refresh_token)) {\n      logger2.debug(\"using refresh token\");\n      const state = new RefreshState(user);\n      return await this._useRefreshToken({\n        state,\n        redirect_uri: requestArgs.redirect_uri,\n        resource: requestArgs.resource,\n        extraTokenParams: requestArgs.extraTokenParams,\n        timeoutInSeconds: silentRequestTimeoutInSeconds\n      });\n    }\n    let dpopJkt;\n    if ((_a = this.settings.dpop) == null ? void 0 : _a.bind_authorization_code) {\n      dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n    }\n    const url = this.settings.silent_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n    }\n    let verifySub;\n    if (user && this.settings.validateSubOnSilentRenew) {\n      logger2.debug(\"subject prior to silent renew:\", user.profile.sub);\n      verifySub = user.profile.sub;\n    }\n    const handle = await this._iframeNavigator.prepare({\n      silentRequestTimeoutInSeconds\n    });\n    user = await this._signin({\n      request_type: \"si:s\",\n      redirect_uri: url,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n      dpopJkt,\n      ...requestArgs\n    }, handle, verifySub);\n    if (user) {\n      if ((_b = user.profile) == null ? void 0 : _b.sub) {\n        logger2.info(\"success, signed in subject\", user.profile.sub);\n      } else {\n        logger2.info(\"no subject\");\n      }\n    }\n    return user;\n  }\n  async _useRefreshToken(args) {\n    const response = await this._client.useRefreshToken({\n      timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds,\n      ...args\n    });\n    const user = new User({\n      ...args.state,\n      ...response\n    });\n    await this.storeUser(user);\n    await this._events.load(user);\n    return user;\n  }\n  /**\n   *\n   * Notify the parent window of response (callback) from the authorization endpoint.\n   * It is recommended to use {@link UserManager.signinCallback} instead.\n   *\n   * @returns A promise\n   *\n   * @see {@link UserManager.signinCallback}\n   */\n  async signinSilentCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signinSilentCallback\");\n    await this._iframeNavigator.callback(url);\n    logger2.info(\"success\");\n  }\n  /**\n   * Process any response (callback) from the authorization endpoint, by dispatching the request_type\n   * and executing one of the following functions:\n   * - {@link UserManager.signinRedirectCallback}\n   * - {@link UserManager.signinPopupCallback}\n   * - {@link UserManager.signinSilentCallback}\n   *\n   * @throws `Error` If request_type is unknown or signin cannot be processed.\n   */\n  async signinCallback(url = window.location.href) {\n    const {\n      state\n    } = await this._client.readSigninResponseState(url);\n    switch (state.request_type) {\n      case \"si:r\":\n        return await this.signinRedirectCallback(url);\n      case \"si:p\":\n        await this.signinPopupCallback(url);\n        break;\n      case \"si:s\":\n        await this.signinSilentCallback(url);\n        break;\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n    return void 0;\n  }\n  /**\n   * Process any response (callback) from the end session endpoint, by dispatching the request_type\n   * and executing one of the following functions:\n   * - {@link UserManager.signoutRedirectCallback}\n   * - {@link UserManager.signoutPopupCallback}\n   * - {@link UserManager.signoutSilentCallback}\n   *\n   * @throws `Error` If request_type is unknown or signout cannot be processed.\n   */\n  async signoutCallback(url = window.location.href, keepOpen = false) {\n    const {\n      state\n    } = await this._client.readSignoutResponseState(url);\n    if (!state) {\n      return void 0;\n    }\n    switch (state.request_type) {\n      case \"so:r\":\n        return await this.signoutRedirectCallback(url);\n      case \"so:p\":\n        await this.signoutPopupCallback(url, keepOpen);\n        break;\n      case \"so:s\":\n        await this.signoutSilentCallback(url);\n        break;\n      default:\n        throw new Error(\"invalid response_type in state\");\n    }\n    return void 0;\n  }\n  /**\n   * Query OP for user's current signin status.\n   *\n   * @returns A promise object with session_state and subject identifier.\n   */\n  async querySessionStatus(args = {}) {\n    const logger2 = this._logger.create(\"querySessionStatus\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    const url = this.settings.silent_redirect_uri;\n    if (!url) {\n      logger2.throw(new Error(\"No silent_redirect_uri configured\"));\n    }\n    const user = await this._loadUser();\n    const handle = await this._iframeNavigator.prepare({\n      silentRequestTimeoutInSeconds\n    });\n    const navResponse = await this._signinStart({\n      request_type: \"si:s\",\n      // this acts like a signin silent\n      redirect_uri: url,\n      prompt: \"none\",\n      id_token_hint: this.settings.includeIdTokenInSilentRenew ? user == null ? void 0 : user.id_token : void 0,\n      response_type: this.settings.query_status_response_type,\n      scope: \"openid\",\n      skipUserInfo: true,\n      ...requestArgs\n    }, handle);\n    try {\n      const extraHeaders = {};\n      const signinResponse = await this._client.processSigninResponse(navResponse.url, extraHeaders);\n      logger2.debug(\"got signin response\");\n      if (signinResponse.session_state && signinResponse.profile.sub) {\n        logger2.info(\"success for subject\", signinResponse.profile.sub);\n        return {\n          session_state: signinResponse.session_state,\n          sub: signinResponse.profile.sub\n        };\n      }\n      logger2.info(\"success, user not authenticated\");\n      return null;\n    } catch (err) {\n      if (this.settings.monitorAnonymousSession && err instanceof ErrorResponse) {\n        switch (err.error) {\n          case \"login_required\":\n          case \"consent_required\":\n          case \"interaction_required\":\n          case \"account_selection_required\":\n            logger2.info(\"success for anonymous user\");\n            return {\n              session_state: err.session_state\n            };\n        }\n      }\n      throw err;\n    }\n  }\n  async _signin(args, handle, verifySub) {\n    const navResponse = await this._signinStart(args, handle);\n    return await this._signinEnd(navResponse.url, verifySub);\n  }\n  async _signinStart(args, handle) {\n    const logger2 = this._logger.create(\"_signinStart\");\n    try {\n      const signinRequest = await this._client.createSigninRequest(args);\n      logger2.debug(\"got signin request\");\n      return await handle.navigate({\n        url: signinRequest.url,\n        state: signinRequest.state.id,\n        response_mode: signinRequest.state.response_mode,\n        scriptOrigin: this.settings.iframeScriptOrigin\n      });\n    } catch (err) {\n      logger2.debug(\"error after preparing navigator, closing navigator window\");\n      handle.close();\n      throw err;\n    }\n  }\n  async _signinEnd(url, verifySub) {\n    const logger2 = this._logger.create(\"_signinEnd\");\n    const extraHeaders = {};\n    const signinResponse = await this._client.processSigninResponse(url, extraHeaders);\n    logger2.debug(\"got signin response\");\n    const user = await this._buildUser(signinResponse, verifySub);\n    return user;\n  }\n  async _buildUser(signinResponse, verifySub) {\n    const logger2 = this._logger.create(\"_buildUser\");\n    const user = new User(signinResponse);\n    if (verifySub) {\n      if (verifySub !== user.profile.sub) {\n        logger2.debug(\"current user does not match user returned from signin. sub from signin:\", user.profile.sub);\n        throw new ErrorResponse({\n          ...signinResponse,\n          error: \"login_required\"\n        });\n      }\n      logger2.debug(\"current user matches user returned from signin\");\n    }\n    await this.storeUser(user);\n    logger2.debug(\"user stored\");\n    await this._events.load(user);\n    return user;\n  }\n  /**\n   * Trigger a redirect of the current window to the end session endpoint.\n   *\n   * @returns A promise\n   */\n  async signoutRedirect(args = {}) {\n    const logger2 = this._logger.create(\"signoutRedirect\");\n    const {\n      redirectMethod,\n      ...requestArgs\n    } = args;\n    const handle = await this._redirectNavigator.prepare({\n      redirectMethod\n    });\n    await this._signoutStart({\n      request_type: \"so:r\",\n      post_logout_redirect_uri: this.settings.post_logout_redirect_uri,\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Process response (callback) from the end session endpoint.\n   * It is recommended to use {@link UserManager.signoutCallback} instead.\n   *\n   * @returns A promise containing signout response\n   *\n   * @see {@link UserManager.signoutCallback}\n   */\n  async signoutRedirectCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signoutRedirectCallback\");\n    const response = await this._signoutEnd(url);\n    logger2.info(\"success\");\n    return response;\n  }\n  /**\n   * Trigger a redirect of a popup window to the end session endpoint.\n   *\n   * @returns A promise\n   */\n  async signoutPopup(args = {}) {\n    const logger2 = this._logger.create(\"signoutPopup\");\n    const {\n      popupWindowFeatures,\n      popupWindowTarget,\n      popupSignal,\n      ...requestArgs\n    } = args;\n    const url = this.settings.popup_post_logout_redirect_uri;\n    const handle = await this._popupNavigator.prepare({\n      popupWindowFeatures,\n      popupWindowTarget,\n      popupSignal\n    });\n    await this._signout({\n      request_type: \"so:p\",\n      post_logout_redirect_uri: url,\n      // we're putting a dummy entry in here because we\n      // need a unique id from the state for notification\n      // to the parent window, which is necessary if we\n      // plan to return back to the client after signout\n      // and so we can close the popup after signout\n      state: url == null ? void 0 : {},\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Process response (callback) from the end session endpoint from a popup window.\n   * It is recommended to use {@link UserManager.signoutCallback} instead.\n   *\n   * @returns A promise\n   *\n   * @see {@link UserManager.signoutCallback}\n   */\n  async signoutPopupCallback(url = window.location.href, keepOpen = false) {\n    const logger2 = this._logger.create(\"signoutPopupCallback\");\n    await this._popupNavigator.callback(url, {\n      keepOpen\n    });\n    logger2.info(\"success\");\n  }\n  async _signout(args, handle) {\n    const navResponse = await this._signoutStart(args, handle);\n    return await this._signoutEnd(navResponse.url);\n  }\n  async _signoutStart(args = {}, handle) {\n    var _a;\n    const logger2 = this._logger.create(\"_signoutStart\");\n    try {\n      const user = await this._loadUser();\n      logger2.debug(\"loaded current user from storage\");\n      if (this.settings.revokeTokensOnSignout) {\n        await this._revokeInternal(user);\n      }\n      const id_token = args.id_token_hint || user && user.id_token;\n      if (id_token) {\n        logger2.debug(\"setting id_token_hint in signout request\");\n        args.id_token_hint = id_token;\n      }\n      await this.removeUser();\n      logger2.debug(\"user removed, creating signout request\");\n      const signoutRequest = await this._client.createSignoutRequest(args);\n      logger2.debug(\"got signout request\");\n      return await handle.navigate({\n        url: signoutRequest.url,\n        state: (_a = signoutRequest.state) == null ? void 0 : _a.id,\n        scriptOrigin: this.settings.iframeScriptOrigin\n      });\n    } catch (err) {\n      logger2.debug(\"error after preparing navigator, closing navigator window\");\n      handle.close();\n      throw err;\n    }\n  }\n  async _signoutEnd(url) {\n    const logger2 = this._logger.create(\"_signoutEnd\");\n    const signoutResponse = await this._client.processSignoutResponse(url);\n    logger2.debug(\"got signout response\");\n    return signoutResponse;\n  }\n  /**\n   * Trigger a silent request (via an iframe) to the end session endpoint.\n   *\n   * @returns A promise\n   */\n  async signoutSilent(args = {}) {\n    var _a;\n    const logger2 = this._logger.create(\"signoutSilent\");\n    const {\n      silentRequestTimeoutInSeconds,\n      ...requestArgs\n    } = args;\n    const id_token_hint = this.settings.includeIdTokenInSilentSignout ? (_a = await this._loadUser()) == null ? void 0 : _a.id_token : void 0;\n    const url = this.settings.popup_post_logout_redirect_uri;\n    const handle = await this._iframeNavigator.prepare({\n      silentRequestTimeoutInSeconds\n    });\n    await this._signout({\n      request_type: \"so:s\",\n      post_logout_redirect_uri: url,\n      id_token_hint,\n      ...requestArgs\n    }, handle);\n    logger2.info(\"success\");\n  }\n  /**\n   * Notify the parent window of response (callback) from the end session endpoint.\n   * It is recommended to use {@link UserManager.signoutCallback} instead.\n   *\n   * @returns A promise\n   *\n   * @see {@link UserManager.signoutCallback}\n   */\n  async signoutSilentCallback(url = window.location.href) {\n    const logger2 = this._logger.create(\"signoutSilentCallback\");\n    await this._iframeNavigator.callback(url);\n    logger2.info(\"success\");\n  }\n  async revokeTokens(types) {\n    const user = await this._loadUser();\n    await this._revokeInternal(user, types);\n  }\n  async _revokeInternal(user, types = this.settings.revokeTokenTypes) {\n    const logger2 = this._logger.create(\"_revokeInternal\");\n    if (!user) return;\n    const typesPresent = types.filter(type => typeof user[type] === \"string\");\n    if (!typesPresent.length) {\n      logger2.debug(\"no need to revoke due to no token(s)\");\n      return;\n    }\n    for (const type of typesPresent) {\n      await this._client.revokeToken(user[type], type);\n      logger2.info(`${type} revoked successfully`);\n      if (type !== \"access_token\") {\n        user[type] = null;\n      }\n    }\n    await this.storeUser(user);\n    logger2.debug(\"user stored\");\n    await this._events.load(user);\n  }\n  /**\n   * Enables silent renew for the `UserManager`.\n   */\n  startSilentRenew() {\n    this._logger.create(\"startSilentRenew\");\n    void this._silentRenewService.start();\n  }\n  /**\n   * Disables silent renew for the `UserManager`.\n   */\n  stopSilentRenew() {\n    this._silentRenewService.stop();\n  }\n  get _userStoreKey() {\n    return `user:${this.settings.authority}:${this.settings.client_id}`;\n  }\n  async _loadUser() {\n    const logger2 = this._logger.create(\"_loadUser\");\n    const storageString = await this.settings.userStore.get(this._userStoreKey);\n    if (storageString) {\n      logger2.debug(\"user storageString loaded\");\n      return User.fromStorageString(storageString);\n    }\n    logger2.debug(\"no user storageString\");\n    return null;\n  }\n  async storeUser(user) {\n    const logger2 = this._logger.create(\"storeUser\");\n    if (user) {\n      logger2.debug(\"storing user\");\n      const storageString = user.toStorageString();\n      await this.settings.userStore.set(this._userStoreKey, storageString);\n    } else {\n      this._logger.debug(\"removing user\");\n      await this.settings.userStore.remove(this._userStoreKey);\n      if (this.settings.dpop) {\n        await this.settings.dpop.store.remove(this.settings.client_id);\n      }\n    }\n  }\n  /**\n   * Removes stale state entries in storage for incomplete authorize requests.\n   */\n  async clearStaleState() {\n    await this._client.clearStaleState();\n  }\n  /**\n   * Dynamically generates a DPoP proof for a given user, URL and optional Http method.\n   * This method is useful when you need to make a request to a resource server\n   * with fetch or similar, and you need to include a DPoP proof in a DPoP header.\n   * @param url - The URL to generate the DPoP proof for\n   * @param user - The user to generate the DPoP proof for\n   * @param httpMethod - Optional, defaults to \"GET\"\n   * @param nonce - Optional nonce provided by the resource server\n   *\n   * @returns A promise containing the DPoP proof or undefined if DPoP is not enabled/no user is found.\n   */\n  async dpopProof(url, user, httpMethod, nonce) {\n    var _a, _b;\n    const dpopState = await ((_b = (_a = this.settings.dpop) == null ? void 0 : _a.store) == null ? void 0 : _b.get(this.settings.client_id));\n    if (dpopState) {\n      return await CryptoUtils.generateDPoPProof({\n        url,\n        accessToken: user == null ? void 0 : user.access_token,\n        httpMethod,\n        keyPair: dpopState.keys,\n        nonce\n      });\n    }\n    return void 0;\n  }\n  async generateDPoPJkt(dpopSettings) {\n    let dpopState = await dpopSettings.store.get(this.settings.client_id);\n    if (!dpopState) {\n      const dpopKeys = await CryptoUtils.generateDPoPKeys();\n      dpopState = new DPoPState(dpopKeys);\n      await dpopSettings.store.set(this.settings.client_id, dpopState);\n    }\n    return await CryptoUtils.generateDPoPJkt(dpopState.keys);\n  }\n};\n\n// package.json\nvar version = \"3.4.1\";\n\n// src/Version.ts\nvar Version = version;\n\n// src/IndexedDbDPoPStore.ts\nvar IndexedDbDPoPStore = class {\n  constructor() {\n    this._dbName = \"oidc\";\n    this._storeName = \"dpop\";\n  }\n  async set(key, value) {\n    const store = await this.createStore(this._dbName, this._storeName);\n    await store(\"readwrite\", str => {\n      str.put(value, key);\n      return this.promisifyRequest(str.transaction);\n    });\n  }\n  async get(key) {\n    const store = await this.createStore(this._dbName, this._storeName);\n    return await store(\"readonly\", str => {\n      return this.promisifyRequest(str.get(key));\n    });\n  }\n  async remove(key) {\n    const item = await this.get(key);\n    const store = await this.createStore(this._dbName, this._storeName);\n    await store(\"readwrite\", str => {\n      return this.promisifyRequest(str.delete(key));\n    });\n    return item;\n  }\n  async getAllKeys() {\n    const store = await this.createStore(this._dbName, this._storeName);\n    return await store(\"readonly\", str => {\n      return this.promisifyRequest(str.getAllKeys());\n    });\n  }\n  promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n      request.oncomplete = request.onsuccess = () => resolve(request.result);\n      request.onabort = request.onerror = () => reject(request.error);\n    });\n  }\n  async createStore(dbName, storeName) {\n    const request = indexedDB.open(dbName);\n    request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n    const db = await this.promisifyRequest(request);\n    return async (txMode, callback) => {\n      const tx = db.transaction(storeName, txMode);\n      const store = tx.objectStore(storeName);\n      return await callback(store);\n    };\n  }\n};\nexport { AccessTokenEvents, CheckSessionIFrame, DPoPState, ErrorResponse, ErrorTimeout, InMemoryWebStorage, IndexedDbDPoPStore, Log, Logger, MetadataService, OidcClient, OidcClientSettingsStore, SessionMonitor, SigninResponse, SigninState, SignoutResponse, State, User, UserManager, UserManagerSettingsStore, Version, WebStorageStateStore };","map":{"version":3,"names":["nopLogger","debug","info","warn","error","level","logger","Log","Log2","reset","setLevel","value","Error","setLogger","Logger","_Logger","constructor","_name","args","_format","_method","throw","err","create","method","methodLogger","Object","createStatic","name","staticMethod","staticLogger","prefix","jwtDecode","JwtUtils","decode","token","generateSignedJwt","header","payload","privateKey","encodedHeader","CryptoUtils","encodeBase64Url","TextEncoder","encode","JSON","stringify","encodedPayload","encodedToken","signature","window","crypto","subtle","sign","hash","encodedSignature","Uint8Array","generateSignedJwtWithHmac","secretKey","UUID_V4_TEMPLATE","toBase64","val","btoa","map","chr","String","fromCharCode","join","_CryptoUtils","_randomWord","arr","Uint32Array","getRandomValues","generateUUIDv4","uuid","replace","c","toString","generateCodeVerifier","generateCodeChallenge","code_verifier","encoder","data","hashed","digest","generateBasicAuth","client_id","client_secret","alg","message","msgUint8","hashBuffer","customCalculateJwkThumbprint","jwk","jsonObject","kty","e","n","crv","x","y","k","utf8encodedAndHashed","generateDPoPProof","url","accessToken","httpMethod","keyPair","nonce","hashedToken","encodedHash","randomUUID","Math","floor","Date","now","ath","publicJwk","exportKey","publicKey","TypeError","generateDPoPJkt","generateDPoPKeys","generateKey","namedCurve","generateClientAssertionJwt","audience","algorithm","hashMap","hashFunction","importKey","input","Event","_callbacks","_logger","addHandler","cb","push","removeHandler","idx","lastIndexOf","splice","raise","ev","PopupUtils","center","features","_a","_b","_c","width","find","outerWidth","left","max","round","screenX","height","top","screenY","outerHeight","serialize","entries","filter","key","Timer","_Timer","arguments","_timerHandle","_expiration","_callback","diff","getEpochTime","cancel","init","durationInSeconds","logger2","expiration","timerDurationInSeconds","min","setInterval","clearInterval","UrlUtils","readParams","responseMode","parsedUrl","URL","params","URLSearchParams","slice","URL_STATE_DELIMITER","ErrorResponse","form","error_description","error_uri","state","userState","session_state","url_state","ErrorTimeout","AccessTokenEvents","_expiringTimer","_expiredTimer","_expiringNotificationTimeInSeconds","expiringNotificationTimeInSeconds","load","container","access_token","expires_in","duration","expiring","expired","unload","addAccessTokenExpiring","removeAccessTokenExpiring","addAccessTokenExpired","removeAccessTokenExpired","CheckSessionIFrame","_client_id","_intervalInSeconds","_stopOnError","_timer","_session_state","_message","origin","_frame_origin","source","_frame","contentWindow","stop","document","createElement","style","visibility","position","src","href","Promise","resolve","onload","body","appendChild","addEventListener","start","send","postMessage","InMemoryWebStorage","_data","clear","getItem","setItem","removeItem","length","getOwnPropertyNames","index","ErrorDPoPNonce","JsonService","additionalContentTypes","_jwtHandler","_extraHeaders","_contentTypes","fetchWithTimeout","timeoutInSeconds","initFetch","fetch","controller","AbortController","timeoutId","setTimeout","abort","response","signal","DOMException","clearTimeout","getJson","credentials","headers","_appendExtraHeaders","status","contentType","get","item","startsWith","ok","text","json","statusText","postForm","basicAuth","initCredentials","extraHeaders","responseText","parse","has","customKeys","keys","protectedHeaders","preventOverride","forEach","headerName","includes","toLocaleLowerCase","content","MetadataService","_settings","_signingKeys","_metadata","_metadataUrl","metadataUrl","_jsonService","signingKeys","metadata","fetchRequestCredentials","_fetchRequestCredentials","resetSigningKeys","getMetadata","requestTimeoutInSeconds","assign","metadataSeed","getIssuer","_getMetadataProperty","getAuthorizationEndpoint","getUserInfoEndpoint","getTokenEndpoint","optional","getCheckSessionIframe","getEndSessionEndpoint","getRevocationEndpoint","getKeysEndpoint","getSigningKeys","jwks_uri","keySet","Array","isArray","WebStorageStateStore","store","localStorage","_store","_prefix","set","remove","getAllKeys","len","indexOf","substr","DefaultResponseType","DefaultScope","DefaultClientAuthentication","DefaultStaleStateAgeInSeconds","OidcClientSettingsStore","authority","response_type","scope","redirect_uri","post_logout_redirect_uri","client_authentication","token_endpoint_auth_signing_alg","prompt","display","max_age","ui_locales","acr_values","resource","response_mode","filterProtocolClaims","loadUserInfo","staleStateAgeInSeconds","mergeClaimsStrategy","array","disablePKCE","stateStore","revokeTokenAdditionalContentTypes","refreshTokenAllowedScope","extraQueryParams","extraTokenParams","dpop","omitScopeWhenRequesting","endsWith","UserInfoService","_metadataService","_getClaimsFromJwt","getClaims","claims","TokenClient","exchangeCode","grant_type","code","append","clientAssertion","exchangeCredentials","exchangeRefreshToken","refresh_token","param","revoke","token_type_hint","ResponseValidator","_claimsService","_userInfoService","_tokenClient","validateSigninResponse","_processSigninState","_processCode","isOpenId","_validateIdTokenAttributes","_processClaims","skipUserInfo","validateCredentialsResponse","shouldValidateSubClaim","id_token","validateRefreshResponse","profile","hasIdToken","validateSignoutResponse","id","validateSub","sub","mergeClaims","tokenResponse","existingToken","incoming","existing","auth_time","azp","State","_State","created","request_type","toStorageString","fromStorageString","storageString","clearStaleState","storage","age","cutoff","i","SigninState","_SigninState","code_challenge","_SigninRequest","state_data","dpopJkt","optionalParams","searchParams","stateParam","resources","r","SigninRequest","OidcScope","SigninResponse","token_type","splitState","decodeURIComponent","split","expires_at","Number","SignoutRequest","id_token_hint","SignoutResponse","DefaultProtocolClaims","InternalRequiredProtocolClaims","ClaimsService","result","protocolClaims","claim","claims1","claims2","values","mergedValues","DPoPState","OidcClient","settings","metadataService","_validator","createSigninRequest","request","request_uri","login_hint","signinRequest","signinState","readSigninResponseState","removeState","storedStateString","processSigninResponse","dpopProof","getDpopProof","dpopStore","dpopState","processResourceOwnerPasswordCredentials","username","password","signinResponse","useRefreshToken","allowableScopes","providedScopes","s","createSignoutRequest","signoutState","readSignoutResponseState","processSignoutResponse","revokeToken","type","SessionMonitor","_userManager","_start","user","_sub","_checkSessionIFrame","intervalInSeconds","checkSessionIntervalInSeconds","stopOnError","stopCheckSessionOnError","checkSessionIFrame","_stop","monitorAnonymousSession","timerHandle","session","querySessionStatus","tmpUser","raiseEvent","events","_raiseUserSessionChanged","_raiseUserSignedOut","_raiseUserSignedIn","addUserLoaded","addUserUnloaded","_init","catch","getUser","User","_User","scopes","messageSource","AbstractChildWindow","_abort","_disposeHandlers","Set","_window","navigate","location","keepOpen","reject","listener","scriptOrigin","_dispose","add","removeEventListener","channel","BroadcastChannel","close","reason","dispose","_notifyParent","parent","targetOrigin","msgData","DefaultPopupWindowFeatures","toolbar","closePopupWindowAfterInSeconds","DefaultPopupTarget","DefaultAccessTokenExpiringNotificationTimeInSeconds","DefaultCheckSessionIntervalInSeconds","DefaultSilentRequestTimeoutInSeconds","UserManagerSettingsStore","popup_redirect_uri","popup_post_logout_redirect_uri","popupWindowFeatures","popupWindowTarget","redirectMethod","redirectTarget","iframeNotifyParentOrigin","iframeScriptOrigin","silent_redirect_uri","silentRequestTimeoutInSeconds","automaticSilentRenew","validateSubOnSilentRenew","includeIdTokenInSilentRenew","monitorSession","query_status_response_type","revokeTokenTypes","revokeTokensOnSignout","includeIdTokenInSilentSignout","accessTokenExpiringNotificationTimeInSeconds","userStore","sessionStorage","IFrameWindow","_IFrameWindow","_timeoutInSeconds","createHiddenIframe","iframe","timer","parentNode","_a2","frame","target","removeChild","notifyParent","IFrameNavigator","prepare","callback","checkForPopupClosedInterval","second","PopupWindow","popupSignal","popupAbortOnClose","centeredPopup","open","abortOnClose","Boolean","closed","focus","popupClosedInterval","clearPopupClosedInterval","delete","notifyOpener","opener","PopupNavigator","RedirectNavigator","targetWindow","self","redirect","bind","promise","UserManagerEvents","_userLoaded","_userUnloaded","_silentRenewError","_userSignedIn","_userSignedOut","_userSessionChanged","removeUserLoaded","removeUserUnloaded","addSilentRenewError","removeSilentRenewError","_raiseSilentRenewError","addUserSignedIn","removeUserSignedIn","addUserSignedOut","removeUserSignedOut","addUserSessionChanged","removeUserSessionChanged","SilentRenewService","_isStarted","_retryTimer","_tokenExpiring","signinSilent","RefreshState","UserManager","redirectNavigator","popupNavigator","iframeNavigator","_client","_redirectNavigator","_popupNavigator","_iframeNavigator","_events","_silentRenewService","startSilentRenew","_sessionMonitor","_loadUser","removeUser","storeUser","signinRedirect","requestArgs","bind_authorization_code","handle","_signinStart","signinRedirectCallback","_signinEnd","signinResourceOwnerCredentials","_buildUser","signinPopup","_signin","signinPopupCallback","forceIframeAuth","_useRefreshToken","verifySub","signinSilentCallback","signinCallback","signoutCallback","signoutRedirectCallback","signoutPopupCallback","signoutSilentCallback","navResponse","signoutRedirect","_signoutStart","_signoutEnd","signoutPopup","_signout","_revokeInternal","signoutRequest","signoutResponse","signoutSilent","revokeTokens","types","typesPresent","stopSilentRenew","_userStoreKey","dpopSettings","dpopKeys","version","Version","IndexedDbDPoPStore","_dbName","_storeName","createStore","str","put","promisifyRequest","transaction","oncomplete","onsuccess","onabort","onerror","dbName","storeName","indexedDB","onupgradeneeded","createObjectStore","db","txMode","tx","objectStore"],"sources":["/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/utils/Logger.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/utils/JwtUtils.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/utils/CryptoUtils.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/utils/Event.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/utils/PopupUtils.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/utils/Timer.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/utils/UrlUtils.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/errors/ErrorResponse.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/errors/ErrorTimeout.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/AccessTokenEvents.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/CheckSessionIFrame.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/InMemoryWebStorage.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/errors/ErrorDPoPNonce.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/JsonService.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/MetadataService.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/WebStorageStateStore.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/OidcClientSettings.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/UserInfoService.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/TokenClient.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/ResponseValidator.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/State.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/SigninState.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/SigninRequest.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/SigninResponse.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/SignoutRequest.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/SignoutResponse.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/ClaimsService.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/DPoPStore.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/OidcClient.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/SessionMonitor.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/User.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/navigators/AbstractChildWindow.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/UserManagerSettings.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/navigators/IFrameWindow.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/navigators/IFrameNavigator.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/navigators/PopupWindow.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/navigators/PopupNavigator.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/navigators/RedirectNavigator.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/UserManagerEvents.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/SilentRenewService.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/RefreshState.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/UserManager.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/package.json","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/Version.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/oidc-client-ts/src/IndexedDbDPoPStore.ts"],"sourcesContent":["// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * Native interface\n *\n * @public\n */\nexport interface ILogger {\n    debug(...args: unknown[]): void;\n    info(...args: unknown[]): void;\n    warn(...args: unknown[]): void;\n    error(...args: unknown[]): void;\n}\n\nconst nopLogger: ILogger = {\n    debug: () => undefined,\n    info: () => undefined,\n    warn: () => undefined,\n    error: () => undefined,\n};\n\nlet level: number;\nlet logger: ILogger;\n\n/**\n * Log levels\n *\n * @public\n */\nexport enum Log {\n    NONE,\n    ERROR,\n    WARN,\n    INFO,\n    DEBUG\n}\n\n/**\n * Log manager\n *\n * @public\n */\nexport namespace Log { // eslint-disable-line @typescript-eslint/no-namespace\n    export function reset(): void {\n        level = Log.INFO;\n        logger = nopLogger;\n    }\n\n    export function setLevel(value: Log): void {\n        if (!(Log.NONE <= value && value <= Log.DEBUG)) {\n            throw new Error(\"Invalid log level\");\n        }\n        level = value;\n    }\n\n    export function setLogger(value: ILogger): void {\n        logger = value;\n    }\n}\n\n/**\n * Internal logger instance\n *\n * @public\n */\nexport class Logger {\n    private _method?: string;\n    public constructor(private _name: string) {}\n\n    /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n    public debug(...args: unknown[]): void {\n        if (level >= Log.DEBUG) {\n            logger.debug(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public info(...args: unknown[]): void {\n        if (level >= Log.INFO) {\n            logger.info(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public warn(...args: unknown[]): void {\n        if (level >= Log.WARN) {\n            logger.warn(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    public error(...args: unknown[]): void {\n        if (level >= Log.ERROR) {\n            logger.error(Logger._format(this._name, this._method), ...args);\n        }\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n\n    public throw(err: Error): never {\n        this.error(err);\n        throw err;\n    }\n\n    public create(method: string): Logger {\n        const methodLogger: Logger = Object.create(this);\n        methodLogger._method = method;\n        methodLogger.debug(\"begin\");\n        return methodLogger;\n    }\n\n    public static createStatic(name: string, staticMethod: string): Logger {\n        const staticLogger = new Logger(`${name}.${staticMethod}`);\n        staticLogger.debug(\"begin\");\n        return staticLogger;\n    }\n\n    private static _format(name: string, method?: string) {\n        const prefix = `[${name}]`;\n        return method ? `${prefix} ${method}:` : prefix;\n    }\n\n    /* eslint-disable @typescript-eslint/no-unsafe-enum-comparison */\n    // helpers for static class methods\n    public static debug(name: string, ...args: unknown[]): void {\n        if (level >= Log.DEBUG) {\n            logger.debug(Logger._format(name), ...args);\n        }\n    }\n    public static info(name: string, ...args: unknown[]): void {\n        if (level >= Log.INFO) {\n            logger.info(Logger._format(name), ...args);\n        }\n    }\n    public static warn(name: string, ...args: unknown[]): void {\n        if (level >= Log.WARN) {\n            logger.warn(Logger._format(name), ...args);\n        }\n    }\n    public static error(name: string, ...args: unknown[]): void {\n        if (level >= Log.ERROR) {\n            logger.error(Logger._format(name), ...args);\n        }\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-enum-comparison */\n}\n\nLog.reset();\n","import { jwtDecode } from \"jwt-decode\";\n\nimport { Logger } from \"./Logger\";\nimport type { JwtClaims } from \"../Claims\";\nimport { CryptoUtils } from \"./CryptoUtils\";\n\n/**\n * @internal\n */\nexport class JwtUtils {\n    // IMPORTANT: doesn't validate the token\n    public static decode(token: string): JwtClaims {\n        try {\n            return jwtDecode<JwtClaims>(token);\n        }\n        catch (err) {\n            Logger.error(\"JwtUtils.decode\", err);\n            throw err;\n        }\n    }\n\n    public static async generateSignedJwt(header: object, payload: object, privateKey: CryptoKey) : Promise<string> {\n        const encodedHeader = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(header)));\n        const encodedPayload = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(payload)));\n        const encodedToken = `${encodedHeader}.${encodedPayload}`;\n\n        const signature = await window.crypto.subtle.sign(\n            {\n                name: \"ECDSA\",\n                hash: { name: \"SHA-256\" },\n            },\n            privateKey,\n            new TextEncoder().encode(encodedToken),\n        );\n\n        const encodedSignature = CryptoUtils.encodeBase64Url(new Uint8Array(signature));\n        return `${encodedToken}.${encodedSignature}`;\n    }\n\n    public static async generateSignedJwtWithHmac(header: object, payload: object, secretKey: CryptoKey): Promise<string> {\n        const encodedHeader = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(header)));\n        const encodedPayload = CryptoUtils.encodeBase64Url(new TextEncoder().encode(JSON.stringify(payload)));\n        const encodedToken = `${encodedHeader}.${encodedPayload}`;\n\n        const signature = await window.crypto.subtle.sign(\n            \"HMAC\",\n            secretKey,\n            new TextEncoder().encode(encodedToken),\n        );\n\n        const encodedSignature = CryptoUtils.encodeBase64Url(new Uint8Array(signature));\n        return `${encodedToken}.${encodedSignature}`;\n    }\n}\n","import { Logger } from \"./Logger\";\nimport { JwtUtils } from \"./JwtUtils\";\n\nexport interface GenerateDPoPProofOpts {\n    url: string;\n    accessToken?: string;\n    httpMethod?: string;\n    keyPair: CryptoKeyPair;\n    nonce?: string;\n}\n\nconst UUID_V4_TEMPLATE = \"10000000-1000-4000-8000-100000000000\";\n\nconst toBase64 = (val: ArrayBuffer | Uint8Array): string =>\n    btoa([...new Uint8Array(val)]\n        .map((chr) => String.fromCharCode(chr))\n        .join(\"\"));\n\n/**\n * @internal\n */\nexport class CryptoUtils {\n    private static _randomWord(): number {\n        const arr = new Uint32Array(1);\n        crypto.getRandomValues(arr);\n        return arr[0];\n    }\n\n    /**\n     * Generates RFC4122 version 4 guid\n     */\n    public static generateUUIDv4(): string {\n        const uuid = UUID_V4_TEMPLATE.replace(/[018]/g, c =>\n            (+c ^ CryptoUtils._randomWord() & 15 >> +c / 4).toString(16),\n        );\n        return uuid.replace(/-/g, \"\");\n    }\n\n    /**\n     * PKCE: Generate a code verifier\n     */\n    public static generateCodeVerifier(): string {\n        return CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4() + CryptoUtils.generateUUIDv4();\n    }\n\n    /**\n     * PKCE: Generate a code challenge\n     */\n    public static async generateCodeChallenge(code_verifier: string): Promise<string> {\n        if (!crypto.subtle) {\n            throw new Error(\"Crypto.subtle is available only in secure contexts (HTTPS).\");\n        }\n\n        try {\n            const encoder = new TextEncoder();\n            const data = encoder.encode(code_verifier);\n            const hashed = await crypto.subtle.digest(\"SHA-256\", data);\n            return toBase64(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n        }\n        catch (err) {\n            Logger.error(\"CryptoUtils.generateCodeChallenge\", err);\n            throw err;\n        }\n    }\n\n    /**\n     * Generates a base64-encoded string for a basic auth header\n     */\n    public static generateBasicAuth(client_id: string, client_secret: string): string {\n        const encoder = new TextEncoder();\n        const data = encoder.encode([client_id, client_secret].join(\":\"));\n        return toBase64(data);\n    }\n\n    /**\n     * Generates a hash of a string using a given algorithm\n     * @param alg\n     * @param message\n     */\n    public static async hash(alg: string, message: string) : Promise<Uint8Array> {\n        const msgUint8 = new TextEncoder().encode(message);\n        const hashBuffer = await crypto.subtle.digest(alg, msgUint8);\n        return new Uint8Array(hashBuffer);\n    }\n\n    /**\n     * Generates a base64url encoded string\n     */\n    public static encodeBase64Url = (input: Uint8Array) => {\n        return toBase64(input).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    };\n\n    /**\n     * Generates a rfc7638 compliant jwk thumbprint\n     * @param jwk\n     */\n    public static async customCalculateJwkThumbprint(jwk: JsonWebKey): Promise<string> {\n        let jsonObject: object;\n        switch (jwk.kty) {\n            case \"RSA\":\n                jsonObject = {\n                    \"e\": jwk.e,\n                    \"kty\": jwk.kty,\n                    \"n\": jwk.n,\n                };\n                break;\n            case \"EC\":\n                jsonObject = {\n                    \"crv\": jwk.crv,\n                    \"kty\": jwk.kty,\n                    \"x\": jwk.x,\n                    \"y\": jwk.y,\n                };\n                break;\n            case \"OKP\":\n                jsonObject = {\n                    \"crv\": jwk.crv,\n                    \"kty\": jwk.kty,\n                    \"x\": jwk.x,\n                };\n                break;\n            case \"oct\":\n                jsonObject = {\n                    \"crv\": jwk.k,\n                    \"kty\": jwk.kty,\n                };\n                break;\n            default:\n                throw new Error(\"Unknown jwk type\");\n        }\n        const utf8encodedAndHashed = await CryptoUtils.hash(\"SHA-256\", JSON.stringify(jsonObject));\n        return CryptoUtils.encodeBase64Url(utf8encodedAndHashed);\n    }\n\n    public static async generateDPoPProof({\n        url,\n        accessToken,\n        httpMethod,\n        keyPair,\n        nonce,\n    }: GenerateDPoPProofOpts): Promise<string> {\n        let hashedToken: Uint8Array;\n        let encodedHash: string;\n\n        const payload: Record<string, string | number> = {\n            \"jti\": window.crypto.randomUUID(),\n            \"htm\": httpMethod ?? \"GET\",\n            \"htu\": url,\n            \"iat\": Math.floor(Date.now() / 1000),\n        };\n\n        if (accessToken) {\n            hashedToken = await CryptoUtils.hash(\"SHA-256\", accessToken);\n            encodedHash = CryptoUtils.encodeBase64Url(hashedToken);\n            payload.ath = encodedHash;\n        }\n\n        if (nonce) {\n            payload.nonce = nonce;\n        }\n\n        try {\n            const publicJwk = await crypto.subtle.exportKey(\"jwk\", keyPair.publicKey);\n            const header = {\n                \"alg\": \"ES256\",\n                \"typ\": \"dpop+jwt\",\n                \"jwk\": {\n                    \"crv\": publicJwk.crv,\n                    \"kty\": publicJwk.kty,\n                    \"x\": publicJwk.x,\n                    \"y\": publicJwk.y,\n                },\n            };\n            return await JwtUtils.generateSignedJwt(header, payload, keyPair.privateKey);\n        } catch (err) {\n            if (err instanceof TypeError) {\n                throw new Error(`Error exporting dpop public key: ${err.message}`);\n            } else {\n                throw err;\n            }\n        }\n    }\n\n    public static async generateDPoPJkt(keyPair: CryptoKeyPair) : Promise<string> {\n        try {\n            const publicJwk = await crypto.subtle.exportKey(\"jwk\", keyPair.publicKey);\n            return await CryptoUtils.customCalculateJwkThumbprint(publicJwk);\n        } catch (err) {\n            if (err instanceof TypeError) {\n                throw new Error(`Could not retrieve dpop keys from storage: ${err.message}`);\n            } else {\n                throw err;\n            }\n        }\n    }\n\n    public static async generateDPoPKeys() : Promise<CryptoKeyPair> {\n        return await window.crypto.subtle.generateKey(\n            {\n                name: \"ECDSA\",\n                namedCurve: \"P-256\",\n            },\n            false,\n            [\"sign\", \"verify\"],\n        );\n    }\n\n    /**\n     * Generates a client assertion JWT for client_secret_jwt authentication\n     * @param client_id The client identifier\n     * @param client_secret The client secret\n     * @param audience The token endpoint URL (audience)\n     * @param algorithm The HMAC algorithm to use (HS256, HS384, HS512). Defaults to HS256\n     */\n    public static async generateClientAssertionJwt(client_id: string, client_secret: string, audience: string, algorithm: string = \"HS256\"): Promise<string> {\n        const now = Math.floor(Date.now() / 1000);\n\n        const header = {\n            \"alg\": algorithm,\n            \"typ\": \"JWT\",\n        };\n\n        const payload = {\n            \"iss\": client_id,\n            \"sub\": client_id,\n            \"aud\": audience,\n            \"jti\": CryptoUtils.generateUUIDv4(),\n            \"exp\": now + 300, // 5 minutes\n            \"iat\": now,\n        };\n\n        const hashMap: Record<string, string> = {\n            \"HS256\": \"SHA-256\",\n            \"HS384\": \"SHA-384\",\n            \"HS512\": \"SHA-512\",\n        };\n\n        const hashFunction = hashMap[algorithm];\n        if (!hashFunction) {\n            throw new Error(`Unsupported algorithm: ${algorithm}. Supported algorithms are: HS256, HS384, HS512`);\n        }\n\n        const encoder = new TextEncoder();\n        const secretKey = await crypto.subtle.importKey(\n            \"raw\",\n            encoder.encode(client_secret),\n            { name: \"HMAC\", hash: hashFunction },\n            false,\n            [\"sign\"],\n        );\n\n        return await JwtUtils.generateSignedJwtWithHmac(header, payload, secretKey);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./Logger\";\n\n/**\n * @internal\n */\nexport type Callback<EventType extends unknown[]> = (...ev: EventType) => (Promise<void> | void);\n\n/**\n * @internal\n */\nexport class Event<EventType extends unknown[]> {\n    protected readonly _logger: Logger;\n\n    private readonly _callbacks: Array<Callback<EventType>> = [];\n\n    public constructor(protected readonly _name: string) {\n        this._logger = new Logger(`Event('${this._name}')`);\n    }\n\n    public addHandler(cb: Callback<EventType>): () => void {\n        this._callbacks.push(cb);\n        return () => this.removeHandler(cb);\n    }\n\n    public removeHandler(cb: Callback<EventType>): void {\n        const idx = this._callbacks.lastIndexOf(cb);\n        if (idx >= 0) {\n            this._callbacks.splice(idx, 1);\n        }\n    }\n\n    public async raise(...ev: EventType): Promise<void> {\n        this._logger.debug(\"raise:\", ...ev);\n        for (const cb of this._callbacks) {\n            await cb(...ev);\n        }\n    }\n}\n","/**\n *\n * @public\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/open#window_features\n */\nexport interface PopupWindowFeatures {\n    left?: number;\n    top?: number;\n    width?: number;\n    height?: number;\n    menubar?: boolean | string;\n    toolbar?: boolean | string;\n    location?: boolean | string;\n    status?: boolean | string;\n    resizable?: boolean | string;\n    scrollbars?: boolean | string;\n    /** Close popup window after time in seconds, by default it is -1. To enable this feature, set value greater than 0. */\n    closePopupWindowAfterInSeconds?: number;\n\n    [k: string]: boolean | string | number | undefined;\n}\n\nexport class PopupUtils {\n    /**\n     * Populates a map of window features with a placement centered in front of\n     * the current window. If no explicit width is given, a default value is\n     * binned into [800, 720, 600, 480, 360] based on the current window's width.\n     */\n    static center({ ...features }: PopupWindowFeatures): PopupWindowFeatures {\n        if (features.width == null)\n            features.width = [800, 720, 600, 480].find(width => width <= window.outerWidth / 1.618) ?? 360;\n        features.left ??= Math.max(0, Math.round(window.screenX + (window.outerWidth - features.width) / 2));\n        if (features.height != null)\n            features.top ??= Math.max(0, Math.round(window.screenY + (window.outerHeight - features.height) / 2));\n        return features;\n    }\n\n    static serialize(features: PopupWindowFeatures): string {\n        return Object.entries(features)\n            .filter(([, value]) => value != null)\n            .map(([key, value]) => `${key}=${typeof value !== \"boolean\" ? value as string : value ? \"yes\" : \"no\"}`)\n            .join(\",\");\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Event } from \"./Event\";\nimport { Logger } from \"./Logger\";\n\n/**\n * @internal\n */\nexport class Timer extends Event<[void]> {\n    protected readonly _logger = new Logger(`Timer('${this._name}')`);\n    private _timerHandle: ReturnType<typeof setInterval> | null = null;\n    private _expiration = 0;\n\n    // get the time\n    public static getEpochTime(): number {\n        return Math.floor(Date.now() / 1000);\n    }\n\n    public init(durationInSeconds: number): void {\n        const logger = this._logger.create(\"init\");\n        durationInSeconds = Math.max(Math.floor(durationInSeconds), 1);\n        const expiration = Timer.getEpochTime() + durationInSeconds;\n        if (this.expiration === expiration && this._timerHandle) {\n            // no need to reinitialize to same expiration, so bail out\n            logger.debug(\"skipping since already initialized for expiration at\", this.expiration);\n            return;\n        }\n\n        this.cancel();\n\n        logger.debug(\"using duration\", durationInSeconds);\n        this._expiration = expiration;\n\n        // we're using a fairly short timer and then checking the expiration in the\n        // callback to handle scenarios where the browser device sleeps, and then\n        // the timers end up getting delayed.\n        const timerDurationInSeconds = Math.min(durationInSeconds, 5);\n        this._timerHandle = setInterval(this._callback, timerDurationInSeconds * 1000);\n    }\n\n    public get expiration(): number {\n        return this._expiration;\n    }\n\n    public cancel(): void {\n        this._logger.create(\"cancel\");\n        if (this._timerHandle) {\n            clearInterval(this._timerHandle);\n            this._timerHandle = null;\n        }\n    }\n\n    protected _callback = (): void => {\n        const diff = this._expiration - Timer.getEpochTime();\n        this._logger.debug(\"timer completes in\", diff);\n\n        if (this._expiration <= Timer.getEpochTime()) {\n            this.cancel();\n            void super.raise();\n        }\n    };\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * @internal\n */\nexport class UrlUtils {\n    public static readParams(url: string, responseMode: \"query\" | \"fragment\" = \"query\"): URLSearchParams {\n        if (!url) throw new TypeError(\"Invalid URL\");\n        // the base URL is irrelevant, it's just here to support relative url arguments\n        const parsedUrl = new URL(url, \"http://127.0.0.1\");\n        const params = parsedUrl[responseMode === \"fragment\" ? \"hash\" : \"search\"];\n        return new URLSearchParams(params.slice(1));\n    }\n}\n\n/**\n * @internal\n */\nexport const URL_STATE_DELIMITER = \";\";","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\n\n/**\n * Error class thrown in case of an authentication error.\n *\n * @public\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n */\nexport class ErrorResponse extends Error {\n    /** Marker to detect class: \"ErrorResponse\" */\n    public readonly name: string = \"ErrorResponse\";\n\n    /** An error code string that can be used to classify the types of errors that occur and to respond to errors. */\n    public readonly error: string | null;\n    /** additional information that can help a developer identify the cause of the error.*/\n    public readonly error_description: string | null;\n    /**\n     * URI identifying a human-readable web page with information about the error, used to provide the client\n       developer with additional information about the error.\n    */\n    public readonly error_uri: string | null;\n\n    /** custom state data set during the initial signin request */\n    public state?: unknown;\n\n    public readonly session_state: string | null;\n\n    public url_state?: string;\n\n    public constructor(\n        args: {\n            error?: string | null; error_description?: string | null; error_uri?: string | null;\n            userState?: unknown; session_state?: string | null; url_state?: string;\n        },\n        /** The x-www-form-urlencoded request body sent to the authority server */\n        public readonly form?: URLSearchParams,\n    ) {\n        super(args.error_description || args.error || \"\");\n\n        if (!args.error) {\n            Logger.error(\"ErrorResponse\", \"No error passed\");\n            throw new Error(\"No error passed\");\n        }\n\n        this.error = args.error;\n        this.error_description = args.error_description ?? null;\n        this.error_uri = args.error_uri ?? null;\n\n        this.state = args.userState;\n        this.session_state = args.session_state ?? null;\n        this.url_state = args.url_state;\n    }\n}\n","// Copyright (C) 2021 AuthTS Contributors\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\n/**\n * Error class thrown in case of network timeouts (e.g IFrame time out).\n *\n * @public\n */\nexport class ErrorTimeout extends Error {\n    /** Marker to detect class: \"ErrorTimeout\" */\n    public readonly name: string = \"ErrorTimeout\";\n\n    public constructor(message?: string) {\n        super(message);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport type AccessTokenCallback = (...ev: unknown[]) => (Promise<void> | void);\n\n/**\n * @public\n */\nexport class AccessTokenEvents {\n    protected readonly _logger = new Logger(\"AccessTokenEvents\");\n\n    private readonly _expiringTimer = new Timer(\"Access token expiring\");\n    private readonly _expiredTimer = new Timer(\"Access token expired\");\n    private readonly _expiringNotificationTimeInSeconds: number;\n\n    public constructor(args: { expiringNotificationTimeInSeconds: number }) {\n        this._expiringNotificationTimeInSeconds = args.expiringNotificationTimeInSeconds;\n    }\n\n    public async load(container: User): Promise<void> {\n        const logger = this._logger.create(\"load\");\n        // only register events if there's an access token and it has an expiration\n        if (container.access_token && container.expires_in !== undefined) {\n            const duration = container.expires_in;\n            logger.debug(\"access token present, remaining duration:\", duration);\n\n            if (duration > 0) {\n                // only register expiring if we still have time\n                let expiring = duration - this._expiringNotificationTimeInSeconds;\n                if (expiring <= 0) {\n                    expiring = 1;\n                }\n\n                logger.debug(\"registering expiring timer, raising in\", expiring, \"seconds\");\n                this._expiringTimer.init(expiring);\n            }\n            else {\n                logger.debug(\"canceling existing expiring timer because we're past expiration.\");\n                this._expiringTimer.cancel();\n            }\n\n            // if it's negative, it will still fire\n            const expired = duration + 1;\n            logger.debug(\"registering expired timer, raising in\", expired, \"seconds\");\n            this._expiredTimer.init(expired);\n        }\n        else {\n            this._expiringTimer.cancel();\n            this._expiredTimer.cancel();\n        }\n    }\n\n    public async unload(): Promise<void> {\n        this._logger.debug(\"unload: canceling existing access token timers\");\n        this._expiringTimer.cancel();\n        this._expiredTimer.cancel();\n    }\n\n    /**\n     * Add callback: Raised prior to the access token expiring.\n     */\n    public addAccessTokenExpiring(cb: AccessTokenCallback): () => void {\n        return this._expiringTimer.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised prior to the access token expiring.\n     */\n    public removeAccessTokenExpiring(cb: AccessTokenCallback): void {\n        this._expiringTimer.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised after the access token has expired.\n     */\n    public addAccessTokenExpired(cb: AccessTokenCallback): () => void {\n        return this._expiredTimer.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised after the access token has expired.\n     */\n    public removeAccessTokenExpired(cb: AccessTokenCallback): void {\n        this._expiredTimer.removeHandler(cb);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\n\n/**\n * @internal\n */\nexport class CheckSessionIFrame {\n    private readonly _logger = new Logger(\"CheckSessionIFrame\");\n    private _frame_origin: string;\n    private _frame: HTMLIFrameElement;\n    private _timer: ReturnType<typeof setInterval> | null = null;\n    private _session_state: string | null = null;\n\n    public constructor(\n        private _callback: () => Promise<void>,\n        private _client_id: string,\n        url: string,\n        private _intervalInSeconds: number,\n        private _stopOnError: boolean,\n    ) {\n        const parsedUrl = new URL(url);\n        this._frame_origin = parsedUrl.origin;\n\n        this._frame = window.document.createElement(\"iframe\");\n\n        // shotgun approach\n        this._frame.style.visibility = \"hidden\";\n        this._frame.style.position = \"fixed\";\n        this._frame.style.left = \"-1000px\";\n        this._frame.style.top = \"0\";\n        this._frame.width = \"0\";\n        this._frame.height = \"0\";\n        this._frame.src = parsedUrl.href;\n    }\n\n    public load(): Promise<void> {\n        return new Promise<void>((resolve) => {\n            this._frame.onload = () => {\n                resolve();\n            };\n\n            window.document.body.appendChild(this._frame);\n            window.addEventListener(\"message\", this._message, false);\n        });\n    }\n\n    private _message = (e: MessageEvent<string>): void => {\n        if (e.origin === this._frame_origin &&\n            e.source === this._frame.contentWindow\n        ) {\n            if (e.data === \"error\") {\n                this._logger.error(\"error message from check session op iframe\");\n                if (this._stopOnError) {\n                    this.stop();\n                }\n            }\n            else if (e.data === \"changed\") {\n                this._logger.debug(\"changed message from check session op iframe\");\n                this.stop();\n                void this._callback();\n            }\n            else {\n                this._logger.debug(e.data + \" message from check session op iframe\");\n            }\n        }\n    };\n\n    public start(session_state: string): void {\n        if (this._session_state === session_state) {\n            return;\n        }\n\n        this._logger.create(\"start\");\n\n        this.stop();\n\n        this._session_state = session_state;\n\n        const send = () => {\n            if (!this._frame.contentWindow || !this._session_state) {\n                return;\n            }\n\n            this._frame.contentWindow.postMessage(this._client_id + \" \" + this._session_state, this._frame_origin);\n        };\n\n        // trigger now\n        send();\n\n        // and setup timer\n        this._timer = setInterval(send, this._intervalInSeconds * 1000);\n    }\n\n    public stop(): void {\n        this._logger.create(\"stop\");\n        this._session_state = null;\n\n        if (this._timer) {\n\n            clearInterval(this._timer);\n            this._timer = null;\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\n\n/**\n * @public\n */\nexport class InMemoryWebStorage implements Storage {\n    private readonly _logger = new Logger(\"InMemoryWebStorage\");\n    private _data: Record<string, string> = {};\n\n    public clear(): void {\n        this._logger.create(\"clear\");\n        this._data = {};\n    }\n\n    public getItem(key: string): string {\n        this._logger.create(`getItem('${key}')`);\n        return this._data[key];\n    }\n\n    public setItem(key: string, value: string): void {\n        this._logger.create(`setItem('${key}')`);\n        this._data[key] = value;\n    }\n\n    public removeItem(key: string): void {\n        this._logger.create(`removeItem('${key}')`);\n        delete this._data[key];\n    }\n\n    public get length(): number {\n        return Object.getOwnPropertyNames(this._data).length;\n    }\n\n    public key(index: number): string {\n        return Object.getOwnPropertyNames(this._data)[index];\n    }\n}\n","export class ErrorDPoPNonce extends Error {\n    /** Marker to detect class: \"ErrorDPoPNonce\" */\n    public readonly name: string = \"ErrorDPoPNonce\";\n    public readonly nonce: string;\n\n    public constructor(nonce: string, message?: string) {\n        super(message);\n        this.nonce = nonce;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { ErrorResponse, ErrorTimeout } from \"./errors\";\nimport type { ExtraHeader } from \"./OidcClientSettings\";\nimport { Logger } from \"./utils\";\nimport { ErrorDPoPNonce } from \"./errors/ErrorDPoPNonce\";\n\n/**\n * @internal\n */\nexport type JwtHandler = (text: string) => Promise<Record<string, unknown>>;\n\n/**\n * @internal\n */\nexport interface GetJsonOpts {\n    token?: string;\n    credentials?: RequestCredentials;\n    timeoutInSeconds?: number;\n}\n\n/**\n * @internal\n */\nexport interface PostFormOpts {\n    body: URLSearchParams;\n    basicAuth?: string;\n    timeoutInSeconds?: number;\n    initCredentials?: \"same-origin\" | \"include\" | \"omit\";\n    extraHeaders?: Record<string, ExtraHeader>;\n}\n\n/**\n * @internal\n */\nexport class JsonService {\n    private readonly _logger = new Logger(\"JsonService\");\n\n    private _contentTypes: string[] = [];\n\n    public constructor(\n        additionalContentTypes: string[] = [],\n        private _jwtHandler: JwtHandler | null = null,\n        private _extraHeaders: Record<string, ExtraHeader> = {},\n    ) {\n        this._contentTypes.push(...additionalContentTypes, \"application/json\");\n        if (_jwtHandler) {\n            this._contentTypes.push(\"application/jwt\");\n        }\n    }\n\n    protected async fetchWithTimeout(input: RequestInfo, init: RequestInit & { timeoutInSeconds?: number } = {}) {\n        const { timeoutInSeconds, ...initFetch } = init;\n        if (!timeoutInSeconds) {\n            return await fetch(input, initFetch);\n        }\n\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), timeoutInSeconds * 1000);\n\n        try {\n            const response = await fetch(input, {\n                ...init,\n                signal: controller.signal,\n            });\n            return response;\n        }\n        catch (err) {\n            if (err instanceof DOMException && err.name === \"AbortError\") {\n                throw new ErrorTimeout(\"Network timed out\");\n            }\n            throw err;\n        }\n        finally {\n            clearTimeout(timeoutId);\n        }\n    }\n\n    public async getJson(url: string, {\n        token,\n        credentials,\n        timeoutInSeconds,\n    }: GetJsonOpts = {}): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"getJson\");\n        const headers: HeadersInit = {\n            \"Accept\": this._contentTypes.join(\", \"),\n        };\n        if (token) {\n            logger.debug(\"token passed, setting Authorization header\");\n            headers[\"Authorization\"] = \"Bearer \" + token;\n        }\n\n        this._appendExtraHeaders(headers);\n\n        let response: Response;\n        try {\n            logger.debug(\"url:\", url);\n            response = await this.fetchWithTimeout(url, { method: \"GET\", headers, timeoutInSeconds, credentials });\n        }\n        catch (err) {\n            logger.error(\"Network Error\");\n            throw err;\n        }\n\n        logger.debug(\"HTTP response received, status\", response.status);\n        const contentType = response.headers.get(\"Content-Type\");\n        if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n            logger.throw(new Error(`Invalid response Content-Type: ${(contentType ?? \"undefined\")}, from URL: ${url}`));\n        }\n        if (response.ok && this._jwtHandler && contentType?.startsWith(\"application/jwt\")) {\n            return await this._jwtHandler(await response.text());\n        }\n        let json: Record<string, unknown>;\n        try {\n            json = await response.json();\n        }\n        catch (err) {\n            logger.error(\"Error parsing JSON response\", err);\n            if (response.ok) throw err;\n            throw new Error(`${response.statusText} (${response.status})`);\n        }\n        if (!response.ok) {\n            logger.error(\"Error from server:\", json);\n            if (json.error) {\n                throw new ErrorResponse(json);\n            }\n            throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n        }\n        return json;\n    }\n\n    public async postForm(url: string, {\n        body,\n        basicAuth,\n        timeoutInSeconds,\n        initCredentials,\n        extraHeaders,\n    }: PostFormOpts): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"postForm\");\n        const headers: HeadersInit = {\n            \"Accept\": this._contentTypes.join(\", \"),\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            ...extraHeaders,\n        };\n        if (basicAuth !== undefined) {\n            headers[\"Authorization\"] = \"Basic \" + basicAuth;\n        }\n\n        this._appendExtraHeaders(headers);\n\n        let response: Response;\n        try {\n            logger.debug(\"url:\", url);\n            response = await this.fetchWithTimeout(url, { method: \"POST\", headers, body, timeoutInSeconds, credentials: initCredentials });\n        }\n        catch (err) {\n            logger.error(\"Network error\");\n            throw err;\n        }\n\n        logger.debug(\"HTTP response received, status\", response.status);\n        const contentType = response.headers.get(\"Content-Type\");\n        if (contentType && !this._contentTypes.find(item => contentType.startsWith(item))) {\n            throw new Error(`Invalid response Content-Type: ${(contentType ?? \"undefined\")}, from URL: ${url}`);\n        }\n\n        const responseText = await response.text();\n\n        let json: Record<string, unknown> = {};\n        if (responseText) {\n            try {\n                json = JSON.parse(responseText);\n            }\n            catch (err) {\n                logger.error(\"Error parsing JSON response\", err);\n                if (response.ok) throw err;\n                throw new Error(`${response.statusText} (${response.status})`);\n            }\n        }\n\n        if (!response.ok) {\n            logger.error(\"Error from server:\", json);\n            if (response.headers.has(\"dpop-nonce\")) {\n                const nonce = response.headers.get(\"dpop-nonce\") as string;\n                throw new ErrorDPoPNonce(nonce, `${JSON.stringify(json)}`);\n            }\n            if (json.error) {\n                throw new ErrorResponse(json, body);\n            }\n            throw new Error(`${response.statusText} (${response.status}): ${JSON.stringify(json)}`);\n        }\n\n        return json;\n    }\n\n    private _appendExtraHeaders(\n        headers: Record<string, string>,\n    ): void {\n        const logger = this._logger.create(\"appendExtraHeaders\");\n        const customKeys = Object.keys(this._extraHeaders);\n        const protectedHeaders = [\n            \"accept\",\n            \"content-type\",\n        ];\n        const preventOverride = [\n            \"authorization\",\n        ];\n        if (customKeys.length === 0) {\n            return;\n        }\n        customKeys.forEach((headerName) => {\n            if (protectedHeaders.includes(headerName.toLocaleLowerCase())) {\n                logger.warn(\"Protected header could not be set\", headerName, protectedHeaders);\n                return;\n            }\n            if (preventOverride.includes(headerName.toLocaleLowerCase()) &&\n                Object.keys(headers).includes(headerName)) {\n                logger.warn(\"Header could not be overridden\", headerName, preventOverride);\n                return;\n            }\n            const content = (typeof this._extraHeaders[headerName] === \"function\") ?\n                (this._extraHeaders[headerName] as ()=>string)() :\n                this._extraHeaders[headerName];\n            if (content && content !== \"\") {\n                headers[headerName] = content;\n            }\n        });\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { OidcClientSettingsStore, SigningKey } from \"./OidcClientSettings\";\nimport type { OidcMetadata } from \"./OidcMetadata\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata\n */\nexport class MetadataService {\n    private readonly _logger = new Logger(\"MetadataService\");\n    private readonly _jsonService;\n\n    // cache\n    private _metadataUrl: string;\n    private _signingKeys: SigningKey[] | null = null;\n    private _metadata: Partial<OidcMetadata> | null = null;\n    private _fetchRequestCredentials: RequestCredentials | undefined;\n\n    public constructor(private readonly _settings: OidcClientSettingsStore) {\n        this._metadataUrl = this._settings.metadataUrl;\n        this._jsonService = new JsonService(\n            [\"application/jwk-set+json\"],\n            null,\n            this._settings.extraHeaders,\n        );\n        if (this._settings.signingKeys) {\n            this._logger.debug(\"using signingKeys from settings\");\n            this._signingKeys = this._settings.signingKeys;\n        }\n\n        if (this._settings.metadata) {\n            this._logger.debug(\"using metadata from settings\");\n            this._metadata = this._settings.metadata;\n        }\n\n        if (this._settings.fetchRequestCredentials) {\n            this._logger.debug(\"using fetchRequestCredentials from settings\");\n            this._fetchRequestCredentials = this._settings.fetchRequestCredentials;\n        }\n    }\n\n    public resetSigningKeys(): void {\n        this._signingKeys = null;\n    }\n\n    public async getMetadata(): Promise<Partial<OidcMetadata>> {\n        const logger = this._logger.create(\"getMetadata\");\n        if (this._metadata) {\n            logger.debug(\"using cached values\");\n            return this._metadata;\n        }\n\n        if (!this._metadataUrl) {\n            logger.throw(new Error(\"No authority or metadataUrl configured on settings\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        logger.debug(\"getting metadata from\", this._metadataUrl);\n        const metadata = await this._jsonService.getJson(this._metadataUrl, { credentials: this._fetchRequestCredentials, timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n\n        logger.debug(\"merging remote JSON with seed metadata\");\n        this._metadata = Object.assign({}, metadata, this._settings.metadataSeed);\n        return this._metadata;\n    }\n\n    public getIssuer(): Promise<string> {\n        return this._getMetadataProperty(\"issuer\") as Promise<string>;\n    }\n\n    public getAuthorizationEndpoint(): Promise<string> {\n        return this._getMetadataProperty(\"authorization_endpoint\") as Promise<string>;\n    }\n\n    public getUserInfoEndpoint(): Promise<string> {\n        return this._getMetadataProperty(\"userinfo_endpoint\") as Promise<string>;\n    }\n\n    public getTokenEndpoint(optional: false): Promise<string>;\n    public getTokenEndpoint(optional?: true): Promise<string | undefined>;\n    public getTokenEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"token_endpoint\", optional) as Promise<string | undefined>;\n    }\n\n    public getCheckSessionIframe(): Promise<string | undefined> {\n        return this._getMetadataProperty(\"check_session_iframe\", true) as Promise<string | undefined>;\n    }\n\n    public getEndSessionEndpoint(): Promise<string | undefined> {\n        return this._getMetadataProperty(\"end_session_endpoint\", true) as Promise<string | undefined>;\n    }\n\n    public getRevocationEndpoint(optional: false): Promise<string>;\n    public getRevocationEndpoint(optional?: true): Promise<string | undefined>;\n    public getRevocationEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"revocation_endpoint\", optional) as Promise<string | undefined>;\n    }\n\n    public getKeysEndpoint(optional: false): Promise<string>;\n    public getKeysEndpoint(optional?: true): Promise<string | undefined>;\n    public getKeysEndpoint(optional = true): Promise<string | undefined> {\n        return this._getMetadataProperty(\"jwks_uri\", optional) as Promise<string | undefined>;\n    }\n\n    protected async _getMetadataProperty(name: keyof OidcMetadata, optional=false): Promise<string | boolean | string[] | undefined> {\n        const logger = this._logger.create(`_getMetadataProperty('${name}')`);\n\n        const metadata = await this.getMetadata();\n        logger.debug(\"resolved\");\n\n        if (metadata[name] === undefined) {\n            if (optional === true) {\n                logger.warn(\"Metadata does not contain optional property\");\n                return undefined;\n            }\n\n            logger.throw(new Error(\"Metadata does not contain property \" + name));\n        }\n\n        return metadata[name];\n    }\n\n    public async getSigningKeys(): Promise<SigningKey[] | null> {\n        const logger = this._logger.create(\"getSigningKeys\");\n        if (this._signingKeys) {\n            logger.debug(\"returning signingKeys from cache\");\n            return this._signingKeys;\n        }\n\n        const jwks_uri = await this.getKeysEndpoint(false);\n        logger.debug(\"got jwks_uri\", jwks_uri);\n\n        const keySet = await this._jsonService.getJson(jwks_uri, { timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n        logger.debug(\"got key set\", keySet);\n\n        if (!Array.isArray(keySet.keys)) {\n            logger.throw(new Error(\"Missing keys on keyset\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        this._signingKeys = keySet.keys;\n        return this._signingKeys;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport type { StateStore } from \"./StateStore\";\nimport type { AsyncStorage } from \"./AsyncStorage\";\n\n/**\n * @public\n */\nexport class WebStorageStateStore implements StateStore {\n    private readonly _logger = new Logger(\"WebStorageStateStore\");\n\n    private readonly _store: AsyncStorage | Storage;\n    private readonly _prefix: string;\n\n    public constructor({\n        prefix = \"oidc.\",\n        store = localStorage,\n    }: { prefix?: string; store?: AsyncStorage | Storage } = {}) {\n        this._store = store;\n        this._prefix = prefix;\n    }\n\n    public async set(key: string, value: string): Promise<void> {\n        this._logger.create(`set('${key}')`);\n\n        key = this._prefix + key;\n        await this._store.setItem(key, value);\n    }\n\n    public async get(key: string): Promise<string | null> {\n        this._logger.create(`get('${key}')`);\n\n        key = this._prefix + key;\n        const item = await this._store.getItem(key);\n        return item;\n    }\n\n    public async remove(key: string): Promise<string | null> {\n        this._logger.create(`remove('${key}')`);\n\n        key = this._prefix + key;\n        const item = await this._store.getItem(key);\n        await this._store.removeItem(key);\n        return item;\n    }\n\n    public async getAllKeys(): Promise<string[]> {\n        this._logger.create(\"getAllKeys\");\n        const len = await this._store.length;\n\n        const keys = [];\n        for (let index = 0; index < len; index++) {\n            const key = await this._store.key(index);\n            if (key && key.indexOf(this._prefix) === 0) {\n                keys.push(key.substr(this._prefix.length));\n            }\n        }\n        return keys;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { WebStorageStateStore } from \"./WebStorageStateStore\";\nimport type { OidcMetadata } from \"./OidcMetadata\";\nimport type { StateStore } from \"./StateStore\";\nimport { InMemoryWebStorage } from \"./InMemoryWebStorage\";\nimport type { DPoPStore } from \"./DPoPStore\";\n\nconst DefaultResponseType = \"code\";\nconst DefaultScope = \"openid\";\nconst DefaultClientAuthentication = \"client_secret_post\";\nconst DefaultStaleStateAgeInSeconds = 60 * 15;\n\n/**\n * @public\n */\nexport type SigningKey = Record<string, string | string[]>;\n\n/**\n * @public\n */\nexport type ExtraHeader = string | (() => string);\n\n/**\n * Optional DPoP settings\n * @public\n */\nexport interface DPoPSettings {\n    bind_authorization_code?: boolean;\n    store: DPoPStore;\n}\n\n/**\n * The settings used to configure the {@link OidcClient}.\n *\n * @public\n */\nexport interface OidcClientSettings {\n    /** The URL of the OIDC/OAuth2 provider */\n    authority: string;\n    metadataUrl?: string;\n    /** Provide metadata when authority server does not allow CORS on the metadata endpoint */\n    metadata?: Partial<OidcMetadata>;\n    /** Can be used to seed or add additional values to the results of the discovery request */\n    metadataSeed?: Partial<OidcMetadata>;\n    /** Provide signingKeys when authority server does not allow CORS on the jwks uri */\n    signingKeys?: SigningKey[];\n\n    /** Your client application's identifier as registered with the OIDC/OAuth2 */\n    client_id: string;\n    client_secret?: string;\n    /** The type of response desired from the OIDC/OAuth2 provider (default: \"code\") */\n    response_type?: string;\n    /** The scope being requested from the OIDC/OAuth2 provider (default: \"openid\") */\n    scope?: string;\n    /** The redirect URI of your client application to receive a response from the OIDC/OAuth2 provider */\n    redirect_uri: string;\n    /** The OIDC/OAuth2 post-logout redirect URI */\n    post_logout_redirect_uri?: string;\n\n    /**\n     * Client authentication method that is used to authenticate when using the token endpoint (default: \"client_secret_post\")\n     * - \"client_secret_basic\": using the HTTP Basic authentication scheme\n     * - \"client_secret_post\": including the client credentials in the request body\n     * - \"client_secret_jwt\": using a JWT signed with the client secret\n     *\n     * See https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication\n     */\n    client_authentication?: \"client_secret_basic\" | \"client_secret_post\" | \"client_secret_jwt\";\n\n    /**\n     * The signature algorithm to use for client_secret_jwt authentication (default: \"HS256\")\n     * Supported algorithms: HS256, HS384, HS512\n     */\n    token_endpoint_auth_signing_alg?: \"HS256\" | \"HS384\" | \"HS512\";\n\n    /** optional protocol param */\n    prompt?: string;\n    /** optional protocol param */\n    display?: string;\n    /** optional protocol param */\n    max_age?: number;\n    /** optional protocol param */\n    ui_locales?: string;\n    /** optional protocol param */\n    acr_values?: string;\n    /** optional protocol param */\n    resource?: string | string[];\n\n    /**\n     * Optional protocol param\n     * The response mode used by the authority server is defined by the response_type unless explicitly specified:\n     * - Response mode for the OAuth 2.0 response type \"code\" is the \"query\" encoding\n     * - Response mode for the OAuth 2.0 response type \"token\" is the \"fragment\" encoding\n     *\n     * @see https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#ResponseModes\n     */\n    response_mode?: \"query\" | \"fragment\";\n\n    /**\n     * Should optional OIDC protocol claims be removed from profile or specify the ones to be removed (default: true)\n     * When true, the following claims are removed by default: [\"nbf\", \"jti\", \"auth_time\", \"nonce\", \"acr\", \"amr\", \"azp\", \"at_hash\"]\n     * When specifying claims, the following claims are not allowed: [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"]\n    */\n    filterProtocolClaims?: boolean | string[];\n    /** Flag to control if additional identity data is loaded from the user info endpoint in order to populate the user's profile (default: false) */\n    loadUserInfo?: boolean;\n    /** Number (in seconds) indicating the age of state entries in storage for authorize requests that are considered abandoned and thus can be cleaned up (default: 900) */\n    staleStateAgeInSeconds?: number;\n\n    /**\n     * Indicates how objects returned from the user info endpoint as claims (e.g. `address`) are merged into the claims from the\n     * id token as a single object.  (default: `{ array: \"replace\" }`)\n     * - array: \"replace\": natives (string, int, float) and arrays are replaced, objects are merged as distinct objects\n     * - array: \"merge\": natives (string, int, float) are replaced, arrays and objects are merged as distinct objects\n     */\n    mergeClaimsStrategy?: { array: \"replace\" | \"merge\" };\n\n    /**\n     * Storage object used to persist interaction state (default: window.localStorage, InMemoryWebStorage iff no window).\n     * E.g. `stateStore: new WebStorageStateStore({ store: window.localStorage })`\n     */\n    stateStore?: StateStore;\n\n    /**\n     * An object containing additional query string parameters to be including in the authorization request.\n     * E.g, when using Azure AD to obtain an access token an additional resource parameter is required. extraQueryParams: `{resource:\"some_identifier\"}`\n     */\n    extraQueryParams?: Record<string, string | number | boolean>;\n\n    extraTokenParams?: Record<string, unknown>;\n\n    /**\n     * An object containing additional header to be including in request.\n     */\n    extraHeaders?: Record<string, ExtraHeader>;\n\n    /**\n     * DPoP enabled or disabled\n     */\n    dpop?: DPoPSettings | undefined;\n\n    /**\n     * Will check the content type header of the response of the revocation endpoint to match these passed values (default: [])\n     */\n    revokeTokenAdditionalContentTypes?: string[];\n    /**\n     * Will disable PKCE validation, changing to true will not append to sign in request code_challenge and code_challenge_method. (default: false)\n     */\n    disablePKCE?: boolean;\n    /**\n     * Sets the credentials for fetch requests. (default: \"same-origin\")\n     * Use this if you need to send cookies to the OIDC/OAuth2 provider or if you are using a proxy that requires cookies\n     */\n    fetchRequestCredentials?: RequestCredentials;\n\n    /**\n     * Only scopes in this list will be passed in the token refresh request.\n     */\n    refreshTokenAllowedScope?: string | undefined;\n\n    /**\n     * Defines request timeouts globally across all requests made to the authorisation server\n     */\n    requestTimeoutInSeconds?: number | undefined;\n\n    /**\n     * https://datatracker.ietf.org/doc/html/rfc6749#section-3.3 describes behavior when omitting scopes from sign in requests\n     * If the IDP supports default scopes, this setting will ignore the scopes property passed to the config. (Default: false)\n     */\n    omitScopeWhenRequesting?: boolean;\n}\n\n/**\n * The settings with defaults applied of the {@link OidcClient}.\n *\n * @public\n * @see {@link OidcClientSettings}\n */\nexport class OidcClientSettingsStore {\n    // metadata\n    public readonly authority: string;\n    public readonly metadataUrl: string;\n    public readonly metadata: Partial<OidcMetadata> | undefined;\n    public readonly metadataSeed: Partial<OidcMetadata> | undefined;\n    public readonly signingKeys: SigningKey[] | undefined;\n\n    // client config\n    public readonly client_id: string;\n    public readonly client_secret: string | undefined;\n    public readonly response_type: string;\n    public readonly scope: string;\n    public readonly redirect_uri: string;\n    public readonly post_logout_redirect_uri: string | undefined;\n    public readonly client_authentication: \"client_secret_basic\" | \"client_secret_post\" | \"client_secret_jwt\";\n    public readonly token_endpoint_auth_signing_alg: \"HS256\" | \"HS384\" | \"HS512\";\n\n    // optional protocol params\n    public readonly prompt: string | undefined;\n    public readonly display: string | undefined;\n    public readonly max_age: number | undefined;\n    public readonly ui_locales: string | undefined;\n    public readonly acr_values: string | undefined;\n    public readonly resource: string | string[] | undefined;\n    public readonly response_mode: \"query\" | \"fragment\" | undefined;\n\n    // behavior flags\n    public readonly filterProtocolClaims: boolean | string[];\n    public readonly loadUserInfo: boolean;\n    public readonly staleStateAgeInSeconds: number;\n    public readonly mergeClaimsStrategy: { array: \"replace\" | \"merge\" };\n    public readonly omitScopeWhenRequesting: boolean;\n\n    public readonly stateStore: StateStore;\n\n    // extra\n    public readonly extraQueryParams: Record<string, string | number | boolean>;\n    public readonly extraTokenParams: Record<string, unknown>;\n    public readonly dpop: DPoPSettings | undefined;\n    public readonly extraHeaders: Record<string, ExtraHeader>;\n\n    public readonly revokeTokenAdditionalContentTypes?: string[];\n    public readonly fetchRequestCredentials: RequestCredentials;\n    public readonly refreshTokenAllowedScope: string | undefined;\n    public readonly disablePKCE: boolean;\n    public readonly requestTimeoutInSeconds: number | undefined;\n\n    public constructor({\n        // metadata related\n        authority, metadataUrl, metadata, signingKeys, metadataSeed,\n        // client related\n        client_id, client_secret, response_type = DefaultResponseType, scope = DefaultScope,\n        redirect_uri, post_logout_redirect_uri,\n        client_authentication = DefaultClientAuthentication,\n        token_endpoint_auth_signing_alg = \"HS256\",\n        // optional protocol\n        prompt, display, max_age, ui_locales, acr_values, resource, response_mode,\n        // behavior flags\n        filterProtocolClaims = true,\n        loadUserInfo = false,\n        requestTimeoutInSeconds,\n        staleStateAgeInSeconds = DefaultStaleStateAgeInSeconds,\n        mergeClaimsStrategy = { array: \"replace\" },\n        disablePKCE = false,\n        // other behavior\n        stateStore,\n        revokeTokenAdditionalContentTypes,\n        fetchRequestCredentials,\n        refreshTokenAllowedScope,\n        // extra\n        extraQueryParams = {},\n        extraTokenParams = {},\n        extraHeaders = {},\n        dpop,\n        omitScopeWhenRequesting = false,\n    }: OidcClientSettings) {\n\n        this.authority = authority;\n\n        if (metadataUrl) {\n            this.metadataUrl = metadataUrl;\n        } else {\n            this.metadataUrl = authority;\n            if (authority) {\n                if (!this.metadataUrl.endsWith(\"/\")) {\n                    this.metadataUrl += \"/\";\n                }\n                this.metadataUrl += \".well-known/openid-configuration\";\n            }\n        }\n\n        this.metadata = metadata;\n        this.metadataSeed = metadataSeed;\n        this.signingKeys = signingKeys;\n\n        this.client_id = client_id;\n        this.client_secret = client_secret;\n        this.response_type = response_type;\n        this.scope = scope;\n        this.redirect_uri = redirect_uri;\n        this.post_logout_redirect_uri = post_logout_redirect_uri;\n        this.client_authentication = client_authentication;\n        this.token_endpoint_auth_signing_alg = token_endpoint_auth_signing_alg;\n\n        this.prompt = prompt;\n        this.display = display;\n        this.max_age = max_age;\n        this.ui_locales = ui_locales;\n        this.acr_values = acr_values;\n        this.resource = resource;\n        this.response_mode = response_mode;\n\n        this.filterProtocolClaims = filterProtocolClaims ?? true;\n        this.loadUserInfo = !!loadUserInfo;\n        this.staleStateAgeInSeconds = staleStateAgeInSeconds;\n        this.mergeClaimsStrategy = mergeClaimsStrategy;\n        this.omitScopeWhenRequesting = omitScopeWhenRequesting;\n        this.disablePKCE = !!disablePKCE;\n        this.revokeTokenAdditionalContentTypes = revokeTokenAdditionalContentTypes;\n\n        this.fetchRequestCredentials = fetchRequestCredentials ? fetchRequestCredentials : \"same-origin\";\n        this.requestTimeoutInSeconds = requestTimeoutInSeconds;\n\n        if (stateStore) {\n            this.stateStore = stateStore;\n        }\n        else {\n            const store = typeof window !== \"undefined\" ? window.localStorage : new InMemoryWebStorage();\n            this.stateStore = new WebStorageStateStore({ store });\n        }\n\n        this.refreshTokenAllowedScope = refreshTokenAllowedScope;\n\n        this.extraQueryParams = extraQueryParams;\n        this.extraTokenParams = extraTokenParams;\n        this.extraHeaders = extraHeaders;\n\n        this.dpop = dpop;\n        if (this.dpop && !this.dpop?.store) {\n            throw new Error(\"A DPoPStore is required when dpop is enabled\");\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, JwtUtils } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { MetadataService } from \"./MetadataService\";\nimport type { JwtClaims } from \"./Claims\";\nimport type { OidcClientSettingsStore } from \"./OidcClientSettings\";\n\n/**\n * @internal\n */\nexport class UserInfoService {\n    protected readonly _logger = new Logger(\"UserInfoService\");\n    private readonly _jsonService: JsonService;\n\n    public constructor(private readonly _settings: OidcClientSettingsStore,\n        private readonly _metadataService: MetadataService,\n    ) {\n        this._jsonService = new JsonService(\n            undefined,\n            this._getClaimsFromJwt,\n            this._settings.extraHeaders,\n        );\n    }\n\n    public async getClaims(token: string): Promise<JwtClaims> {\n        const logger = this._logger.create(\"getClaims\");\n        if (!token) {\n            this._logger.throw(new Error(\"No token passed\"));\n        }\n\n        const url = await this._metadataService.getUserInfoEndpoint();\n        logger.debug(\"got userinfo url\", url);\n\n        const claims = await this._jsonService.getJson(url, {\n            token,\n            credentials: this._settings.fetchRequestCredentials,\n            timeoutInSeconds: this._settings.requestTimeoutInSeconds,\n        });\n        logger.debug(\"got claims\", claims);\n\n        return claims;\n    }\n\n    protected _getClaimsFromJwt = async (responseText: string): Promise<JwtClaims> => {\n        const logger = this._logger.create(\"_getClaimsFromJwt\");\n        try {\n            const payload = JwtUtils.decode(responseText);\n            logger.debug(\"JWT decoding successful\");\n\n            return payload;\n        } catch (err) {\n            logger.error(\"Error parsing JWT response\");\n            throw err;\n        }\n    };\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { CryptoUtils, Logger } from \"./utils\";\nimport { JsonService } from \"./JsonService\";\nimport type { MetadataService } from \"./MetadataService\";\nimport type { ExtraHeader, OidcClientSettingsStore } from \"./OidcClientSettings\";\n\n/**\n * @internal\n */\nexport interface ExchangeCodeArgs {\n    client_id?: string;\n    client_secret?: string;\n    redirect_uri?: string;\n\n    grant_type?: string;\n    code: string;\n    code_verifier?: string;\n\n    extraHeaders?: Record<string, ExtraHeader>;\n}\n\n/**\n * @internal\n */\nexport interface ExchangeCredentialsArgs {\n    client_id?: string;\n    client_secret?: string;\n\n    grant_type?: string;\n    scope?: string;\n\n    username: string;\n    password: string;\n}\n\n/**\n * @internal\n */\nexport interface ExchangeRefreshTokenArgs {\n    client_id?: string;\n    client_secret?: string;\n    redirect_uri?: string;\n\n    grant_type?: string;\n    refresh_token: string;\n    scope?: string;\n    resource?: string | string[];\n\n    timeoutInSeconds?: number;\n\n    extraHeaders?: Record<string, ExtraHeader>;\n}\n\n/**\n * @internal\n */\nexport interface RevokeArgs {\n    token: string;\n    token_type_hint?: \"access_token\" | \"refresh_token\";\n}\n\n/**\n * @internal\n */\nexport class TokenClient {\n    private readonly _logger = new Logger(\"TokenClient\");\n    private readonly _jsonService;\n\n    public constructor(\n        private readonly _settings: OidcClientSettingsStore,\n        private readonly _metadataService: MetadataService,\n    ) {\n        this._jsonService = new JsonService(\n            this._settings.revokeTokenAdditionalContentTypes,\n            null,\n            this._settings.extraHeaders,\n        );\n    }\n\n    /**\n     * Exchange code.\n     *\n     * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.3\n     */\n    public async exchangeCode({\n        grant_type = \"authorization_code\",\n        redirect_uri = this._settings.redirect_uri,\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        extraHeaders,\n        ...args\n    }: ExchangeCodeArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeCode\");\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n        if (!redirect_uri) {\n            logger.throw(new Error(\"A redirect_uri is required\"));\n        }\n        if (!args.code) {\n            logger.throw(new Error(\"A code is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type, redirect_uri });\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n\n        // Validate client_secret if required before making any external calls\n        if ((this._settings.client_authentication === \"client_secret_basic\" ||\n             this._settings.client_authentication === \"client_secret_jwt\") &&\n            (client_secret === undefined || client_secret === null)) {\n            logger.throw(new Error(\"A client_secret is required\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        let basicAuth: string | undefined;\n        const url = await this._metadataService.getTokenEndpoint(false);\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret!);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n            case \"client_secret_jwt\": {\n                const clientAssertion = await CryptoUtils.generateClientAssertionJwt(client_id, client_secret!, url, this._settings.token_endpoint_auth_signing_alg);\n                params.append(\"client_id\", client_id);\n                params.append(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n                params.append(\"client_assertion\", clientAssertion);\n                break;\n            }\n        }\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, {\n            body: params,\n            basicAuth,\n            timeoutInSeconds: this._settings.requestTimeoutInSeconds,\n            initCredentials: this._settings.fetchRequestCredentials,\n            extraHeaders,\n        });\n\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    /**\n     * Exchange credentials.\n     *\n     * @see https://www.rfc-editor.org/rfc/rfc6749#section-4.3.2\n     */\n    public async exchangeCredentials({\n        grant_type = \"password\",\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        scope = this._settings.scope,\n        ...args\n    }: ExchangeCredentialsArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeCredentials\");\n\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type });\n        if (!this._settings.omitScopeWhenRequesting) {\n            params.set(\"scope\", scope);\n        }\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n\n        // Validate client_secret if required before making any external calls\n        if ((this._settings.client_authentication === \"client_secret_basic\" ||\n             this._settings.client_authentication === \"client_secret_jwt\") &&\n            (client_secret === undefined || client_secret === null)) {\n            logger.throw(new Error(\"A client_secret is required\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        let basicAuth: string | undefined;\n        const url = await this._metadataService.getTokenEndpoint(false);\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret!);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n            case \"client_secret_jwt\": {\n                const clientAssertion = await CryptoUtils.generateClientAssertionJwt(client_id, client_secret!, url, this._settings.token_endpoint_auth_signing_alg);\n                params.append(\"client_id\", client_id);\n                params.append(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n                params.append(\"client_assertion\", clientAssertion);\n                break;\n            }\n        }\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds: this._settings.requestTimeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials });\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    /**\n     * Exchange a refresh token.\n     *\n     * @see https://www.rfc-editor.org/rfc/rfc6749#section-6\n     */\n    public async exchangeRefreshToken({\n        grant_type = \"refresh_token\",\n        client_id = this._settings.client_id,\n        client_secret = this._settings.client_secret,\n        timeoutInSeconds,\n        extraHeaders,\n        ...args\n    }: ExchangeRefreshTokenArgs): Promise<Record<string, unknown>> {\n        const logger = this._logger.create(\"exchangeRefreshToken\");\n        if (!client_id) {\n            logger.throw(new Error(\"A client_id is required\"));\n        }\n        if (!args.refresh_token) {\n            logger.throw(new Error(\"A refresh_token is required\"));\n        }\n\n        const params = new URLSearchParams({ grant_type });\n        for (const [key, value] of Object.entries(args)) {\n            if (Array.isArray(value)) {\n                value.forEach(param => params.append(key, param));\n            }\n            else if (value != null) {\n                params.set(key, value);\n            }\n        }\n\n        // Validate client_secret if required before making any external calls\n        if ((this._settings.client_authentication === \"client_secret_basic\" ||\n             this._settings.client_authentication === \"client_secret_jwt\") &&\n            (client_secret === undefined || client_secret === null)) {\n            logger.throw(new Error(\"A client_secret is required\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        let basicAuth: string | undefined;\n        const url = await this._metadataService.getTokenEndpoint(false);\n        switch (this._settings.client_authentication) {\n            case \"client_secret_basic\":\n                basicAuth = CryptoUtils.generateBasicAuth(client_id, client_secret!);\n                break;\n            case \"client_secret_post\":\n                params.append(\"client_id\", client_id);\n                if (client_secret) {\n                    params.append(\"client_secret\", client_secret);\n                }\n                break;\n            case \"client_secret_jwt\": {\n                const clientAssertion = await CryptoUtils.generateClientAssertionJwt(client_id, client_secret!, url, this._settings.token_endpoint_auth_signing_alg);\n                params.append(\"client_id\", client_id);\n                params.append(\"client_assertion_type\", \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\");\n                params.append(\"client_assertion\", clientAssertion);\n                break;\n            }\n        }\n        logger.debug(\"got token endpoint\");\n\n        const response = await this._jsonService.postForm(url, { body: params, basicAuth, timeoutInSeconds, initCredentials: this._settings.fetchRequestCredentials, extraHeaders });\n        logger.debug(\"got response\");\n\n        return response;\n    }\n\n    /**\n     * Revoke an access or refresh token.\n     *\n     * @see https://datatracker.ietf.org/doc/html/rfc7009#section-2.1\n     */\n    public async revoke(args: RevokeArgs): Promise<void> {\n        const logger = this._logger.create(\"revoke\");\n        if (!args.token) {\n            logger.throw(new Error(\"A token is required\"));\n        }\n\n        const url = await this._metadataService.getRevocationEndpoint(false);\n\n        logger.debug(`got revocation endpoint, revoking ${args.token_type_hint ?? \"default token type\"}`);\n\n        const params = new URLSearchParams();\n        for (const [key, value] of Object.entries(args)) {\n            if (value != null) {\n                params.set(key, value);\n            }\n        }\n        params.set(\"client_id\", this._settings.client_id);\n        if (this._settings.client_secret) {\n            params.set(\"client_secret\", this._settings.client_secret);\n        }\n\n        await this._jsonService.postForm(url, { body: params, timeoutInSeconds: this._settings.requestTimeoutInSeconds });\n        logger.debug(\"got response\");\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, JwtUtils } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport type { MetadataService } from \"./MetadataService\";\nimport { UserInfoService } from \"./UserInfoService\";\nimport { TokenClient } from \"./TokenClient\";\nimport type { ExtraHeader, OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport type { SigninState } from \"./SigninState\";\nimport type { SigninResponse } from \"./SigninResponse\";\nimport type { State } from \"./State\";\nimport type { SignoutResponse } from \"./SignoutResponse\";\nimport type { UserProfile } from \"./User\";\nimport type { RefreshState } from \"./RefreshState\";\nimport type { IdTokenClaims } from \"./Claims\";\nimport type { ClaimsService } from \"./ClaimsService\";\n\n/**\n * @internal\n */\nexport class ResponseValidator {\n    protected readonly _logger = new Logger(\"ResponseValidator\");\n    protected readonly _userInfoService: UserInfoService;\n    protected readonly _tokenClient: TokenClient;\n\n    public constructor(\n        protected readonly _settings: OidcClientSettingsStore,\n        protected readonly _metadataService: MetadataService,\n        protected readonly _claimsService: ClaimsService,\n    ) {\n        this._userInfoService = new UserInfoService(this._settings, this._metadataService);\n        this._tokenClient = new TokenClient(this._settings, this._metadataService);\n    }\n\n    public async validateSigninResponse(response: SigninResponse, state: SigninState, extraHeaders?: Record<string, ExtraHeader>): Promise<void> {\n        const logger = this._logger.create(\"validateSigninResponse\");\n\n        this._processSigninState(response, state);\n        logger.debug(\"state processed\");\n\n        await this._processCode(response, state, extraHeaders);\n        logger.debug(\"code processed\");\n\n        if (response.isOpenId) {\n            this._validateIdTokenAttributes(response);\n        }\n        logger.debug(\"tokens validated\");\n\n        await this._processClaims(response, state?.skipUserInfo, response.isOpenId);\n        logger.debug(\"claims processed\");\n    }\n\n    public async validateCredentialsResponse(response: SigninResponse, skipUserInfo: boolean): Promise<void> {\n        const logger = this._logger.create(\"validateCredentialsResponse\");\n        const shouldValidateSubClaim = response.isOpenId && !!response.id_token;\n\n        if (shouldValidateSubClaim) {\n            this._validateIdTokenAttributes(response);\n        }\n        logger.debug(\"tokens validated\");\n\n        await this._processClaims(response, skipUserInfo, shouldValidateSubClaim);\n        logger.debug(\"claims processed\");\n    }\n\n    public async validateRefreshResponse(response: SigninResponse, state: RefreshState): Promise<void> {\n        const logger = this._logger.create(\"validateRefreshResponse\");\n\n        response.userState = state.data;\n        // if there's no session_state on the response, copy over session_state from original request\n        response.session_state ??= state.session_state;\n        // if there's no scope on the response, then assume all scopes granted (per-spec) and copy over scopes from original request\n        response.scope ??= state.scope;\n\n        // OpenID Connect Core 1.0 says that id_token is optional in refresh response:\n        // https://openid.net/specs/openid-connect-core-1_0.html#RefreshTokenResponse\n        if (response.isOpenId && !!response.id_token) {\n            this._validateIdTokenAttributes(response, state.id_token);\n            logger.debug(\"ID Token validated\");\n        }\n\n        if (!response.id_token) {\n            // if there's no id_token on the response, copy over id_token from original request\n            response.id_token = state.id_token;\n            // and decoded part too\n            response.profile = state.profile;\n        }\n\n        const hasIdToken = response.isOpenId && !!response.id_token;\n        await this._processClaims(response, false, hasIdToken);\n        logger.debug(\"claims processed\");\n    }\n\n    public validateSignoutResponse(response: SignoutResponse, state: State): void {\n        const logger = this._logger.create(\"validateSignoutResponse\");\n        if (state.id !== response.state) {\n            logger.throw(new Error(\"State does not match\"));\n        }\n\n        // now that we know the state matches, take the stored data\n        // and set it into the response so callers can get their state\n        // this is important for both success & error outcomes\n        logger.debug(\"state validated\");\n        response.userState = state.data;\n\n        if (response.error) {\n            logger.warn(\"Response was error\", response.error);\n            throw new ErrorResponse(response);\n        }\n    }\n\n    protected _processSigninState(response: SigninResponse, state: SigninState): void {\n        const logger = this._logger.create(\"_processSigninState\");\n        if (state.id !== response.state) {\n            logger.throw(new Error(\"State does not match\"));\n        }\n\n        if (!state.client_id) {\n            logger.throw(new Error(\"No client_id on state\"));\n        }\n\n        if (!state.authority) {\n            logger.throw(new Error(\"No authority on state\"));\n        }\n\n        // ensure we're using the correct authority\n        if (this._settings.authority !== state.authority) {\n            logger.throw(new Error(\"authority mismatch on settings vs. signin state\"));\n        }\n        if (this._settings.client_id && this._settings.client_id !== state.client_id) {\n            logger.throw(new Error(\"client_id mismatch on settings vs. signin state\"));\n        }\n\n        // now that we know the state matches, take the stored data\n        // and set it into the response so callers can get their state\n        // this is important for both success & error outcomes\n        logger.debug(\"state validated\");\n        response.userState = state.data;\n        response.url_state = state.url_state;\n        // if there's no scope on the response, then assume all scopes granted (per-spec) and copy over scopes from original request\n        response.scope ??= state.scope;\n\n        if (response.error) {\n            logger.warn(\"Response was error\", response.error);\n            throw new ErrorResponse(response);\n        }\n\n        if (state.code_verifier && !response.code) {\n            logger.throw(new Error(\"Expected code in response\"));\n        }\n\n    }\n\n    protected async _processClaims(response: SigninResponse, skipUserInfo = false, validateSub = true): Promise<void> {\n        const logger = this._logger.create(\"_processClaims\");\n        response.profile = this._claimsService.filterProtocolClaims(response.profile);\n\n        if (skipUserInfo || !this._settings.loadUserInfo || !response.access_token) {\n            logger.debug(\"not loading user info\");\n            return;\n        }\n\n        logger.debug(\"loading user info\");\n        const claims = await this._userInfoService.getClaims(response.access_token);\n        logger.debug(\"user info claims received from user info endpoint\");\n\n        if (validateSub && claims.sub !== response.profile.sub) {\n            logger.throw(new Error(\"subject from UserInfo response does not match subject in ID Token\"));\n        }\n\n        response.profile = this._claimsService.mergeClaims(response.profile, this._claimsService.filterProtocolClaims(claims as IdTokenClaims));\n        logger.debug(\"user info claims received, updated profile:\", response.profile);\n    }\n\n    protected async _processCode(response: SigninResponse, state: SigninState, extraHeaders?: Record<string, ExtraHeader>): Promise<void> {\n        const logger = this._logger.create(\"_processCode\");\n        if (response.code) {\n            logger.debug(\"Validating code\");\n            const tokenResponse = await this._tokenClient.exchangeCode({\n                client_id: state.client_id,\n                client_secret: state.client_secret,\n                code: response.code,\n                redirect_uri: state.redirect_uri,\n                code_verifier: state.code_verifier,\n                extraHeaders: extraHeaders,\n                ...state.extraTokenParams,\n            });\n            Object.assign(response, tokenResponse);\n        } else {\n            logger.debug(\"No code to process\");\n        }\n    }\n\n    protected _validateIdTokenAttributes(response: SigninResponse, existingToken?: string): void {\n        const logger = this._logger.create(\"_validateIdTokenAttributes\");\n\n        logger.debug(\"decoding ID Token JWT\");\n        const incoming = JwtUtils.decode(response.id_token ?? \"\");\n\n        if (!incoming.sub) {\n            logger.throw(new Error(\"ID Token is missing a subject claim\"));\n        }\n\n        if (existingToken) {\n            const existing = JwtUtils.decode(existingToken);\n            if (incoming.sub !== existing.sub) {\n                logger.throw(new Error(\"sub in id_token does not match current sub\"));\n            }\n            if (incoming.auth_time && incoming.auth_time !== existing.auth_time) {\n                logger.throw(new Error(\"auth_time in id_token does not match original auth_time\"));\n            }\n            if (incoming.azp && incoming.azp !== existing.azp) {\n                logger.throw(new Error(\"azp in id_token does not match original azp\"));\n            }\n            if (!incoming.azp && existing.azp) {\n                logger.throw(new Error(\"azp not in id_token, but present in original id_token\"));\n            }\n        }\n\n        response.profile = incoming as UserProfile;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, CryptoUtils, Timer } from \"./utils\";\nimport type { StateStore } from \"./StateStore\";\n\n/**\n * @public\n */\nexport class State {\n    public readonly id: string;\n    public readonly created: number;\n    public readonly request_type: string | undefined;\n    public readonly url_state: string | undefined;\n\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    public readonly data?: unknown;\n\n    public constructor(args: {\n        id?: string;\n        data?: unknown;\n        created?: number;\n        request_type?: string;\n        url_state?: string;\n    }) {\n        this.id = args.id || CryptoUtils.generateUUIDv4();\n        this.data = args.data;\n\n        if (args.created && args.created > 0) {\n            this.created = args.created;\n        }\n        else {\n            this.created = Timer.getEpochTime();\n        }\n        this.request_type = args.request_type;\n        this.url_state = args.url_state;\n    }\n\n    public toStorageString(): string {\n        new Logger(\"State\").create(\"toStorageString\");\n        return JSON.stringify({\n            id: this.id,\n            data: this.data,\n            created: this.created,\n            request_type: this.request_type,\n            url_state: this.url_state,\n        });\n    }\n\n    public static fromStorageString(storageString: string): Promise<State> {\n        Logger.createStatic(\"State\", \"fromStorageString\");\n        return Promise.resolve(new State(JSON.parse(storageString)));\n    }\n\n    public static async clearStaleState(storage: StateStore, age: number): Promise<void> {\n        const logger = Logger.createStatic(\"State\", \"clearStaleState\");\n        const cutoff = Timer.getEpochTime() - age;\n\n        const keys = await storage.getAllKeys();\n        logger.debug(\"got keys\", keys);\n\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const item = await storage.get(key);\n            let remove = false;\n\n            if (item) {\n                try {\n                    const state = await State.fromStorageString(item);\n\n                    logger.debug(\"got item from key:\", key, state.created);\n                    if (state.created <= cutoff) {\n                        remove = true;\n                    }\n                }\n                catch (err) {\n                    logger.error(\"Error parsing state for key:\", key, err);\n                    remove = true;\n                }\n            }\n            else {\n                logger.debug(\"no item in storage for key:\", key);\n                remove = true;\n            }\n\n            if (remove) {\n                logger.debug(\"removed item for key:\", key);\n                void storage.remove(key);\n            }\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, CryptoUtils } from \"./utils\";\nimport { State } from \"./State\";\n\n/** @public */\nexport interface SigninStateArgs {\n    id?: string;\n    data?: unknown;\n    created?: number;\n    request_type?: string;\n\n    code_verifier?: string;\n    code_challenge?: string;\n    authority: string;\n    client_id: string;\n    redirect_uri: string;\n    scope: string;\n    client_secret?: string;\n    extraTokenParams?: Record<string, unknown>;\n    response_mode?: \"query\" | \"fragment\";\n    skipUserInfo?: boolean;\n    url_state?: string;\n}\n\n/** @public */\nexport type SigninStateCreateArgs = Omit<SigninStateArgs, \"code_verifier\"> & {\n    code_verifier?: string | boolean;\n};\n\n/**\n * @public\n */\nexport class SigninState extends State {\n    // isCode\n    /** The same code_verifier that was used to obtain the authorization_code via PKCE. */\n    public readonly code_verifier: string | undefined;\n    /** Used to secure authorization code grants via Proof Key for Code Exchange (PKCE). */\n    public readonly code_challenge: string | undefined;\n\n    // to ensure state still matches settings\n    /** @see {@link OidcClientSettings.authority} */\n    public readonly authority: string;\n    /** @see {@link OidcClientSettings.client_id} */\n    public readonly client_id: string;\n    /** @see {@link OidcClientSettings.redirect_uri} */\n    public readonly redirect_uri: string;\n    /** @see {@link OidcClientSettings.scope} */\n    public readonly scope: string;\n    /** @see {@link OidcClientSettings.client_secret} */\n    public readonly client_secret: string | undefined;\n    /** @see {@link OidcClientSettings.extraTokenParams} */\n    public readonly extraTokenParams: Record<string, unknown> | undefined;\n    /** @see {@link OidcClientSettings.response_mode} */\n    public readonly response_mode: \"query\" | \"fragment\" | undefined;\n\n    public readonly skipUserInfo: boolean | undefined;\n\n    private constructor(args: SigninStateArgs) {\n        super(args);\n\n        this.code_verifier = args.code_verifier;\n        this.code_challenge = args.code_challenge;\n        this.authority = args.authority;\n        this.client_id = args.client_id;\n        this.redirect_uri = args.redirect_uri;\n        this.scope = args.scope;\n        this.client_secret = args.client_secret;\n        this.extraTokenParams = args.extraTokenParams;\n\n        this.response_mode = args.response_mode;\n        this.skipUserInfo = args.skipUserInfo;\n    }\n\n    public static async create(args: SigninStateCreateArgs): Promise<SigninState> {\n        const code_verifier = args.code_verifier === true ? CryptoUtils.generateCodeVerifier() : (args.code_verifier || undefined);\n        const code_challenge = code_verifier ? (await CryptoUtils.generateCodeChallenge(code_verifier)) : undefined;\n\n        return new SigninState({\n            ...args,\n            code_verifier,\n            code_challenge,\n        });\n    }\n\n    public toStorageString(): string {\n        new Logger(\"SigninState\").create(\"toStorageString\");\n        return JSON.stringify({\n            id: this.id,\n            data: this.data,\n            created: this.created,\n            request_type: this.request_type,\n            url_state: this.url_state,\n\n            code_verifier: this.code_verifier,\n            authority: this.authority,\n            client_id: this.client_id,\n            redirect_uri: this.redirect_uri,\n            scope: this.scope,\n            client_secret: this.client_secret,\n            extraTokenParams : this.extraTokenParams,\n            response_mode: this.response_mode,\n            skipUserInfo: this.skipUserInfo,\n        });\n    }\n\n    public static fromStorageString(storageString: string): Promise<SigninState> {\n        Logger.createStatic(\"SigninState\", \"fromStorageString\");\n        const data = JSON.parse(storageString);\n        return SigninState.create(data);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, URL_STATE_DELIMITER } from \"./utils\";\nimport { SigninState } from \"./SigninState\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest\n */\nexport interface SigninRequestCreateArgs {\n    // mandatory\n    url: string;\n    authority: string;\n    client_id: string;\n    redirect_uri: string;\n    response_type: string;\n    scope: string;\n\n    // optional\n    response_mode?: \"query\" | \"fragment\";\n    nonce?: string;\n    display?: string;\n    dpopJkt?: string;\n    prompt?: string;\n    max_age?: number;\n    ui_locales?: string;\n    id_token_hint?: string;\n    login_hint?: string;\n    acr_values?: string;\n\n    // other\n    resource?: string | string[];\n    request?: string;\n    request_uri?: string;\n    request_type?: string;\n    extraQueryParams?: Record<string, string | number | boolean>;\n\n    // special\n    extraTokenParams?: Record<string, unknown>;\n    client_secret?: string;\n    skipUserInfo?: boolean;\n    disablePKCE?: boolean;\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state_data?: unknown;\n    url_state?: string;\n    omitScopeWhenRequesting?: boolean;\n}\n\n/**\n * @public\n */\nexport class SigninRequest {\n    private static readonly _logger = new Logger(\"SigninRequest\");\n\n    public readonly url: string;\n    public readonly state: SigninState;\n\n    private constructor(args: {\n        url: string;\n        state: SigninState;\n    }) {\n        this.url = args.url;\n        this.state = args.state;\n    }\n\n    public static async create({\n        // mandatory\n        url, authority, client_id, redirect_uri, response_type, scope,\n        // optional\n        state_data, response_mode, request_type, client_secret, nonce, url_state,\n        resource,\n        skipUserInfo,\n        extraQueryParams,\n        extraTokenParams,\n        disablePKCE,\n        dpopJkt,\n        omitScopeWhenRequesting,\n        ...optionalParams\n    }: SigninRequestCreateArgs): Promise<SigninRequest> {\n        if (!url) {\n            this._logger.error(\"create: No url passed\");\n            throw new Error(\"url\");\n        }\n        if (!client_id) {\n            this._logger.error(\"create: No client_id passed\");\n            throw new Error(\"client_id\");\n        }\n        if (!redirect_uri) {\n            this._logger.error(\"create: No redirect_uri passed\");\n            throw new Error(\"redirect_uri\");\n        }\n        if (!response_type) {\n            this._logger.error(\"create: No response_type passed\");\n            throw new Error(\"response_type\");\n        }\n        if (!scope) {\n            this._logger.error(\"create: No scope passed\");\n            throw new Error(\"scope\");\n        }\n        if (!authority) {\n            this._logger.error(\"create: No authority passed\");\n            throw new Error(\"authority\");\n        }\n\n        const state = await SigninState.create({\n            data: state_data,\n            request_type,\n            url_state,\n            code_verifier: !disablePKCE,\n            client_id, authority, redirect_uri,\n            response_mode,\n            client_secret, scope, extraTokenParams,\n            skipUserInfo,\n        });\n\n        const parsedUrl = new URL(url);\n        parsedUrl.searchParams.append(\"client_id\", client_id);\n        parsedUrl.searchParams.append(\"redirect_uri\", redirect_uri);\n        parsedUrl.searchParams.append(\"response_type\", response_type);\n        if (!omitScopeWhenRequesting) {\n            parsedUrl.searchParams.append(\"scope\", scope);\n        }\n        if (nonce) {\n            parsedUrl.searchParams.append(\"nonce\", nonce);\n        }\n\n        if (dpopJkt) {\n            parsedUrl.searchParams.append(\"dpop_jkt\", dpopJkt);\n        }\n\n        let stateParam = state.id;\n        if (url_state) {\n            stateParam = `${stateParam}${URL_STATE_DELIMITER}${url_state}`;\n        }\n        parsedUrl.searchParams.append(\"state\", stateParam);\n        if (state.code_challenge) {\n            parsedUrl.searchParams.append(\"code_challenge\", state.code_challenge);\n            parsedUrl.searchParams.append(\"code_challenge_method\", \"S256\");\n        }\n\n        if (resource) {\n            // https://datatracker.ietf.org/doc/html/rfc8707\n            const resources = Array.isArray(resource) ? resource : [resource];\n            resources\n                .forEach(r => parsedUrl.searchParams.append(\"resource\", r));\n        }\n\n        for (const [key, value] of Object.entries({ response_mode, ...optionalParams, ...extraQueryParams })) {\n            if (value != null) {\n                parsedUrl.searchParams.append(key, value.toString());\n            }\n        }\n\n        return new SigninRequest({\n            url: parsedUrl.href,\n            state,\n        });\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Timer, URL_STATE_DELIMITER } from \"./utils\";\nimport type { UserProfile } from \"./User\";\n\nconst OidcScope = \"openid\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthResponse\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n */\nexport class SigninResponse {\n    // props present in the initial callback response regardless of success\n    public readonly state: string | null;\n    /** @see {@link User.session_state} */\n    public session_state: string | null;\n\n    // error props\n    /** @see {@link ErrorResponse.error} */\n    public readonly error: string | null;\n    /** @see {@link ErrorResponse.error_description} */\n    public readonly error_description: string | null;\n    /** @see {@link ErrorResponse.error_uri} */\n    public readonly error_uri: string | null;\n\n    // success props\n    public readonly code: string | null;\n\n    // props set after validation\n    /** @see {@link User.id_token} */\n    public id_token?: string;\n    /** @see {@link User.access_token} */\n    public access_token = \"\";\n    /** @see {@link User.token_type} */\n    public token_type = \"\";\n    /** @see {@link User.refresh_token} */\n    public refresh_token?: string;\n    /** @see {@link User.scope} */\n    public scope?: string;\n    /** @see {@link User.expires_at} */\n    public expires_at?: number;\n\n    /** custom state data set during the initial signin request */\n    public userState: unknown;\n    public url_state?: string;\n\n    /** @see {@link User.profile} */\n    public profile: UserProfile = {} as UserProfile;\n\n    public constructor(params: URLSearchParams) {\n        this.state = params.get(\"state\");\n        this.session_state = params.get(\"session_state\");\n        if (this.state) {\n            const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);\n            this.state = splitState[0];\n            if (splitState.length > 1) {\n                this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);\n            }\n        }\n\n        this.error = params.get(\"error\");\n        this.error_description = params.get(\"error_description\");\n        this.error_uri = params.get(\"error_uri\");\n\n        this.code = params.get(\"code\");\n    }\n\n    public get expires_in(): number | undefined {\n        if (this.expires_at === undefined) {\n            return undefined;\n        }\n        return this.expires_at - Timer.getEpochTime();\n    }\n    public set expires_in(value: number | undefined) {\n        // spec expects a number, but normalize here just in case\n        if (typeof value === \"string\") value = Number(value);\n        if (value !== undefined && value >= 0) {\n            this.expires_at = Math.floor(value) + Timer.getEpochTime();\n        }\n    }\n\n    public get isOpenId(): boolean {\n        return this.scope?.split(\" \").includes(OidcScope) || !!this.id_token;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, URL_STATE_DELIMITER } from \"./utils\";\nimport { State } from \"./State\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-rpinitiated-1_0.html#RPLogout\n */\nexport interface SignoutRequestArgs {\n    // mandatory\n    url: string;\n\n    // optional\n    id_token_hint?: string;\n    client_id?: string;\n    post_logout_redirect_uri?: string;\n    extraQueryParams?: Record<string, string | number | boolean>;\n\n    // special\n    request_type?: string;\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state_data?: unknown;\n    url_state?: string;\n}\n\n/**\n * @public\n */\nexport class SignoutRequest {\n    private readonly _logger = new Logger(\"SignoutRequest\");\n\n    public readonly url: string;\n    public readonly state?: State;\n\n    public constructor({\n        url,\n        state_data, id_token_hint, post_logout_redirect_uri, extraQueryParams, request_type, client_id, url_state,\n    }: SignoutRequestArgs) {\n        if (!url) {\n            this._logger.error(\"ctor: No url passed\");\n            throw new Error(\"url\");\n        }\n\n        const parsedUrl = new URL(url);\n        if (id_token_hint) {\n            parsedUrl.searchParams.append(\"id_token_hint\", id_token_hint);\n        }\n        if (client_id) {\n            parsedUrl.searchParams.append(\"client_id\", client_id);\n        }\n\n        if (post_logout_redirect_uri) {\n            parsedUrl.searchParams.append(\"post_logout_redirect_uri\", post_logout_redirect_uri);\n\n            // Add state if either data needs to be stored, or url_state set for an intermediate proxy\n            if (state_data || url_state) {\n                this.state = new State({ data: state_data, request_type, url_state });\n\n                let stateParam = this.state.id;\n                if (url_state) {\n                    stateParam = `${stateParam}${URL_STATE_DELIMITER}${url_state}`;\n                }\n                parsedUrl.searchParams.append(\"state\", stateParam);\n            }\n        }\n\n        for (const [key, value] of Object.entries({ ...extraQueryParams })) {\n            if (value != null) {\n                parsedUrl.searchParams.append(key, value.toString());\n            }\n        }\n\n        this.url = parsedUrl.href;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { URL_STATE_DELIMITER } from \"./utils\";\n\n/**\n * @public\n * @see https://openid.net/specs/openid-connect-core-1_0.html#AuthError\n */\nexport class SignoutResponse {\n    public readonly state: string | null;\n\n    // error props\n    /** @see {@link ErrorResponse.error} */\n    public error: string | null;\n    /** @see {@link ErrorResponse.error_description} */\n    public error_description: string | null;\n    /** @see {@link ErrorResponse.error_uri} */\n    public error_uri: string | null;\n\n    /** custom state data set during the initial signin request */\n    public userState: unknown;\n    public url_state?: string;\n\n    public constructor(params: URLSearchParams) {\n        this.state = params.get(\"state\");\n        if (this.state) {\n            const splitState = decodeURIComponent(this.state).split(URL_STATE_DELIMITER);\n            this.state = splitState[0];\n            if (splitState.length > 1) {\n                this.url_state = splitState.slice(1).join(URL_STATE_DELIMITER);\n            }\n        }\n\n        this.error = params.get(\"error\");\n        this.error_description = params.get(\"error_description\");\n        this.error_uri = params.get(\"error_uri\");\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport type { JwtClaims } from \"./Claims\";\nimport type { OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport type { UserProfile } from \"./User\";\nimport { Logger } from \"./utils\";\n\n/**\n * Protocol claims that could be removed by default from profile.\n * Derived from the following sets of claims:\n * - {@link https://datatracker.ietf.org/doc/html/rfc7519.html#section-4.1}\n * - {@link https://openid.net/specs/openid-connect-core-1_0.html#IDToken}\n * - {@link https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken}\n *\n * @internal\n */\nconst DefaultProtocolClaims = [\n    \"nbf\",\n    \"jti\",\n    \"auth_time\",\n    \"nonce\",\n    \"acr\",\n    \"amr\",\n    \"azp\",\n    \"at_hash\", // https://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken\n] as const;\n\n/**\n * Protocol claims that should never be removed from profile.\n * \"sub\" is needed internally and others should remain required as per the OIDC specs.\n *\n * @internal\n */\nconst InternalRequiredProtocolClaims = [\"sub\", \"iss\", \"aud\", \"exp\", \"iat\"];\n\n/**\n * @internal\n */\nexport class ClaimsService {\n    protected readonly _logger = new Logger(\"ClaimsService\");\n    public constructor(\n        protected readonly _settings: OidcClientSettingsStore,\n    ) {}\n\n    public filterProtocolClaims(claims: UserProfile): UserProfile {\n        const result = { ...claims };\n\n        if (this._settings.filterProtocolClaims) {\n            let protocolClaims;\n            if (Array.isArray(this._settings.filterProtocolClaims)) {\n                protocolClaims = this._settings.filterProtocolClaims;\n            } else {\n                protocolClaims = DefaultProtocolClaims;\n            }\n\n            for (const claim of protocolClaims) {\n                if (!InternalRequiredProtocolClaims.includes(claim)) {\n                    delete result[claim];\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public mergeClaims(claims1: JwtClaims, claims2: JwtClaims): UserProfile;\n    public mergeClaims(claims1: UserProfile, claims2: JwtClaims): UserProfile {\n        const result = { ...claims1 };\n        for (const [claim, values] of Object.entries(claims2)) {\n            if (result[claim] !== values) {\n                if (Array.isArray(result[claim]) || Array.isArray(values)) {\n                    if (this._settings.mergeClaimsStrategy.array == \"replace\") {\n                        result[claim] = values;\n                    } else {\n                        const mergedValues = Array.isArray(result[claim]) ? result[claim] as unknown[] : [result[claim]];\n                        for (const value of Array.isArray(values) ? values : [values]) {\n                            if (!mergedValues.includes(value)) {\n                                mergedValues.push(value);\n                            }\n                        }\n                        result[claim] = mergedValues;\n                    }\n                } else if (typeof result[claim] === \"object\" && typeof values === \"object\") {\n                    result[claim] = this.mergeClaims(result[claim] as JwtClaims, values as JwtClaims);\n                } else {\n                    result[claim] = values;\n                }\n            }\n        }\n\n        return result;\n    }\n}\n","/**\n * @public\n */\nexport interface DPoPStore {\n    set(key: string, value: DPoPState): Promise<void>;\n    get(key: string): Promise<DPoPState>;\n    remove(key: string): Promise<DPoPState>;\n    getAllKeys(): Promise<string[]>;\n}\n\n/**\n * @public\n */\nexport class DPoPState {\n    public constructor(\n        public readonly keys: CryptoKeyPair,\n        public nonce?: string,\n    ) { }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { CryptoUtils, Logger, UrlUtils } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport { type ExtraHeader, type OidcClientSettings, OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport { ResponseValidator } from \"./ResponseValidator\";\nimport { MetadataService } from \"./MetadataService\";\nimport type { RefreshState } from \"./RefreshState\";\nimport { SigninRequest, type SigninRequestCreateArgs } from \"./SigninRequest\";\nimport { SigninResponse } from \"./SigninResponse\";\nimport { SignoutRequest, type SignoutRequestArgs } from \"./SignoutRequest\";\nimport { SignoutResponse } from \"./SignoutResponse\";\nimport { SigninState } from \"./SigninState\";\nimport { State } from \"./State\";\nimport { TokenClient } from \"./TokenClient\";\nimport { ClaimsService } from \"./ClaimsService\";\nimport { DPoPState, type DPoPStore } from \"./DPoPStore\";\nimport { ErrorDPoPNonce } from \"./errors/ErrorDPoPNonce\";\n\n/**\n * @public\n */\nexport interface CreateSigninRequestArgs\n    extends Omit<SigninRequestCreateArgs, \"url\" | \"authority\" | \"client_id\" | \"redirect_uri\" | \"response_type\" | \"scope\" | \"state_data\"> {\n    redirect_uri?: string;\n    response_type?: string;\n    scope?: string;\n    dpopJkt?: string;\n\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state?: unknown;\n}\n\n/**\n * @public\n */\nexport interface UseRefreshTokenArgs {\n    redirect_uri?: string;\n    resource?: string | string[];\n    extraTokenParams?: Record<string, unknown>;\n    timeoutInSeconds?: number;\n\n    state: RefreshState;\n\n    extraHeaders?: Record<string, ExtraHeader>;\n}\n\n/**\n * @public\n */\nexport type CreateSignoutRequestArgs = Omit<SignoutRequestArgs, \"url\" | \"state_data\"> & {\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    state?: unknown;\n};\n\n/**\n * @public\n */\nexport type ProcessResourceOwnerPasswordCredentialsArgs = {\n    username: string;\n    password: string;\n    skipUserInfo?: boolean;\n    extraTokenParams?: Record<string, unknown>;\n};\n\n/**\n * Provides the raw OIDC/OAuth2 protocol support for the authorization endpoint and the end session endpoint in the\n * authorization server. It provides a bare-bones protocol implementation and is used by the UserManager class.\n * Only use this class if you simply want protocol support without the additional management features of the\n * UserManager class.\n *\n * @public\n */\nexport class OidcClient {\n    public readonly settings: OidcClientSettingsStore;\n    protected readonly _logger = new Logger(\"OidcClient\");\n\n    public readonly metadataService: MetadataService;\n    protected readonly _claimsService: ClaimsService;\n    protected readonly _validator: ResponseValidator;\n    protected readonly _tokenClient: TokenClient;\n\n    public constructor(settings: OidcClientSettings);\n    public constructor(settings: OidcClientSettingsStore, metadataService: MetadataService);\n    public constructor(settings: OidcClientSettings | OidcClientSettingsStore, metadataService?: MetadataService) {\n        this.settings = settings instanceof OidcClientSettingsStore ? settings : new OidcClientSettingsStore(settings);\n\n        this.metadataService = metadataService ?? new MetadataService(this.settings);\n        this._claimsService = new ClaimsService(this.settings);\n        this._validator = new ResponseValidator(this.settings, this.metadataService, this._claimsService);\n        this._tokenClient = new TokenClient(this.settings, this.metadataService);\n    }\n\n    public async createSigninRequest({\n        state,\n        request,\n        request_uri,\n        request_type,\n        id_token_hint,\n        login_hint,\n        skipUserInfo,\n        nonce,\n        url_state,\n        response_type = this.settings.response_type,\n        scope = this.settings.scope,\n        redirect_uri = this.settings.redirect_uri,\n        prompt = this.settings.prompt,\n        display = this.settings.display,\n        max_age = this.settings.max_age,\n        ui_locales = this.settings.ui_locales,\n        acr_values = this.settings.acr_values,\n        resource = this.settings.resource,\n        response_mode = this.settings.response_mode,\n        extraQueryParams = this.settings.extraQueryParams,\n        extraTokenParams = this.settings.extraTokenParams,\n        dpopJkt,\n        omitScopeWhenRequesting = this.settings.omitScopeWhenRequesting,\n    }: CreateSigninRequestArgs): Promise<SigninRequest> {\n        const logger = this._logger.create(\"createSigninRequest\");\n\n        if (response_type !== \"code\") {\n            throw new Error(\"Only the Authorization Code flow (with PKCE) is supported\");\n        }\n\n        const url = await this.metadataService.getAuthorizationEndpoint();\n        logger.debug(\"Received authorization endpoint\", url);\n\n        const signinRequest = await SigninRequest.create({\n            url,\n            authority: this.settings.authority,\n            client_id: this.settings.client_id,\n            redirect_uri,\n            response_type,\n            scope,\n            state_data: state,\n            url_state,\n            prompt, display, max_age, ui_locales, id_token_hint, login_hint, acr_values, dpopJkt,\n            resource, request, request_uri, extraQueryParams, extraTokenParams, request_type, response_mode,\n            client_secret: this.settings.client_secret,\n            skipUserInfo,\n            nonce,\n            disablePKCE: this.settings.disablePKCE,\n            omitScopeWhenRequesting,\n        });\n\n        // house cleaning\n        await this.clearStaleState();\n\n        const signinState = signinRequest.state;\n        await this.settings.stateStore.set(signinState.id, signinState.toStorageString());\n        return signinRequest;\n    }\n\n    public async readSigninResponseState(url: string, removeState = false): Promise<{ state: SigninState; response: SigninResponse }> {\n        const logger = this._logger.create(\"readSigninResponseState\");\n\n        const response = new SigninResponse(UrlUtils.readParams(url, this.settings.response_mode));\n        if (!response.state) {\n            logger.throw(new Error(\"No state in response\"));\n            // need to throw within this function's body for type narrowing to work\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n        if (!storedStateString) {\n            logger.throw(new Error(\"No matching state found in storage\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const state = await SigninState.fromStorageString(storedStateString);\n        return { state, response };\n    }\n\n    public async processSigninResponse(url: string, extraHeaders?: Record<string, ExtraHeader>, removeState = true): Promise<SigninResponse> {\n        const logger = this._logger.create(\"processSigninResponse\");\n\n        const { state, response } = await this.readSigninResponseState(url, removeState);\n        logger.debug(\"received state from storage; validating response\");\n\n        if (this.settings.dpop && this.settings.dpop.store) {\n            const dpopProof = await this.getDpopProof(this.settings.dpop.store);\n            extraHeaders = { ...extraHeaders, \"DPoP\": dpopProof };\n        }\n\n        /**\n         * The DPoP spec describes a method for Authorization Servers to supply a nonce value\n         * in order to limit the lifetime of a given DPoP proof.\n         * See https://datatracker.ietf.org/doc/html/rfc9449#name-authorization-server-provid\n         * This involves the AS returning a 400 bad request with a DPoP-Nonce header containing\n         * the nonce value. The client must then retry the request with a recomputed DPoP proof\n         * containing the supplied nonce value.\n         */\n        try {\n            await this._validator.validateSigninResponse(response, state, extraHeaders);\n        }\n        catch (err) {\n            if (err instanceof ErrorDPoPNonce && this.settings.dpop) {\n                const dpopProof = await this.getDpopProof(this.settings.dpop.store, err.nonce);\n                extraHeaders![\"DPoP\"] = dpopProof;\n                await this._validator.validateSigninResponse(response, state, extraHeaders);\n            } else {\n                throw err;\n            }\n        }\n\n        return response;\n    }\n\n    async getDpopProof(dpopStore: DPoPStore, nonce?: string): Promise<string> {\n        let keyPair: CryptoKeyPair;\n        let dpopState: DPoPState;\n\n        if (!(await dpopStore.getAllKeys()).includes(this.settings.client_id)) {\n            keyPair = await CryptoUtils.generateDPoPKeys();\n            dpopState = new DPoPState(keyPair, nonce);\n            await dpopStore.set(this.settings.client_id, dpopState);\n        } else {\n            dpopState = await dpopStore.get(this.settings.client_id);\n\n            // if the server supplied nonce has changed since the last request, update the nonce\n            if (dpopState.nonce !== nonce && nonce) {\n                dpopState.nonce = nonce;\n                await dpopStore.set(this.settings.client_id, dpopState);\n            }\n        }\n\n        return await CryptoUtils.generateDPoPProof({\n            url: await this.metadataService.getTokenEndpoint(false),\n            httpMethod: \"POST\",\n            keyPair: dpopState.keys,\n            nonce: dpopState.nonce,\n        });\n    }\n\n    public async processResourceOwnerPasswordCredentials({\n        username,\n        password,\n        skipUserInfo = false,\n        extraTokenParams = {},\n    }: ProcessResourceOwnerPasswordCredentialsArgs): Promise<SigninResponse> {\n        const tokenResponse: Record<string, unknown> = await this._tokenClient.exchangeCredentials({ username, password, ...extraTokenParams });\n        const signinResponse: SigninResponse = new SigninResponse(new URLSearchParams());\n        Object.assign(signinResponse, tokenResponse);\n        await this._validator.validateCredentialsResponse(signinResponse, skipUserInfo);\n        return signinResponse;\n    }\n\n    public async useRefreshToken({\n        state,\n        redirect_uri,\n        resource,\n        timeoutInSeconds,\n        extraHeaders,\n        extraTokenParams,\n    }: UseRefreshTokenArgs): Promise<SigninResponse> {\n        const logger = this._logger.create(\"useRefreshToken\");\n\n        // https://github.com/authts/oidc-client-ts/issues/695\n        // In some cases (e.g. AzureAD), not all granted scopes are allowed on token refresh requests.\n        // Therefore, we filter all granted scopes by a list of allowable scopes.\n        let scope;\n        if (this.settings.refreshTokenAllowedScope === undefined) {\n            scope = state.scope;\n        } else {\n            const allowableScopes = this.settings.refreshTokenAllowedScope.split(\" \");\n            const providedScopes = state.scope?.split(\" \") || [];\n\n            scope = providedScopes.filter(s => allowableScopes.includes(s)).join(\" \");\n        }\n\n        if (this.settings.dpop && this.settings.dpop.store) {\n            const dpopProof = await this.getDpopProof(this.settings.dpop.store);\n            extraHeaders = { ...extraHeaders, \"DPoP\": dpopProof };\n        }\n\n        /**\n         * The DPoP spec describes a method for Authorization Servers to supply a nonce value\n         * in order to limit the lifetime of a given DPoP proof.\n         * See https://datatracker.ietf.org/doc/html/rfc9449#name-authorization-server-provid\n         * This involves the AS returning a 400 bad request with a DPoP-Nonce header containing\n         * the nonce value. The client must then retry the request with a recomputed DPoP proof\n         * containing the supplied nonce value.\n         */\n        let result;\n        try {\n            result = await this._tokenClient.exchangeRefreshToken({\n                refresh_token: state.refresh_token,\n                // provide the (possible filtered) scope list\n                scope,\n                redirect_uri,\n                resource,\n                timeoutInSeconds,\n                extraHeaders,\n                ...extraTokenParams,\n            });\n        } catch (err) {\n            if (err instanceof ErrorDPoPNonce && this.settings.dpop) {\n                extraHeaders![\"DPoP\"] = await this.getDpopProof(this.settings.dpop.store, err.nonce);\n                result = await this._tokenClient.exchangeRefreshToken({\n                    refresh_token: state.refresh_token,\n                    // provide the (possible filtered) scope list\n                    scope,\n                    redirect_uri,\n                    resource,\n                    timeoutInSeconds,\n                    extraHeaders,\n                    ...extraTokenParams,\n                });\n            } else {\n                throw err;\n            }\n        }\n\n        const response = new SigninResponse(new URLSearchParams());\n        Object.assign(response, result);\n        logger.debug(\"validating response\", response);\n        await this._validator.validateRefreshResponse(response, {\n            ...state,\n            // override the scope in the state handed over to the validator\n            // so it can set the granted scope to the requested scope in case none is included in the response\n            scope,\n        });\n        return response;\n    }\n\n    public async createSignoutRequest({\n        state,\n        id_token_hint,\n        client_id,\n        request_type,\n        url_state,\n        post_logout_redirect_uri = this.settings.post_logout_redirect_uri,\n        extraQueryParams = this.settings.extraQueryParams,\n    }: CreateSignoutRequestArgs = {}): Promise<SignoutRequest> {\n        const logger = this._logger.create(\"createSignoutRequest\");\n\n        const url = await this.metadataService.getEndSessionEndpoint();\n        if (!url) {\n            logger.throw(new Error(\"No end session endpoint\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        logger.debug(\"Received end session endpoint\", url);\n\n        // specify the client identifier when post_logout_redirect_uri is used but id_token_hint is not\n        if (!client_id && post_logout_redirect_uri && !id_token_hint) {\n            client_id = this.settings.client_id;\n        }\n\n        const request = new SignoutRequest({\n            url,\n            id_token_hint,\n            client_id,\n            post_logout_redirect_uri,\n            state_data: state,\n            extraQueryParams,\n            request_type,\n            url_state,\n        });\n\n        // house cleaning\n        await this.clearStaleState();\n\n        const signoutState = request.state;\n        if (signoutState) {\n            logger.debug(\"Signout request has state to persist\");\n            await this.settings.stateStore.set(signoutState.id, signoutState.toStorageString());\n        }\n\n        return request;\n    }\n\n    public async readSignoutResponseState(url: string, removeState = false): Promise<{ state: State | undefined; response: SignoutResponse }> {\n        const logger = this._logger.create(\"readSignoutResponseState\");\n\n        const response = new SignoutResponse(UrlUtils.readParams(url, this.settings.response_mode));\n        if (!response.state) {\n            logger.debug(\"No state in response\");\n\n            if (response.error) {\n                logger.warn(\"Response was error:\", response.error);\n                throw new ErrorResponse(response);\n            }\n\n            return { state: undefined, response };\n        }\n\n        const storedStateString = await this.settings.stateStore[removeState ? \"remove\" : \"get\"](response.state);\n        if (!storedStateString) {\n            logger.throw(new Error(\"No matching state found in storage\"));\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw null; // https://github.com/microsoft/TypeScript/issues/46972\n        }\n\n        const state = await State.fromStorageString(storedStateString);\n        return { state, response };\n    }\n\n    public async processSignoutResponse(url: string): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"processSignoutResponse\");\n\n        const { state, response } = await this.readSignoutResponseState(url, true);\n        if (state) {\n            logger.debug(\"Received state from storage; validating response\");\n            this._validator.validateSignoutResponse(response, state);\n        } else {\n            logger.debug(\"No state from storage; skipping response validation\");\n        }\n\n        return response;\n    }\n\n    public clearStaleState(): Promise<void> {\n        this._logger.create(\"clearStaleState\");\n        return State.clearStaleState(this.settings.stateStore, this.settings.staleStateAgeInSeconds);\n    }\n\n    public async revokeToken(token: string, type?: \"access_token\" | \"refresh_token\"): Promise<void> {\n        this._logger.create(\"revokeToken\");\n        return await this._tokenClient.revoke({\n            token,\n            token_type_hint: type,\n        });\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"./utils\";\nimport { CheckSessionIFrame } from \"./CheckSessionIFrame\";\nimport type { UserManager } from \"./UserManager\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport class SessionMonitor {\n    private readonly _logger = new Logger(\"SessionMonitor\");\n\n    private _sub: string | undefined;\n    private _checkSessionIFrame?: CheckSessionIFrame;\n\n    public constructor(private readonly _userManager: UserManager) {\n        if (!_userManager) {\n            this._logger.throw(new Error(\"No user manager passed\"));\n        }\n\n        this._userManager.events.addUserLoaded(this._start);\n        this._userManager.events.addUserUnloaded(this._stop);\n\n        this._init().catch((err: unknown) => {\n            // catch to suppress errors since we're in a ctor\n            this._logger.error(err);\n        });\n    }\n\n    protected async _init(): Promise<void> {\n        this._logger.create(\"_init\");\n        const user = await this._userManager.getUser();\n        // doing this manually here since calling getUser\n        // doesn't trigger load event.\n        if (user) {\n            void this._start(user);\n        }\n        else if (this._userManager.settings.monitorAnonymousSession) {\n            const session = await this._userManager.querySessionStatus();\n            if (session) {\n                const tmpUser = {\n                    session_state: session.session_state,\n                    profile: session.sub ? {\n                        sub: session.sub,\n                    } : null,\n                };\n                void this._start(tmpUser);\n            }\n        }\n    }\n\n    protected _start = async (\n        user: User | {\n            session_state: string;\n            profile: { sub: string } | null;\n        },\n    ): Promise<void> => {\n        const session_state = user.session_state;\n        if (!session_state) {\n            return;\n        }\n        const logger = this._logger.create(\"_start\");\n\n        if (user.profile) {\n            this._sub = user.profile.sub;\n            logger.debug(\"session_state\", session_state, \", sub\", this._sub);\n        }\n        else {\n            this._sub = undefined;\n            logger.debug(\"session_state\", session_state, \", anonymous user\");\n        }\n\n        if (this._checkSessionIFrame) {\n            this._checkSessionIFrame.start(session_state);\n            return;\n        }\n\n        try {\n            const url = await this._userManager.metadataService.getCheckSessionIframe();\n            if (url) {\n                logger.debug(\"initializing check session iframe\");\n\n                const client_id = this._userManager.settings.client_id;\n                const intervalInSeconds = this._userManager.settings.checkSessionIntervalInSeconds;\n                const stopOnError = this._userManager.settings.stopCheckSessionOnError;\n\n                const checkSessionIFrame = new CheckSessionIFrame(this._callback, client_id, url, intervalInSeconds, stopOnError);\n                await checkSessionIFrame.load();\n                this._checkSessionIFrame = checkSessionIFrame;\n                checkSessionIFrame.start(session_state);\n            }\n            else {\n                logger.warn(\"no check session iframe found in the metadata\");\n            }\n        }\n        catch (err) {\n            // catch to suppress errors since we're in non-promise callback\n            logger.error(\"Error from getCheckSessionIframe:\", err instanceof Error ? err.message : err);\n        }\n    };\n\n    protected _stop = (): void => {\n        const logger = this._logger.create(\"_stop\");\n        this._sub = undefined;\n\n        if (this._checkSessionIFrame) {\n            this._checkSessionIFrame.stop();\n        }\n\n        if (this._userManager.settings.monitorAnonymousSession) {\n            // using a timer to delay re-initialization to avoid race conditions during signout\n            // TODO rewrite to use promise correctly\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            const timerHandle = setInterval(async () => {\n                clearInterval(timerHandle);\n\n                try {\n                    const session = await this._userManager.querySessionStatus();\n                    if (session) {\n                        const tmpUser = {\n                            session_state: session.session_state,\n                            profile: session.sub ? {\n                                sub: session.sub,\n                            } : null,\n                        };\n                        void this._start(tmpUser);\n                    }\n                }\n                catch (err) {\n                    // catch to suppress errors since we're in a callback\n                    logger.error(\"error from querySessionStatus\", err instanceof Error ? err.message : err);\n                }\n            }, 1000);\n        }\n    };\n\n    protected _callback = async (): Promise<void> => {\n        const logger = this._logger.create(\"_callback\");\n        try {\n            const session = await this._userManager.querySessionStatus();\n            let raiseEvent = true;\n\n            if (session && this._checkSessionIFrame) {\n                if (session.sub === this._sub) {\n                    raiseEvent = false;\n                    this._checkSessionIFrame.start(session.session_state);\n\n                    logger.debug(\"same sub still logged in at OP, session state has changed, restarting check session iframe; session_state\", session.session_state);\n                    await this._userManager.events._raiseUserSessionChanged();\n                }\n                else {\n                    logger.debug(\"different subject signed into OP\", session.sub);\n                }\n            }\n            else {\n                logger.debug(\"subject no longer signed into OP\");\n            }\n\n            if (raiseEvent) {\n                if (this._sub) {\n                    await this._userManager.events._raiseUserSignedOut();\n                }\n                else {\n                    await this._userManager.events._raiseUserSignedIn();\n                }\n            } else {\n                logger.debug(\"no change in session detected, no event to raise\");\n            }\n        }\n        catch (err) {\n            if (this._sub) {\n                logger.debug(\"Error calling queryCurrentSigninSession; raising signed out event\", err);\n                await this._userManager.events._raiseUserSignedOut();\n            }\n        }\n    };\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport type { IdTokenClaims } from \"./Claims\";\n\n/**\n * Holds claims represented by a combination of the `id_token` and the user info endpoint.\n *\n * @public\n */\nexport type UserProfile = IdTokenClaims;\n\n/**\n * @public\n */\nexport class User {\n    /**\n     * A JSON Web Token (JWT). Only provided if `openid` scope was requested.\n     * The application can access the data decoded by using the `profile` property.\n     */\n    public id_token?: string;\n\n    /** The session state value returned from the OIDC provider. */\n    public session_state: string | null;\n\n    /**\n     * The requested access token returned from the OIDC provider. The application can use this token to\n     * authenticate itself to the secured resource.\n     */\n    public access_token: string;\n\n    /**\n     * An OAuth 2.0 refresh token. The app can use this token to acquire additional access tokens after the\n     * current access token expires. Refresh tokens are long-lived and can be used to maintain access to resources\n     * for extended periods of time.\n     */\n    public refresh_token?: string;\n\n    /** Typically \"Bearer\" */\n    public token_type: string;\n\n    /** The scopes that the requested access token is valid for. */\n    public scope?: string;\n\n    /** The claims represented by a combination of the `id_token` and the user info endpoint. */\n    public profile: UserProfile;\n\n    /** The expires at returned from the OIDC provider. */\n    public expires_at?: number;\n\n    /** custom state data set during the initial signin request */\n    public readonly state: unknown;\n    public readonly url_state?: string;\n\n    public constructor(args: {\n        id_token?: string;\n        session_state?: string | null;\n        access_token: string;\n        refresh_token?: string;\n        token_type: string;\n        scope?: string;\n        profile: UserProfile;\n        expires_at?: number;\n        userState?: unknown;\n        url_state?: string;\n    }) {\n        this.id_token = args.id_token;\n        this.session_state = args.session_state ?? null;\n        this.access_token = args.access_token;\n        this.refresh_token = args.refresh_token;\n\n        this.token_type = args.token_type;\n        this.scope = args.scope;\n        this.profile = args.profile;\n        this.expires_at = args.expires_at;\n        this.state = args.userState;\n        this.url_state = args.url_state;\n    }\n\n    /** Computed number of seconds the access token has remaining. */\n    public get expires_in(): number | undefined {\n        if (this.expires_at === undefined) {\n            return undefined;\n        }\n        return this.expires_at - Timer.getEpochTime();\n    }\n\n    public set expires_in(value: number | undefined) {\n        if (value !== undefined) {\n            this.expires_at = Math.floor(value) + Timer.getEpochTime();\n        }\n    }\n\n    /** Computed value indicating if the access token is expired. */\n    public get expired(): boolean | undefined {\n        const expires_in = this.expires_in;\n        if (expires_in === undefined) {\n            return undefined;\n        }\n        return expires_in <= 0;\n    }\n\n    /** Array representing the parsed values from the `scope`. */\n    public get scopes(): string[] {\n        return this.scope?.split(\" \") ?? [];\n    }\n\n    public toStorageString(): string {\n        new Logger(\"User\").create(\"toStorageString\");\n        return JSON.stringify({\n            id_token: this.id_token,\n            session_state: this.session_state,\n            access_token: this.access_token,\n            refresh_token: this.refresh_token,\n            token_type: this.token_type,\n            scope: this.scope,\n            profile: this.profile,\n            expires_at: this.expires_at,\n        });\n    }\n\n    public static fromStorageString(storageString: string): User {\n        Logger.createStatic(\"User\", \"fromStorageString\");\n        return new User(JSON.parse(storageString));\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Event, Logger, UrlUtils } from \"../utils\";\nimport type { IWindow, NavigateParams, NavigateResponse } from \"./IWindow\";\n\nconst messageSource = \"oidc-client\";\n\ninterface MessageData {\n    source: string;\n    url: string;\n    keepOpen: boolean;\n}\n\n/**\n * Window implementation which resolves via communication from a child window\n * via the `Window.postMessage()` interface.\n *\n * @internal\n */\nexport abstract class AbstractChildWindow implements IWindow {\n    protected abstract readonly _logger: Logger;\n    protected readonly _abort = new Event<[reason: Error]>(\"Window navigation aborted\");\n    protected readonly _disposeHandlers = new Set<() => void>();\n\n    protected _window: WindowProxy | null = null;\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"navigate\");\n        if (!this._window) {\n            throw new Error(\"Attempted to navigate on a disposed window\");\n        }\n\n        logger.debug(\"setting URL in window\");\n        this._window.location.replace(params.url);\n\n        const { url, keepOpen } = await new Promise<MessageData>((resolve, reject) => {\n            const listener = (e: MessageEvent) => {\n                const data: MessageData | undefined = e.data;\n                const origin = params.scriptOrigin ?? window.location.origin;\n                if (e.origin !== origin || data?.source !== messageSource) {\n                    // silently discard events not intended for us\n                    return;\n                }\n                try {\n                    const state = UrlUtils.readParams(data.url, params.response_mode).get(\"state\");\n                    if (!state) {\n                        logger.warn(\"no state found in response url\");\n                    }\n                    if (e.source !== this._window && state !== params.state) {\n                        // MessageEvent source is a relatively modern feature, we can't rely on it\n                        // so we also inspect the payload for a matching state key as an alternative\n                        return;\n                    }\n                }\n                catch {\n                    this._dispose();\n                    reject(new Error(\"Invalid response from window\"));\n                }\n                resolve(data);\n            };\n            window.addEventListener(\"message\", listener, false);\n            this._disposeHandlers.add(() => window.removeEventListener(\"message\", listener, false));\n            const channel = new BroadcastChannel(`oidc-client-popup-${params.state}`);\n            channel.addEventListener(\"message\", listener, false);\n            this._disposeHandlers.add(() => channel.close());\n            this._disposeHandlers.add(this._abort.addHandler((reason) => {\n                this._dispose();\n                reject(reason);\n            }));\n        });\n        logger.debug(\"got response from window\");\n        this._dispose();\n\n        if (!keepOpen) {\n            this.close();\n        }\n\n        return { url };\n    }\n\n    public abstract close(): void;\n\n    private _dispose(): void {\n        this._logger.create(\"_dispose\");\n\n        for (const dispose of this._disposeHandlers) {\n            dispose();\n        }\n        this._disposeHandlers.clear();\n    }\n\n    protected static _notifyParent(parent: Window | null, url: string, keepOpen = false, targetOrigin = window.location.origin): void {\n        const msgData: MessageData = {\n            source: messageSource,\n            url,\n            keepOpen,\n        };\n        const logger = new Logger(\"_notifyParent\");\n        if (parent) {\n            logger.debug(\"With parent. Using parent.postMessage.\");\n            parent.postMessage(msgData, targetOrigin);\n        } else {\n            logger.debug(\"No parent. Using BroadcastChannel.\");\n            const state = new URL(url).searchParams.get(\"state\");\n            if (!state) {\n                throw new Error(\"No parent and no state in URL. Can't complete notification.\");\n            }\n            const channel = new BroadcastChannel(`oidc-client-popup-${state}`);\n            channel.postMessage(msgData);\n            channel.close();\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { type OidcClientSettings, OidcClientSettingsStore } from \"./OidcClientSettings\";\nimport type { PopupWindowFeatures } from \"./utils/PopupUtils\";\nimport { WebStorageStateStore } from \"./WebStorageStateStore\";\nimport { InMemoryWebStorage } from \"./InMemoryWebStorage\";\nimport type { StateStore } from \"./StateStore\";\n\nexport const DefaultPopupWindowFeatures: PopupWindowFeatures = {\n    location: false,\n    toolbar: false,\n    height: 640,\n    closePopupWindowAfterInSeconds: -1,\n};\nexport const DefaultPopupTarget = \"_blank\";\nconst DefaultAccessTokenExpiringNotificationTimeInSeconds = 60;\nconst DefaultCheckSessionIntervalInSeconds = 2;\nexport const DefaultSilentRequestTimeoutInSeconds = 10;\n\n/**\n * The settings used to configure the {@link UserManager}.\n *\n * @public\n */\nexport interface UserManagerSettings extends OidcClientSettings {\n    /** The URL for the page containing the call to signinPopupCallback to handle the callback from the OIDC/OAuth2 */\n    popup_redirect_uri?: string;\n    popup_post_logout_redirect_uri?: string;\n    /**\n     * The features parameter to window.open for the popup signin window. By default, the popup is\n     * placed centered in front of the window opener.\n     * (default: \\{ location: false, menubar: false, height: 640, closePopupWindowAfterInSeconds: -1 \\})\n     */\n    popupWindowFeatures?: PopupWindowFeatures;\n    /** The target parameter to window.open for the popup signin window (default: \"_blank\") */\n    popupWindowTarget?: string;\n    /** The methods window.location method used to redirect (default: \"assign\") */\n    redirectMethod?: \"replace\" | \"assign\";\n    /** The methods target window being redirected (default: \"self\") */\n    redirectTarget?: \"top\" | \"self\";\n\n    /** The target to pass while calling postMessage inside iframe for callback (default: window.location.origin) */\n    iframeNotifyParentOrigin?: string;\n\n    /** The script origin to check during 'message' callback execution while performing silent auth via iframe (default: window.location.origin) */\n    iframeScriptOrigin?: string;\n\n    /** The URL for the page containing the code handling the silent renew */\n    silent_redirect_uri?: string;\n    /** Number of seconds to wait for the silent renew to return before assuming it has failed or timed out (default: 10) */\n    silentRequestTimeoutInSeconds?: number;\n    /** Flag to indicate if there should be an automatic attempt to renew the access token prior to its expiration. The automatic renew attempt starts 1 minute before the access token expires (default: true) */\n    automaticSilentRenew?: boolean;\n    /** Flag to validate user.profile.sub in silent renew calls (default: true) */\n    validateSubOnSilentRenew?: boolean;\n    /** Flag to control if id_token is included as id_token_hint in silent renew calls (default: false) */\n    includeIdTokenInSilentRenew?: boolean;\n\n    /** Will raise events for when user has performed a signout at the OP (default: false) */\n    monitorSession?: boolean;\n    monitorAnonymousSession?: boolean;\n    /** Interval in seconds to check the user's session (default: 2) */\n    checkSessionIntervalInSeconds?: number;\n    query_status_response_type?: string;\n    stopCheckSessionOnError?: boolean;\n\n    /**\n     * The `token_type_hint`s to pass to the authority server by default (default: [\"access_token\", \"refresh_token\"])\n     *\n     * Token types will be revoked in the same order as they are given here.\n     */\n    revokeTokenTypes?: (\"access_token\" | \"refresh_token\")[];\n    /** Will invoke the revocation endpoint on signout if there is an access token for the user (default: false) */\n    revokeTokensOnSignout?: boolean;\n    /** Flag to control if id_token is included as id_token_hint in silent signout calls (default: false) */\n    includeIdTokenInSilentSignout?: boolean;\n\n    /** The number of seconds before an access token is to expire to raise the accessTokenExpiring event (default: 60) */\n    accessTokenExpiringNotificationTimeInSeconds?: number;\n\n    /**\n     * Storage object used to persist User for currently authenticated user (default: window.sessionStorage, InMemoryWebStorage iff no window).\n     *  E.g. `userStore: new WebStorageStateStore({ store: window.localStorage })`\n     */\n    userStore?: StateStore;\n}\n\n/**\n * The settings with defaults applied of the {@link UserManager}.\n * @see {@link UserManagerSettings}\n *\n * @public\n */\nexport class UserManagerSettingsStore extends OidcClientSettingsStore {\n    public readonly popup_redirect_uri: string;\n    public readonly popup_post_logout_redirect_uri: string | undefined;\n    public readonly popupWindowFeatures: PopupWindowFeatures;\n    public readonly popupWindowTarget: string;\n    public readonly redirectMethod: \"replace\" | \"assign\";\n    public readonly redirectTarget: \"top\" | \"self\";\n\n    public readonly iframeNotifyParentOrigin: string | undefined;\n    public readonly iframeScriptOrigin: string | undefined;\n\n    public readonly silent_redirect_uri: string;\n    public readonly silentRequestTimeoutInSeconds: number;\n    public readonly automaticSilentRenew: boolean;\n    public readonly validateSubOnSilentRenew: boolean;\n    public readonly includeIdTokenInSilentRenew: boolean;\n\n    public readonly monitorSession: boolean;\n    public readonly monitorAnonymousSession: boolean;\n    public readonly checkSessionIntervalInSeconds: number;\n    public readonly query_status_response_type: string;\n    public readonly stopCheckSessionOnError: boolean;\n\n    public readonly revokeTokenTypes: (\"access_token\" | \"refresh_token\")[];\n    public readonly revokeTokensOnSignout: boolean;\n    public readonly includeIdTokenInSilentSignout: boolean;\n\n    public readonly accessTokenExpiringNotificationTimeInSeconds: number;\n\n    public readonly userStore: StateStore;\n\n    public constructor(args: UserManagerSettings) {\n        const {\n            popup_redirect_uri = args.redirect_uri,\n            popup_post_logout_redirect_uri = args.post_logout_redirect_uri,\n            popupWindowFeatures = DefaultPopupWindowFeatures,\n            popupWindowTarget = DefaultPopupTarget,\n            redirectMethod = \"assign\",\n            redirectTarget = \"self\",\n\n            iframeNotifyParentOrigin = args.iframeNotifyParentOrigin,\n            iframeScriptOrigin = args.iframeScriptOrigin,\n\n            requestTimeoutInSeconds,\n            silent_redirect_uri = args.redirect_uri,\n            silentRequestTimeoutInSeconds,\n            automaticSilentRenew = true,\n            validateSubOnSilentRenew = true,\n            includeIdTokenInSilentRenew = false,\n\n            monitorSession = false,\n            monitorAnonymousSession = false,\n            checkSessionIntervalInSeconds = DefaultCheckSessionIntervalInSeconds,\n            query_status_response_type = \"code\",\n            stopCheckSessionOnError = true,\n\n            revokeTokenTypes = [\"access_token\", \"refresh_token\"],\n            revokeTokensOnSignout = false,\n            includeIdTokenInSilentSignout = false,\n\n            accessTokenExpiringNotificationTimeInSeconds = DefaultAccessTokenExpiringNotificationTimeInSeconds,\n\n            userStore,\n        } = args;\n\n        super(args);\n\n        this.popup_redirect_uri = popup_redirect_uri;\n        this.popup_post_logout_redirect_uri = popup_post_logout_redirect_uri;\n        this.popupWindowFeatures = popupWindowFeatures;\n        this.popupWindowTarget = popupWindowTarget;\n        this.redirectMethod = redirectMethod;\n        this.redirectTarget = redirectTarget;\n\n        this.iframeNotifyParentOrigin = iframeNotifyParentOrigin;\n        this.iframeScriptOrigin = iframeScriptOrigin;\n\n        this.silent_redirect_uri = silent_redirect_uri;\n        this.silentRequestTimeoutInSeconds = silentRequestTimeoutInSeconds || requestTimeoutInSeconds || DefaultSilentRequestTimeoutInSeconds;\n        this.automaticSilentRenew = automaticSilentRenew;\n        this.validateSubOnSilentRenew = validateSubOnSilentRenew;\n        this.includeIdTokenInSilentRenew = includeIdTokenInSilentRenew;\n\n        this.monitorSession = monitorSession;\n        this.monitorAnonymousSession = monitorAnonymousSession;\n        this.checkSessionIntervalInSeconds = checkSessionIntervalInSeconds;\n        this.stopCheckSessionOnError = stopCheckSessionOnError;\n        this.query_status_response_type = query_status_response_type;\n\n        this.revokeTokenTypes = revokeTokenTypes;\n        this.revokeTokensOnSignout = revokeTokensOnSignout;\n        this.includeIdTokenInSilentSignout = includeIdTokenInSilentSignout;\n\n        this.accessTokenExpiringNotificationTimeInSeconds = accessTokenExpiringNotificationTimeInSeconds;\n\n        if (userStore) {\n            this.userStore = userStore;\n        }\n        else {\n            const store = typeof window !== \"undefined\" ? window.sessionStorage : new InMemoryWebStorage();\n            this.userStore = new WebStorageStateStore({ store });\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport { ErrorTimeout } from \"../errors\";\nimport type { NavigateParams, NavigateResponse } from \"./IWindow\";\nimport { AbstractChildWindow } from \"./AbstractChildWindow\";\nimport { DefaultSilentRequestTimeoutInSeconds } from \"../UserManagerSettings\";\n\n/**\n * @public\n */\nexport interface IFrameWindowParams {\n    silentRequestTimeoutInSeconds?: number;\n}\n\n/**\n * @internal\n */\nexport class IFrameWindow extends AbstractChildWindow {\n    protected readonly _logger = new Logger(\"IFrameWindow\");\n    private _frame: HTMLIFrameElement | null;\n    private _timeoutInSeconds: number;\n\n    public constructor({\n        silentRequestTimeoutInSeconds = DefaultSilentRequestTimeoutInSeconds,\n    }: IFrameWindowParams) {\n        super();\n        this._timeoutInSeconds = silentRequestTimeoutInSeconds;\n\n        this._frame = IFrameWindow.createHiddenIframe();\n        this._window = this._frame.contentWindow;\n    }\n\n    private static createHiddenIframe(): HTMLIFrameElement {\n        const iframe = window.document.createElement(\"iframe\");\n\n        // shotgun approach\n        iframe.style.visibility = \"hidden\";\n        iframe.style.position = \"fixed\";\n        iframe.style.left = \"-1000px\";\n        iframe.style.top = \"0\";\n        iframe.width = \"0\";\n        iframe.height = \"0\";\n\n        window.document.body.appendChild(iframe);\n        return iframe;\n    }\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        this._logger.debug(\"navigate: Using timeout of:\", this._timeoutInSeconds);\n        const timer = setTimeout(() => void this._abort.raise(new ErrorTimeout(\"IFrame timed out without a response\")), this._timeoutInSeconds * 1000);\n        this._disposeHandlers.add(() => clearTimeout(timer));\n\n        return await super.navigate(params);\n    }\n\n    public close(): void {\n        if (this._frame) {\n            if (this._frame.parentNode) {\n                this._frame.addEventListener(\"load\", (ev) => {\n                    const frame = ev.target as HTMLIFrameElement;\n                    frame.parentNode?.removeChild(frame);\n                    void this._abort.raise(new Error(\"IFrame removed from DOM\"));\n                }, true);\n                this._frame.contentWindow?.location.replace(\"about:blank\");\n            }\n            this._frame = null;\n        }\n        this._window = null;\n    }\n\n    public static notifyParent(url: string, targetOrigin?: string): void {\n        return super._notifyParent(window.parent, url, false, targetOrigin);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\nimport { IFrameWindow, type IFrameWindowParams } from \"./IFrameWindow\";\nimport type { INavigator } from \"./INavigator\";\n\n/**\n * @internal\n */\nexport class IFrameNavigator implements INavigator {\n    private readonly _logger = new Logger(\"IFrameNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) {}\n\n    public async prepare({\n        silentRequestTimeoutInSeconds = this._settings.silentRequestTimeoutInSeconds,\n    }: IFrameWindowParams): Promise<IFrameWindow> {\n        return new IFrameWindow({ silentRequestTimeoutInSeconds });\n    }\n\n    public async callback(url: string): Promise<void> {\n        this._logger.create(\"callback\");\n        IFrameWindow.notifyParent(url, this._settings.iframeNotifyParentOrigin);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, PopupUtils, type PopupWindowFeatures } from \"../utils\";\nimport { DefaultPopupWindowFeatures, DefaultPopupTarget } from \"../UserManagerSettings\";\nimport { AbstractChildWindow } from \"./AbstractChildWindow\";\nimport type { NavigateParams, NavigateResponse } from \"./IWindow\";\n\nconst checkForPopupClosedInterval = 500;\nconst second = 1000;\n\n/**\n * @public\n */\nexport interface PopupWindowParams {\n    popupWindowFeatures?: PopupWindowFeatures;\n    popupWindowTarget?: string;\n    /** An AbortSignal to set request's signal. */\n    popupSignal?: AbortSignal | null;\n    /** Abort navigator when the popup is lost */\n    popupAbortOnClose?: boolean;\n}\n\n/**\n * @internal\n */\nexport class PopupWindow extends AbstractChildWindow {\n    protected readonly _logger = new Logger(\"PopupWindow\");\n\n    protected _window: WindowProxy | null;\n\n    protected abortOnClose: boolean;\n\n    public constructor({\n        popupWindowTarget = DefaultPopupTarget,\n        popupWindowFeatures = {},\n        popupSignal,\n        popupAbortOnClose,\n    }: PopupWindowParams) {\n        super();\n        const centeredPopup = PopupUtils.center({ ...DefaultPopupWindowFeatures, ...popupWindowFeatures });\n        this._window = window.open(undefined, popupWindowTarget, PopupUtils.serialize(centeredPopup));\n        this.abortOnClose = Boolean(popupAbortOnClose);\n\n        if (popupSignal) {\n            popupSignal.addEventListener(\"abort\", () => {\n                void this._abort.raise(new Error(popupSignal.reason ?? \"Popup aborted\"));\n            });\n        }\n\n        if (popupWindowFeatures.closePopupWindowAfterInSeconds && popupWindowFeatures.closePopupWindowAfterInSeconds > 0) {\n            setTimeout(() => {\n                if (!this._window || typeof this._window.closed !== \"boolean\" || this._window.closed) {\n                    void this._abort.raise(new Error(\"Popup blocked by user\"));\n                    return;\n                }\n\n                this.close();\n            }, popupWindowFeatures.closePopupWindowAfterInSeconds * second);\n        }\n    }\n\n    public async navigate(params: NavigateParams): Promise<NavigateResponse> {\n        this._window?.focus();\n\n        const popupClosedInterval = setInterval(() => {\n            if (!this._window || this._window.closed) {\n                this._logger.debug(\"Popup closed by user or isolated by redirect\");\n                clearPopupClosedInterval();\n                this._disposeHandlers.delete(clearPopupClosedInterval);\n                \n                if (this.abortOnClose) {\n                    void this._abort.raise(new Error(\"Popup closed by user\"));\n                }\n            }\n        }, checkForPopupClosedInterval);\n        const clearPopupClosedInterval = () => clearInterval(popupClosedInterval);\n        this._disposeHandlers.add(clearPopupClosedInterval);\n\n        return await super.navigate(params);\n    }\n\n    public close(): void {\n        if (this._window) {\n            if (!this._window.closed) {\n                this._window.close();\n                void this._abort.raise(new Error(\"Popup closed\"));\n            }\n        }\n        this._window = null;\n    }\n\n    public static notifyOpener(url: string, keepOpen: boolean): void {\n        super._notifyParent(window.opener, url, keepOpen);\n        if (!keepOpen && !window.opener) {\n            window.close();\n        }\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport { PopupWindow, type PopupWindowParams } from \"./PopupWindow\";\nimport type { INavigator } from \"./INavigator\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\n\n/**\n * @internal\n */\nexport class PopupNavigator implements INavigator {\n    private readonly _logger = new Logger(\"PopupNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) { }\n\n    public async prepare({\n        popupWindowFeatures = this._settings.popupWindowFeatures,\n        popupWindowTarget = this._settings.popupWindowTarget,\n        popupSignal,\n        popupAbortOnClose,\n    }: PopupWindowParams): Promise<PopupWindow> {\n        return new PopupWindow({\n            popupWindowFeatures,\n            popupWindowTarget,\n            popupSignal,\n            popupAbortOnClose,\n        });\n    }\n\n    public async callback(url: string, { keepOpen = false }): Promise<void> {\n        this._logger.create(\"callback\");\n\n        PopupWindow.notifyOpener(url, keepOpen);\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger } from \"../utils\";\nimport type { UserManagerSettingsStore } from \"../UserManagerSettings\";\nimport type { INavigator } from \"./INavigator\";\nimport type { IWindow, NavigateResponse } from \"./IWindow\";\n\n/**\n * @public\n */\nexport interface RedirectParams {\n    redirectMethod?: \"replace\" | \"assign\";\n    redirectTarget?: \"top\" | \"self\";\n}\n\n/**\n * @internal\n */\nexport class RedirectNavigator implements INavigator {\n    private readonly _logger = new Logger(\"RedirectNavigator\");\n\n    constructor(private _settings: UserManagerSettingsStore) {}\n\n    public async prepare({\n        redirectMethod = this._settings.redirectMethod,\n        redirectTarget = this._settings.redirectTarget,\n    }: RedirectParams): Promise<IWindow> {\n        this._logger.create(\"prepare\");\n        let targetWindow = window.self as Window;\n\n        if (redirectTarget === \"top\") {\n            targetWindow = window.top ?? window.self;\n        }\n    \n        const redirect = targetWindow.location[redirectMethod].bind(targetWindow.location) as (url: string) => void;\n        let abort: (reason: Error) => void;\n        return {\n            navigate: async (params): Promise<NavigateResponse> => {\n                this._logger.create(\"navigate\");\n                const promise = new Promise((resolve, reject) => {\n                    abort = reject;\n                    window.addEventListener(\"pageshow\", () => resolve(window.location.href));\n                    redirect(params.url);\n                });\n                return await (promise as Promise<NavigateResponse>);\n            },\n            close: () => {\n                this._logger.create(\"close\");\n                abort?.(new Error(\"Redirect aborted\"));\n                targetWindow.stop();\n            },\n        };\n    }\n\n    public async callback(): Promise<void> {\n        return;\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Event } from \"./utils\";\nimport { AccessTokenEvents } from \"./AccessTokenEvents\";\nimport type { UserManagerSettingsStore } from \"./UserManagerSettings\";\nimport type { User } from \"./User\";\n\n/**\n * @public\n */\nexport type UserLoadedCallback = (user: User) => Promise<void> | void;\n/**\n * @public\n */\nexport type UserUnloadedCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type SilentRenewErrorCallback = (error: Error) => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSignedInCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSignedOutCallback = () => Promise<void> | void;\n/**\n * @public\n */\nexport type UserSessionChangedCallback = () => Promise<void> | void;\n\n/**\n * @public\n */\nexport class UserManagerEvents extends AccessTokenEvents {\n    protected readonly _logger = new Logger(\"UserManagerEvents\");\n\n    private readonly _userLoaded = new Event<[User]>(\"User loaded\");\n    private readonly _userUnloaded = new Event<[]>(\"User unloaded\");\n    private readonly _silentRenewError = new Event<[Error]>(\"Silent renew error\");\n    private readonly _userSignedIn = new Event<[]>(\"User signed in\");\n    private readonly _userSignedOut = new Event<[]>(\"User signed out\");\n    private readonly _userSessionChanged = new Event<[]>(\"User session changed\");\n\n    public constructor(settings: UserManagerSettingsStore) {\n        super({ expiringNotificationTimeInSeconds: settings.accessTokenExpiringNotificationTimeInSeconds });\n    }\n\n    public async load(user: User, raiseEvent=true): Promise<void> {\n        await super.load(user);\n        if (raiseEvent) {\n            await this._userLoaded.raise(user);\n        }\n    }\n\n    public async unload(): Promise<void> {\n        await super.unload();\n        await this._userUnloaded.raise();\n    }\n\n    /**\n     * Add callback: Raised when a user session has been established (or re-established).\n     */\n    public addUserLoaded(cb: UserLoadedCallback): () => void {\n        return this._userLoaded.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when a user session has been established (or re-established).\n     */\n    public removeUserLoaded(cb: UserLoadedCallback): void {\n        return this._userLoaded.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised when a user session has been terminated.\n     */\n    public addUserUnloaded(cb: UserUnloadedCallback): () => void {\n        return this._userUnloaded.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when a user session has been terminated.\n     */\n    public removeUserUnloaded(cb: UserUnloadedCallback): void {\n        return this._userUnloaded.removeHandler(cb);\n    }\n\n    /**\n     * Add callback: Raised when the automatic silent renew has failed.\n     */\n    public addSilentRenewError(cb: SilentRenewErrorCallback): () => void {\n        return this._silentRenewError.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the automatic silent renew has failed.\n     */\n    public removeSilentRenewError(cb: SilentRenewErrorCallback): void {\n        return this._silentRenewError.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public async _raiseSilentRenewError(e: Error): Promise<void> {\n        await this._silentRenewError.raise(e);\n    }\n\n    /**\n     * Add callback: Raised when the user is signed in (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSignedIn(cb: UserSignedInCallback): () => void {\n        return this._userSignedIn.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user is signed in (when `monitorSession` is set).\n     */\n    public removeUserSignedIn(cb: UserSignedInCallback): void {\n        this._userSignedIn.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public async _raiseUserSignedIn(): Promise<void> {\n        await this._userSignedIn.raise();\n    }\n\n    /**\n     * Add callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSignedOut(cb: UserSignedOutCallback): () => void {\n        return this._userSignedOut.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user's sign-in status at the OP has changed (when `monitorSession` is set).\n     */\n    public removeUserSignedOut(cb: UserSignedOutCallback): void {\n        this._userSignedOut.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public async _raiseUserSignedOut(): Promise<void> {\n        await this._userSignedOut.raise();\n    }\n\n    /**\n     * Add callback: Raised when the user session changed (when `monitorSession` is set).\n     * @see {@link UserManagerSettings.monitorSession}\n     */\n    public addUserSessionChanged(cb: UserSessionChangedCallback): () => void {\n        return this._userSessionChanged.addHandler(cb);\n    }\n    /**\n     * Remove callback: Raised when the user session changed (when `monitorSession` is set).\n     */\n    public removeUserSessionChanged(cb: UserSessionChangedCallback): void {\n        this._userSessionChanged.removeHandler(cb);\n    }\n    /**\n     * @internal\n     */\n    public async _raiseUserSessionChanged(): Promise<void> {\n        await this._userSessionChanged.raise();\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { Logger, Timer } from \"./utils\";\nimport { ErrorTimeout } from \"./errors\";\nimport type { UserManager } from \"./UserManager\";\nimport type { AccessTokenCallback } from \"./AccessTokenEvents\";\n\n/**\n * @internal\n */\nexport class SilentRenewService {\n    protected _logger = new Logger(\"SilentRenewService\");\n    private _isStarted = false;\n    private readonly _retryTimer = new Timer(\"Retry Silent Renew\");\n\n    public constructor(private _userManager: UserManager) {}\n\n    public async start(): Promise<void> {\n        const logger = this._logger.create(\"start\");\n        if (!this._isStarted) {\n            this._isStarted = true;\n            this._userManager.events.addAccessTokenExpiring(this._tokenExpiring);\n            this._retryTimer.addHandler(this._tokenExpiring);\n\n            // this will trigger loading of the user so the expiring events can be initialized\n            try {\n                await this._userManager.getUser();\n                // deliberate nop\n            }\n            catch (err) {\n                // catch to suppress errors since we're in a ctor\n                logger.error(\"getUser error\", err);\n            }\n        }\n    }\n\n    public stop(): void {\n        if (this._isStarted) {\n            this._retryTimer.cancel();\n            this._retryTimer.removeHandler(this._tokenExpiring);\n            this._userManager.events.removeAccessTokenExpiring(this._tokenExpiring);\n            this._isStarted = false;\n        }\n    }\n\n    protected _tokenExpiring: AccessTokenCallback = async () => {\n        const logger = this._logger.create(\"_tokenExpiring\");\n        try {\n            await this._userManager.signinSilent();\n            logger.debug(\"silent token renewal successful\");\n        }\n        catch (err) {\n            if (err instanceof ErrorTimeout) {\n                // no response from authority server, e.g. IFrame timeout, ...\n                logger.warn(\"ErrorTimeout from signinSilent:\", err, \"retry in 5s\");\n                this._retryTimer.init(5);\n                return;\n            }\n\n            logger.error(\"Error from signinSilent:\", err);\n            await this._userManager.events._raiseSilentRenewError(err as Error);\n        }\n    };\n}\n","// Copyright (C) AuthTS Contributors\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport type { UserProfile } from \"./User\";\n\n/**\n * Fake state store implementation necessary for validating refresh token requests.\n *\n * @public\n */\nexport class RefreshState {\n    /** custom \"state\", which can be used by a caller to have \"data\" round tripped */\n    public readonly data?: unknown;\n\n    public readonly refresh_token: string;\n    public readonly id_token?: string;\n    public readonly session_state: string | null;\n    public readonly scope?: string;\n    public readonly profile: UserProfile;\n\n    constructor(args: {\n        refresh_token: string;\n        id_token?: string;\n        session_state: string | null;\n        scope?: string;\n        profile: UserProfile;\n\n        state?: unknown;\n    }) {\n        this.refresh_token = args.refresh_token;\n        this.id_token = args.id_token;\n        this.session_state = args.session_state;\n        this.scope = args.scope;\n        this.profile = args.profile;\n\n        this.data = args.state;\n\n    }\n}\n","// Copyright (c) Brock Allen & Dominick Baier. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See LICENSE in the project root for license information.\n\nimport { CryptoUtils, Logger } from \"./utils\";\nimport { ErrorResponse } from \"./errors\";\nimport { type NavigateResponse, type PopupWindowParams, type IWindow, type IFrameWindowParams, type RedirectParams, RedirectNavigator, PopupNavigator, IFrameNavigator, type INavigator } from \"./navigators\";\nimport { OidcClient, type CreateSigninRequestArgs, type CreateSignoutRequestArgs, type ProcessResourceOwnerPasswordCredentialsArgs, type UseRefreshTokenArgs } from \"./OidcClient\";\nimport { type UserManagerSettings, UserManagerSettingsStore } from \"./UserManagerSettings\";\nimport { User } from \"./User\";\nimport { UserManagerEvents } from \"./UserManagerEvents\";\nimport { SilentRenewService } from \"./SilentRenewService\";\nimport { SessionMonitor } from \"./SessionMonitor\";\nimport type { SessionStatus } from \"./SessionStatus\";\nimport type { SignoutResponse } from \"./SignoutResponse\";\nimport type { MetadataService } from \"./MetadataService\";\nimport { RefreshState } from \"./RefreshState\";\nimport type { SigninResponse } from \"./SigninResponse\";\nimport type { ExtraHeader, DPoPSettings } from \"./OidcClientSettings\";\nimport { DPoPState } from \"./DPoPStore\";\n\n/**\n * @public\n */\nexport type ExtraSigninRequestArgs = Pick<CreateSigninRequestArgs, \"nonce\" | \"extraQueryParams\" | \"extraTokenParams\" | \"state\" | \"redirect_uri\" | \"prompt\" | \"acr_values\" | \"login_hint\" | \"scope\" | \"max_age\" | \"ui_locales\" | \"resource\" | \"url_state\">;\n/**\n * @public\n */\nexport type ExtraSignoutRequestArgs = Pick<CreateSignoutRequestArgs, \"extraQueryParams\" | \"state\" | \"id_token_hint\" | \"post_logout_redirect_uri\" | \"url_state\">;\n\n/**\n * @public\n */\nexport type RevokeTokensTypes = UserManagerSettings[\"revokeTokenTypes\"];\n\n/**\n * @public\n */\nexport type SigninRedirectArgs = RedirectParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SigninPopupArgs = PopupWindowParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type ExtraSignInSilentArgs = { \n    // forceIframeAuth bypasses refresh token usage and forces iframe-based silent authentication\n    forceIframeAuth?: boolean;\n};\n\n/**\n * @public\n */\nexport type SigninSilentArgs = IFrameWindowParams & ExtraSigninRequestArgs & ExtraSignInSilentArgs;\n\n/**\n * @public\n */\nexport type SigninResourceOwnerCredentialsArgs = ProcessResourceOwnerPasswordCredentialsArgs;\n\n/**\n * @public\n */\nexport type QuerySessionStatusArgs = IFrameWindowParams & ExtraSigninRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutRedirectArgs = RedirectParams & ExtraSignoutRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutPopupArgs = PopupWindowParams & ExtraSignoutRequestArgs;\n\n/**\n * @public\n */\nexport type SignoutSilentArgs = IFrameWindowParams & ExtraSignoutRequestArgs;\n\n/**\n * Provides a higher level API for signing a user in, signing out, managing the user's claims returned from the identity provider,\n * and managing an access token returned from the identity provider (OAuth2/OIDC).\n *\n * @public\n */\nexport class UserManager {\n    /** Get the settings used to configure the `UserManager`. */\n    public readonly settings: UserManagerSettingsStore;\n    protected readonly _logger = new Logger(\"UserManager\");\n\n    protected readonly _client: OidcClient;\n    protected readonly _redirectNavigator: INavigator;\n    protected readonly _popupNavigator: INavigator;\n    protected readonly _iframeNavigator: INavigator;\n    protected readonly _events: UserManagerEvents;\n    protected readonly _silentRenewService: SilentRenewService;\n    protected readonly _sessionMonitor: SessionMonitor | null;\n\n    public constructor(settings: UserManagerSettings, redirectNavigator?: INavigator, popupNavigator?: INavigator, iframeNavigator?: INavigator) {\n        this.settings = new UserManagerSettingsStore(settings);\n\n        this._client = new OidcClient(settings);\n\n        this._redirectNavigator = redirectNavigator ?? new RedirectNavigator(this.settings);\n        this._popupNavigator = popupNavigator ?? new PopupNavigator(this.settings);\n        this._iframeNavigator = iframeNavigator ?? new IFrameNavigator(this.settings);\n\n        this._events = new UserManagerEvents(this.settings);\n        this._silentRenewService = new SilentRenewService(this);\n\n        // order is important for the following properties; these services depend upon the events.\n        if (this.settings.automaticSilentRenew) {\n            this.startSilentRenew();\n        }\n\n        this._sessionMonitor = null;\n        if (this.settings.monitorSession) {\n            this._sessionMonitor = new SessionMonitor(this);\n        }\n    }\n\n    /**\n     * Get object used to register for events raised by the `UserManager`.\n     */\n    public get events(): UserManagerEvents {\n        return this._events;\n    }\n\n    /**\n     * Get object used to access the metadata configuration of the identity provider.\n     */\n    public get metadataService(): MetadataService {\n        return this._client.metadataService;\n    }\n\n    /**\n     * Load the `User` object for the currently authenticated user.\n     *\n     * @param raiseEvent - If `true`, the `UserLoaded` event will be raised. Defaults to false.\n     * @returns A promise\n     */\n    public async getUser(raiseEvent = false): Promise<User | null> {\n        const logger = this._logger.create(\"getUser\");\n        const user = await this._loadUser();\n        if (user) {\n            logger.info(\"user loaded\");\n            await this._events.load(user, raiseEvent);\n            return user;\n        }\n\n        logger.info(\"user not found in storage\");\n        return null;\n    }\n\n    /**\n     * Remove from any storage the currently authenticated user.\n     *\n     * @returns A promise\n     */\n    public async removeUser(): Promise<void> {\n        const logger = this._logger.create(\"removeUser\");\n        await this.storeUser(null);\n        logger.info(\"user removed from storage\");\n        await this._events.unload();\n    }\n\n    /**\n     * Trigger a redirect of the current window to the authorization endpoint.\n     *\n     * @returns A promise\n     *\n     * @throws `Error` In cases of wrong authentication.\n     */\n    public async signinRedirect(args: SigninRedirectArgs = {}): Promise<void> {\n        this._logger.create(\"signinRedirect\");\n        const {\n            redirectMethod,\n            ...requestArgs\n        } = args;\n\n        let dpopJkt: string | undefined;\n        if (this.settings.dpop?.bind_authorization_code) {\n            dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n        }\n\n        const handle = await this._redirectNavigator.prepare({ redirectMethod });\n        await this._signinStart({\n            request_type: \"si:r\",\n            dpopJkt,\n            ...requestArgs,\n        }, handle);\n    }\n\n    /**\n     * Process the response (callback) from the authorization endpoint.\n     * It is recommended to use {@link UserManager.signinCallback} instead.\n     *\n     * @returns A promise containing the authenticated `User`.\n     *\n     * @see {@link UserManager.signinCallback}\n     */\n    public async signinRedirectCallback(url = window.location.href): Promise<User> {\n        const logger = this._logger.create(\"signinRedirectCallback\");\n        const user = await this._signinEnd(url);\n        if (user.profile && user.profile.sub) {\n            logger.info(\"success, signed in subject\", user.profile.sub);\n        }\n        else {\n            logger.info(\"no subject\");\n        }\n\n        return user;\n    }\n\n    /**\n     * Trigger the signin with user/password.\n     *\n     * @returns A promise containing the authenticated `User`.\n     * @throws {@link ErrorResponse} In cases of wrong authentication.\n     */\n    public async signinResourceOwnerCredentials({\n        username,\n        password,\n        skipUserInfo = false,\n    }: SigninResourceOwnerCredentialsArgs): Promise<User> {\n        const logger = this._logger.create(\"signinResourceOwnerCredential\");\n\n        const signinResponse = await this._client.processResourceOwnerPasswordCredentials({\n            username,\n            password,\n            skipUserInfo,\n            extraTokenParams: this.settings.extraTokenParams,\n        });\n        logger.debug(\"got signin response\");\n\n        const user = await this._buildUser(signinResponse);\n        if (user.profile && user.profile.sub) {\n            logger.info(\"success, signed in subject\", user.profile.sub);\n        } else {\n            logger.info(\"no subject\");\n        }\n        return user;\n    }\n\n    /**\n     * Trigger a request (via a popup window) to the authorization endpoint.\n     *\n     * @returns A promise containing the authenticated `User`.\n     * @throws `Error` In cases of wrong authentication.\n     */\n    public async signinPopup(args: SigninPopupArgs = {}): Promise<User> {\n        const logger = this._logger.create(\"signinPopup\");\n\n        let dpopJkt: string | undefined;\n        if (this.settings.dpop?.bind_authorization_code) {\n            dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n        }\n\n        const {\n            popupWindowFeatures,\n            popupWindowTarget,\n            popupSignal,\n            popupAbortOnClose,\n            ...requestArgs\n        } = args;\n        const url = this.settings.popup_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No popup_redirect_uri configured\"));\n        }\n\n        const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget, popupSignal, popupAbortOnClose });\n        const user = await this._signin({\n            request_type: \"si:p\",\n            redirect_uri: url,\n            display: \"popup\",\n            dpopJkt,\n            ...requestArgs,\n        }, handle);\n        if (user) {\n            if (user.profile && user.profile.sub) {\n                logger.info(\"success, signed in subject\", user.profile.sub);\n            } else {\n                logger.info(\"no subject\");\n            }\n        }\n\n        return user;\n    }\n\n    /**\n     * Notify the opening window of response (callback) from the authorization endpoint.\n     * It is recommended to use {@link UserManager.signinCallback} instead.\n     *\n     * @returns A promise\n     *\n     * @see {@link UserManager.signinCallback}\n     */\n    public async signinPopupCallback(url = window.location.href, keepOpen = false): Promise<void> {\n        const logger = this._logger.create(\"signinPopupCallback\");\n        await this._popupNavigator.callback(url, { keepOpen });\n        logger.info(\"success\");\n    }\n\n    /**\n     * Trigger a silent request (via refresh token or an iframe) to the authorization endpoint.\n     *\n     * @returns A promise that contains the authenticated `User`.\n     */\n    public async signinSilent(args: SigninSilentArgs = {}): Promise<User | null> {\n        const logger = this._logger.create(\"signinSilent\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n        // first determine if we have a refresh token, or need to use iframe\n        let user = await this._loadUser();\n        // use refresh token unless forceIframeAuth is explicitly true\n        if (!args.forceIframeAuth && user?.refresh_token) {\n            logger.debug(\"using refresh token\");\n            const state = new RefreshState(user as Required<User>);\n            return await this._useRefreshToken({\n                state,\n                redirect_uri: requestArgs.redirect_uri,\n                resource: requestArgs.resource,\n                extraTokenParams: requestArgs.extraTokenParams,\n                timeoutInSeconds: silentRequestTimeoutInSeconds,\n            });\n        }\n\n        let dpopJkt: string | undefined;\n        if (this.settings.dpop?.bind_authorization_code) {\n            dpopJkt = await this.generateDPoPJkt(this.settings.dpop);\n        }\n\n        const url = this.settings.silent_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No silent_redirect_uri configured\"));\n        }\n\n        let verifySub: string | undefined;\n        if (user && this.settings.validateSubOnSilentRenew) {\n            logger.debug(\"subject prior to silent renew:\", user.profile.sub);\n            verifySub = user.profile.sub;\n        }\n\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        user = await this._signin({\n            request_type: \"si:s\",\n            redirect_uri: url,\n            prompt: \"none\",\n            id_token_hint: this.settings.includeIdTokenInSilentRenew ? user?.id_token : undefined,\n            dpopJkt,\n            ...requestArgs,\n        }, handle, verifySub);\n        if (user) {\n            if (user.profile?.sub) {\n                logger.info(\"success, signed in subject\", user.profile.sub);\n            }\n            else {\n                logger.info(\"no subject\");\n            }\n        }\n\n        return user;\n    }\n\n    protected async _useRefreshToken(args: UseRefreshTokenArgs): Promise<User> {\n        const response = await this._client.useRefreshToken({\n            timeoutInSeconds: this.settings.silentRequestTimeoutInSeconds,\n            ...args,\n        });\n        const user = new User({ ...args.state, ...response });\n\n        await this.storeUser(user);\n        await this._events.load(user);\n        return user;\n    }\n\n    /**\n     *\n     * Notify the parent window of response (callback) from the authorization endpoint.\n     * It is recommended to use {@link UserManager.signinCallback} instead.\n     *\n     * @returns A promise\n     *\n     * @see {@link UserManager.signinCallback}\n     */\n    public async signinSilentCallback(url = window.location.href): Promise<void> {\n        const logger = this._logger.create(\"signinSilentCallback\");\n        await this._iframeNavigator.callback(url);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Process any response (callback) from the authorization endpoint, by dispatching the request_type\n     * and executing one of the following functions:\n     * - {@link UserManager.signinRedirectCallback}\n     * - {@link UserManager.signinPopupCallback}\n     * - {@link UserManager.signinSilentCallback}\n     *\n     * @throws `Error` If request_type is unknown or signin cannot be processed.\n     */\n    public async signinCallback(url = window.location.href): Promise<User | undefined> {\n        const { state } = await this._client.readSigninResponseState(url);\n        switch (state.request_type) {\n            case \"si:r\":\n                return await this.signinRedirectCallback(url);\n            case \"si:p\":\n                await this.signinPopupCallback(url);\n                break;\n            case \"si:s\":\n                await this.signinSilentCallback(url);\n                break;\n            default:\n                throw new Error(\"invalid response_type in state\");\n        }\n        return undefined;\n    }\n\n    /**\n     * Process any response (callback) from the end session endpoint, by dispatching the request_type\n     * and executing one of the following functions:\n     * - {@link UserManager.signoutRedirectCallback}\n     * - {@link UserManager.signoutPopupCallback}\n     * - {@link UserManager.signoutSilentCallback}\n     *\n     * @throws `Error` If request_type is unknown or signout cannot be processed.\n     */\n    public async signoutCallback(url = window.location.href, keepOpen = false): Promise<SignoutResponse | undefined> {\n        const { state } = await this._client.readSignoutResponseState(url);\n        if (!state) {\n            return undefined;\n        }\n\n        switch (state.request_type) {\n            case \"so:r\":\n                return await this.signoutRedirectCallback(url);\n            case \"so:p\":\n                await this.signoutPopupCallback(url, keepOpen);\n                break;\n            case \"so:s\":\n                await this.signoutSilentCallback(url);\n                break;\n            default:\n                throw new Error(\"invalid response_type in state\");\n        }\n        return undefined;\n    }\n\n    /**\n     * Query OP for user's current signin status.\n     *\n     * @returns A promise object with session_state and subject identifier.\n     */\n    public async querySessionStatus(args: QuerySessionStatusArgs = {}): Promise<SessionStatus | null> {\n        const logger = this._logger.create(\"querySessionStatus\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n        const url = this.settings.silent_redirect_uri;\n        if (!url) {\n            logger.throw(new Error(\"No silent_redirect_uri configured\"));\n        }\n\n        const user = await this._loadUser();\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        const navResponse = await this._signinStart({\n            request_type: \"si:s\", // this acts like a signin silent\n            redirect_uri: url,\n            prompt: \"none\",\n            id_token_hint: this.settings.includeIdTokenInSilentRenew ? user?.id_token : undefined,\n            response_type: this.settings.query_status_response_type,\n            scope: \"openid\",\n            skipUserInfo: true,\n            ...requestArgs,\n        }, handle);\n        try {\n            const extraHeaders: Record<string, ExtraHeader> = {};\n            const signinResponse = await this._client.processSigninResponse(navResponse.url, extraHeaders);\n            logger.debug(\"got signin response\");\n\n            if (signinResponse.session_state && signinResponse.profile.sub) {\n                logger.info(\"success for subject\", signinResponse.profile.sub);\n                return {\n                    session_state: signinResponse.session_state,\n                    sub: signinResponse.profile.sub,\n                };\n            }\n\n            logger.info(\"success, user not authenticated\");\n            return null;\n        } catch (err) {\n            if (this.settings.monitorAnonymousSession && err instanceof ErrorResponse) {\n                switch (err.error) {\n                    case \"login_required\":\n                    case \"consent_required\":\n                    case \"interaction_required\":\n                    case \"account_selection_required\":\n                        logger.info(\"success for anonymous user\");\n                        return {\n                            session_state: err.session_state!,\n                        };\n                }\n            }\n            throw err;\n        }\n    }\n\n    protected async _signin(args: CreateSigninRequestArgs, handle: IWindow, verifySub?: string): Promise<User> {\n        const navResponse = await this._signinStart(args, handle);\n        return await this._signinEnd(navResponse.url, verifySub);\n    }\n\n    protected async _signinStart(args: CreateSigninRequestArgs, handle: IWindow): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"_signinStart\");\n\n        try {\n            const signinRequest = await this._client.createSigninRequest(args);\n            logger.debug(\"got signin request\");\n\n            return await handle.navigate({\n                url: signinRequest.url,\n                state: signinRequest.state.id,\n                response_mode: signinRequest.state.response_mode,\n                scriptOrigin: this.settings.iframeScriptOrigin,\n            });\n        } catch (err) {\n            logger.debug(\"error after preparing navigator, closing navigator window\");\n            handle.close();\n            throw err;\n        }\n    }\n\n    protected async _signinEnd(url: string, verifySub?: string): Promise<User> {\n        const logger = this._logger.create(\"_signinEnd\");\n        const extraHeaders: Record<string, ExtraHeader> = {};\n        const signinResponse = await this._client.processSigninResponse(url, extraHeaders);\n        logger.debug(\"got signin response\");\n\n        const user = await this._buildUser(signinResponse, verifySub);\n        return user;\n    }\n\n    protected async _buildUser(signinResponse: SigninResponse, verifySub?: string) {\n        const logger = this._logger.create(\"_buildUser\");\n        const user = new User(signinResponse);\n        if (verifySub) {\n            if (verifySub !== user.profile.sub) {\n                logger.debug(\"current user does not match user returned from signin. sub from signin:\", user.profile.sub);\n                throw new ErrorResponse({ ...signinResponse, error: \"login_required\" });\n            }\n            logger.debug(\"current user matches user returned from signin\");\n        }\n\n        await this.storeUser(user);\n        logger.debug(\"user stored\");\n        await this._events.load(user);\n\n        return user;\n    }\n\n    /**\n     * Trigger a redirect of the current window to the end session endpoint.\n     *\n     * @returns A promise\n     */\n    public async signoutRedirect(args: SignoutRedirectArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutRedirect\");\n        const {\n            redirectMethod,\n            ...requestArgs\n        } = args;\n        const handle = await this._redirectNavigator.prepare({ redirectMethod });\n        await this._signoutStart({\n            request_type: \"so:r\",\n            post_logout_redirect_uri: this.settings.post_logout_redirect_uri,\n            ...requestArgs,\n        }, handle);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Process response (callback) from the end session endpoint.\n     * It is recommended to use {@link UserManager.signoutCallback} instead.\n     *\n     * @returns A promise containing signout response\n     *\n     * @see {@link UserManager.signoutCallback}\n     */\n    public async signoutRedirectCallback(url = window.location.href): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"signoutRedirectCallback\");\n        const response = await this._signoutEnd(url);\n        logger.info(\"success\");\n        return response;\n    }\n\n    /**\n     * Trigger a redirect of a popup window to the end session endpoint.\n     *\n     * @returns A promise\n     */\n    public async signoutPopup(args: SignoutPopupArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutPopup\");\n        const {\n            popupWindowFeatures,\n            popupWindowTarget,\n            popupSignal,\n            ...requestArgs\n        } = args;\n        const url = this.settings.popup_post_logout_redirect_uri;\n\n        const handle = await this._popupNavigator.prepare({ popupWindowFeatures, popupWindowTarget, popupSignal });\n        await this._signout({\n            request_type: \"so:p\",\n            post_logout_redirect_uri: url,\n            // we're putting a dummy entry in here because we\n            // need a unique id from the state for notification\n            // to the parent window, which is necessary if we\n            // plan to return back to the client after signout\n            // and so we can close the popup after signout\n            state: url == null ? undefined : {},\n            ...requestArgs,\n        }, handle);\n        logger.info(\"success\");\n    }\n\n    /**\n     * Process response (callback) from the end session endpoint from a popup window.\n     * It is recommended to use {@link UserManager.signoutCallback} instead.\n     *\n     * @returns A promise\n     *\n     * @see {@link UserManager.signoutCallback}\n     */\n    public async signoutPopupCallback(url = window.location.href, keepOpen = false): Promise<void> {\n        const logger = this._logger.create(\"signoutPopupCallback\");\n        await this._popupNavigator.callback(url, { keepOpen });\n        logger.info(\"success\");\n    }\n\n    protected async _signout(args: CreateSignoutRequestArgs, handle: IWindow): Promise<SignoutResponse> {\n        const navResponse = await this._signoutStart(args, handle);\n        return await this._signoutEnd(navResponse.url);\n    }\n\n    protected async _signoutStart(args: CreateSignoutRequestArgs = {}, handle: IWindow): Promise<NavigateResponse> {\n        const logger = this._logger.create(\"_signoutStart\");\n\n        try {\n            const user = await this._loadUser();\n            logger.debug(\"loaded current user from storage\");\n\n            if (this.settings.revokeTokensOnSignout) {\n                await this._revokeInternal(user);\n            }\n\n            const id_token = args.id_token_hint || user && user.id_token;\n            if (id_token) {\n                logger.debug(\"setting id_token_hint in signout request\");\n                args.id_token_hint = id_token;\n            }\n\n            await this.removeUser();\n            logger.debug(\"user removed, creating signout request\");\n\n            const signoutRequest = await this._client.createSignoutRequest(args);\n            logger.debug(\"got signout request\");\n\n            return await handle.navigate({\n                url: signoutRequest.url,\n                state: signoutRequest.state?.id,\n                scriptOrigin: this.settings.iframeScriptOrigin,\n            });\n        } catch (err) {\n            logger.debug(\"error after preparing navigator, closing navigator window\");\n            handle.close();\n            throw err;\n        }\n    }\n\n    protected async _signoutEnd(url: string): Promise<SignoutResponse> {\n        const logger = this._logger.create(\"_signoutEnd\");\n        const signoutResponse = await this._client.processSignoutResponse(url);\n        logger.debug(\"got signout response\");\n\n        return signoutResponse;\n    }\n\n    /**\n     * Trigger a silent request (via an iframe) to the end session endpoint.\n     *\n     * @returns A promise\n     */\n    public async signoutSilent(args: SignoutSilentArgs = {}): Promise<void> {\n        const logger = this._logger.create(\"signoutSilent\");\n        const {\n            silentRequestTimeoutInSeconds,\n            ...requestArgs\n        } = args;\n\n        const id_token_hint = this.settings.includeIdTokenInSilentSignout\n            ? (await this._loadUser())?.id_token\n            : undefined;\n\n        const url = this.settings.popup_post_logout_redirect_uri;\n        const handle = await this._iframeNavigator.prepare({ silentRequestTimeoutInSeconds });\n        await this._signout({\n            request_type: \"so:s\",\n            post_logout_redirect_uri: url,\n            id_token_hint: id_token_hint,\n            ...requestArgs,\n        }, handle);\n\n        logger.info(\"success\");\n    }\n\n    /**\n     * Notify the parent window of response (callback) from the end session endpoint.\n     * It is recommended to use {@link UserManager.signoutCallback} instead.\n     *\n     * @returns A promise\n     *\n     * @see {@link UserManager.signoutCallback}\n     */\n    public async signoutSilentCallback(url = window.location.href): Promise<void> {\n        const logger = this._logger.create(\"signoutSilentCallback\");\n        await this._iframeNavigator.callback(url);\n        logger.info(\"success\");\n    }\n\n    public async revokeTokens(types?: RevokeTokensTypes): Promise<void> {\n        const user = await this._loadUser();\n        await this._revokeInternal(user, types);\n    }\n\n    protected async _revokeInternal(user: User | null, types = this.settings.revokeTokenTypes): Promise<void> {\n        const logger = this._logger.create(\"_revokeInternal\");\n        if (!user) return;\n\n        const typesPresent = types.filter(type => typeof user[type] === \"string\");\n\n        if (!typesPresent.length) {\n            logger.debug(\"no need to revoke due to no token(s)\");\n            return;\n        }\n\n        // don't Promise.all, order matters\n        for (const type of typesPresent) {\n            await this._client.revokeToken(\n                user[type]!,\n                type,\n            );\n            logger.info(`${type} revoked successfully`);\n            if (type !== \"access_token\") {\n                user[type] = null as never;\n            }\n        }\n\n        await this.storeUser(user);\n        logger.debug(\"user stored\");\n        await this._events.load(user);\n    }\n\n    /**\n     * Enables silent renew for the `UserManager`.\n     */\n    public startSilentRenew(): void {\n        this._logger.create(\"startSilentRenew\");\n        void this._silentRenewService.start();\n    }\n\n    /**\n     * Disables silent renew for the `UserManager`.\n     */\n    public stopSilentRenew(): void {\n        this._silentRenewService.stop();\n    }\n\n    protected get _userStoreKey(): string {\n        return `user:${this.settings.authority}:${this.settings.client_id}`;\n    }\n\n    protected async _loadUser(): Promise<User | null> {\n        const logger = this._logger.create(\"_loadUser\");\n        const storageString = await this.settings.userStore.get(this._userStoreKey);\n        if (storageString) {\n            logger.debug(\"user storageString loaded\");\n            return User.fromStorageString(storageString);\n        }\n\n        logger.debug(\"no user storageString\");\n        return null;\n    }\n\n    public async storeUser(user: User | null): Promise<void> {\n        const logger = this._logger.create(\"storeUser\");\n        if (user) {\n            logger.debug(\"storing user\");\n            const storageString = user.toStorageString();\n            await this.settings.userStore.set(this._userStoreKey, storageString);\n        } else {\n            this._logger.debug(\"removing user\");\n            await this.settings.userStore.remove(this._userStoreKey);\n            if (this.settings.dpop) {\n                await this.settings.dpop.store.remove(this.settings.client_id);\n            }\n        }\n    }\n\n    /**\n     * Removes stale state entries in storage for incomplete authorize requests.\n     */\n    public async clearStaleState(): Promise<void> {\n        await this._client.clearStaleState();\n    }\n\n    /**\n     * Dynamically generates a DPoP proof for a given user, URL and optional Http method.\n     * This method is useful when you need to make a request to a resource server\n     * with fetch or similar, and you need to include a DPoP proof in a DPoP header.\n     * @param url - The URL to generate the DPoP proof for\n     * @param user - The user to generate the DPoP proof for\n     * @param httpMethod - Optional, defaults to \"GET\"\n     * @param nonce - Optional nonce provided by the resource server\n     *\n     * @returns A promise containing the DPoP proof or undefined if DPoP is not enabled/no user is found.\n     */\n    public async dpopProof(url: string, user: User, httpMethod?: string, nonce?: string): Promise<string | undefined> {\n        const dpopState = await this.settings.dpop?.store?.get(this.settings.client_id);\n        if (dpopState) {\n            return await CryptoUtils.generateDPoPProof({\n                url,\n                accessToken: user?.access_token,\n                httpMethod: httpMethod,\n                keyPair: dpopState.keys,\n                nonce,\n            });\n        }\n        return undefined;\n    }\n\n    async generateDPoPJkt(dpopSettings: DPoPSettings): Promise<string | undefined> {\n        let dpopState = await dpopSettings.store.get(this.settings.client_id);\n        if (!dpopState) {\n            const dpopKeys = await CryptoUtils.generateDPoPKeys();\n            dpopState = new DPoPState(dpopKeys);\n            await dpopSettings.store.set(this.settings.client_id, dpopState);\n        }\n        return await CryptoUtils.generateDPoPJkt(dpopState.keys);\n    }\n}\n","{\n  \"name\": \"oidc-client-ts\",\n  \"version\": \"3.4.1\",\n  \"description\": \"OpenID Connect (OIDC) & OAuth2 client library\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/authts/oidc-client-ts.git\"\n  },\n  \"homepage\": \"https://github.com/authts/oidc-client-ts#readme\",\n  \"license\": \"Apache-2.0\",\n  \"main\": \"dist/umd/oidc-client-ts.js\",\n  \"types\": \"dist/types/oidc-client-ts.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/types/oidc-client-ts.d.ts\",\n      \"import\": \"./dist/esm/oidc-client-ts.js\",\n      \"require\": \"./dist/umd/oidc-client-ts.js\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"files\": [\n    \"dist\"\n  ],\n  \"keywords\": [\n    \"authentication\",\n    \"oauth2\",\n    \"oidc\",\n    \"openid\",\n    \"OpenID Connect\"\n  ],\n  \"scripts\": {\n    \"build\": \"node scripts/build.js && npm run build-types\",\n    \"build-types\": \"tsc -p tsconfig.build.json && api-extractor run\",\n    \"clean\": \"git clean -fdX dist lib *.tsbuildinfo\",\n    \"prepack\": \"npm run build\",\n    \"test\": \"tsc && jest\",\n    \"typedoc\": \"typedoc\",\n    \"lint\": \"eslint --max-warnings=0 --cache .\",\n    \"prepare\": \"husky\"\n  },\n  \"dependencies\": {\n    \"jwt-decode\": \"^4.0.0\"\n  },\n  \"devDependencies\": {\n    \"@eslint/eslintrc\": \"^3.2.0\",\n    \"@eslint/js\": \"^9.18.0\",\n    \"@microsoft/api-extractor\": \"^7.49.1\",\n    \"@stylistic/eslint-plugin\": \"^2.13.0\",\n    \"@testing-library/jest-dom\": \"^6.6.3\",\n    \"@types/jest\": \"^29.5.14\",\n    \"@types/node\": \"^24.10.1\",\n    \"@typescript-eslint/eslint-plugin\": \"^8.20.0\",\n    \"@typescript-eslint/parser\": \"^8.20.0\",\n    \"esbuild\": \"^0.27.0\",\n    \"eslint\": \"^9.18.0\",\n    \"eslint-plugin-testing-library\": \"^7.1.1\",\n    \"fake-indexeddb\": \"^6.0.0\",\n    \"globals\": \"^16.0.0\",\n    \"http-proxy-middleware\": \"^3.0.3\",\n    \"husky\": \"^9.1.7\",\n    \"jest\": \"^29.7.0\",\n    \"jest-environment-jsdom\": \"^29.7.0\",\n    \"jest-mock\": \"^29.7.0\",\n    \"jose\": \"^5.9.6\",\n    \"lint-staged\": \"^16.1.0\",\n    \"ts-jest\": \"^29.2.5\",\n    \"typedoc\": \"^0.28.0\",\n    \"typescript\": \"~5.8.2\",\n    \"yn\": \"^5.0.0\"\n  },\n  \"engines\": {\n    \"node\": \">=18\"\n  },\n  \"lint-staged\": {\n    \"*.{js,jsx,ts,tsx}\": \"eslint --cache --fix\"\n  }\n}\n","// @ts-expect-error avoid enabling resolveJsonModule to keep build process simple\nimport { version } from \"../package.json\";\n\n/**\n * @public\n */\nexport const Version: string = version;\n","import { DPoPState, type DPoPStore } from \"./DPoPStore\";\n\n/**\n * Provides a default implementation of the DPoP store using IndexedDB.\n *\n * @public\n */\nexport class IndexedDbDPoPStore implements DPoPStore {\n    readonly _dbName: string = \"oidc\";\n    readonly _storeName: string = \"dpop\";\n\n    public async set(key: string, value: DPoPState): Promise<void> {\n        const store = await this.createStore(this._dbName, this._storeName);\n        await store(\"readwrite\", (str: IDBObjectStore) => {\n            str.put(value, key);\n            return this.promisifyRequest(str.transaction);\n        });\n    }\n\n    public async get(key: string): Promise<DPoPState> {\n        const store = await this.createStore(this._dbName, this._storeName);\n        return await store(\"readonly\", (str) => {\n            return this.promisifyRequest(str.get(key));\n        }) as DPoPState;\n    }\n\n    public async remove(key: string): Promise<DPoPState> {\n        const item = await this.get(key);\n        const store = await this.createStore(this._dbName, this._storeName);\n        await store(\"readwrite\", (str) => {\n            return this.promisifyRequest(str.delete(key));\n        });\n        return item;\n    }\n\n    public async getAllKeys(): Promise<string[]> {\n        const store = await this.createStore(this._dbName, this._storeName);\n        return await store(\"readonly\", (str) => {\n            return this.promisifyRequest(str.getAllKeys());\n        }) as string[];\n    }\n\n    promisifyRequest<T = undefined>(\n        request: IDBRequest<T> | IDBTransaction): Promise<T> {\n        return new Promise<T>((resolve, reject) => {\n            (request as IDBTransaction).oncomplete = (request as IDBRequest<T>).onsuccess = () => resolve((request as IDBRequest<T>).result);\n            (request as IDBTransaction).onabort = (request as IDBRequest<T>).onerror = () => reject((request as IDBRequest<T>).error as Error);\n        });\n    }\n\n    async createStore<T>(\n        dbName: string,\n        storeName: string,\n    ): Promise<(txMode: IDBTransactionMode, callback: (store: IDBObjectStore) => T | PromiseLike<T>) => Promise<T>> {\n        const request = indexedDB.open(dbName);\n        request.onupgradeneeded = () => request.result.createObjectStore(storeName);\n        const db = await this.promisifyRequest<IDBDatabase>(request);\n\n        return async (\n            txMode: IDBTransactionMode,\n            callback: (store: IDBObjectStore) => T | PromiseLike<T>,\n        ) => {\n            const tx = db.transaction(storeName, txMode);\n            const store = tx.objectStore(storeName);\n            return await callback(store);\n        };\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
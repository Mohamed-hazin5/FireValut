{"ast":null,"code":"// src/AuthContext.ts\nimport React from \"react\";\nvar AuthContext = React.createContext(void 0);\nAuthContext.displayName = \"AuthContext\";\n\n// src/AuthProvider.tsx\nimport { UserManager } from \"oidc-client-ts\";\nimport React2 from \"react\";\n\n// src/AuthState.ts\nvar initialAuthState = {\n  isLoading: true,\n  isAuthenticated: false\n};\n\n// src/reducer.ts\nvar reducer = (state, action) => {\n  switch (action.type) {\n    case \"INITIALISED\":\n    case \"USER_LOADED\":\n      return {\n        ...state,\n        user: action.user,\n        isLoading: false,\n        isAuthenticated: action.user ? !action.user.expired : false,\n        error: void 0\n      };\n    case \"USER_SIGNED_OUT\":\n    case \"USER_UNLOADED\":\n      return {\n        ...state,\n        user: void 0,\n        isAuthenticated: false\n      };\n    case \"NAVIGATOR_INIT\":\n      return {\n        ...state,\n        isLoading: true,\n        activeNavigator: action.method\n      };\n    case \"NAVIGATOR_CLOSE\":\n      return {\n        ...state,\n        isLoading: false,\n        activeNavigator: void 0\n      };\n    case \"ERROR\":\n      {\n        const error = action.error;\n        error[\"toString\"] = () => `${error.name}: ${error.message}`;\n        return {\n          ...state,\n          isLoading: false,\n          error\n        };\n      }\n    default:\n      {\n        const innerError = new TypeError(`unknown type ${action[\"type\"]}`);\n        const error = {\n          name: innerError.name,\n          message: innerError.message,\n          innerError,\n          stack: innerError.stack,\n          source: \"unknown\"\n        };\n        error[\"toString\"] = () => `${error.name}: ${error.message}`;\n        return {\n          ...state,\n          isLoading: false,\n          error\n        };\n      }\n  }\n};\n\n// src/utils.ts\nvar hasAuthParams = (location = window.location) => {\n  let searchParams = new URLSearchParams(location.search);\n  if ((searchParams.get(\"code\") || searchParams.get(\"error\")) && searchParams.get(\"state\")) {\n    return true;\n  }\n  searchParams = new URLSearchParams(location.hash.replace(\"#\", \"?\"));\n  if ((searchParams.get(\"code\") || searchParams.get(\"error\")) && searchParams.get(\"state\")) {\n    return true;\n  }\n  return false;\n};\nvar signinError = normalizeErrorFn(\"signinCallback\", \"Sign-in failed\");\nvar signoutError = normalizeErrorFn(\"signoutCallback\", \"Sign-out failed\");\nvar renewSilentError = normalizeErrorFn(\"renewSilent\", \"Renew silent failed\");\nfunction normalizeError(error, fallbackMessage) {\n  return {\n    name: stringFieldOf(error, \"name\", () => \"Error\"),\n    message: stringFieldOf(error, \"message\", () => fallbackMessage),\n    stack: stringFieldOf(error, \"stack\", () => new Error().stack),\n    innerError: error\n  };\n}\nfunction normalizeErrorFn(source, fallbackMessage) {\n  return error => {\n    return {\n      ...normalizeError(error, fallbackMessage),\n      source\n    };\n  };\n}\nfunction stringFieldOf(element, fieldName, or) {\n  if (element && typeof element === \"object\") {\n    const value = element[fieldName];\n    if (typeof value === \"string\") {\n      return value;\n    }\n  }\n  return or();\n}\n\n// src/AuthProvider.tsx\nvar userManagerContextKeys = [\"clearStaleState\", \"querySessionStatus\", \"revokeTokens\", \"startSilentRenew\", \"stopSilentRenew\"];\nvar navigatorKeys = [\"signinPopup\", \"signinSilent\", \"signinRedirect\", \"signinResourceOwnerCredentials\", \"signoutPopup\", \"signoutRedirect\", \"signoutSilent\"];\nvar unsupportedEnvironment = fnName => () => {\n  throw new Error(`UserManager#${fnName} was called from an unsupported context. If this is a server-rendered page, defer this call with useEffect() or pass a custom UserManager implementation.`);\n};\nvar UserManagerImpl = typeof window === \"undefined\" ? null : UserManager;\nvar AuthProvider = props => {\n  const {\n    children,\n    onSigninCallback,\n    skipSigninCallback,\n    matchSignoutCallback,\n    onSignoutCallback,\n    onRemoveUser,\n    userManager: userManagerProp = null,\n    ...userManagerSettings\n  } = props;\n  const [userManager] = React2.useState(() => {\n    return userManagerProp != null ? userManagerProp : UserManagerImpl ? new UserManagerImpl(userManagerSettings) : {\n      settings: userManagerSettings\n    };\n  });\n  const [state, dispatch] = React2.useReducer(reducer, initialAuthState);\n  const userManagerContext = React2.useMemo(() => Object.assign({\n    settings: userManager.settings,\n    events: userManager.events\n  }, Object.fromEntries(userManagerContextKeys.map(key => {\n    var _a, _b;\n    return [key, (_b = (_a = userManager[key]) == null ? void 0 : _a.bind(userManager)) != null ? _b : unsupportedEnvironment(key)];\n  })), Object.fromEntries(navigatorKeys.map(key => [key, userManager[key] ? async args => {\n    dispatch({\n      type: \"NAVIGATOR_INIT\",\n      method: key\n    });\n    try {\n      return await userManager[key](args);\n    } catch (error) {\n      dispatch({\n        type: \"ERROR\",\n        error: {\n          ...normalizeError(error, `Unknown error while executing ${key}(...).`),\n          source: key,\n          args\n        }\n      });\n      return null;\n    } finally {\n      dispatch({\n        type: \"NAVIGATOR_CLOSE\"\n      });\n    }\n  } : unsupportedEnvironment(key)]))), [userManager]);\n  const didInitialize = React2.useRef(false);\n  React2.useEffect(() => {\n    if (!userManager || didInitialize.current) {\n      return;\n    }\n    didInitialize.current = true;\n    void (async () => {\n      try {\n        let user = null;\n        if (hasAuthParams() && !skipSigninCallback) {\n          user = await userManager.signinCallback();\n          if (onSigninCallback) await onSigninCallback(user);\n        }\n        user = !user ? await userManager.getUser() : user;\n        dispatch({\n          type: \"INITIALISED\",\n          user\n        });\n      } catch (error) {\n        dispatch({\n          type: \"ERROR\",\n          error: signinError(error)\n        });\n      }\n      try {\n        if (matchSignoutCallback && matchSignoutCallback(userManager.settings)) {\n          const resp = await userManager.signoutCallback();\n          if (onSignoutCallback) await onSignoutCallback(resp);\n        }\n      } catch (error) {\n        dispatch({\n          type: \"ERROR\",\n          error: signoutError(error)\n        });\n      }\n    })();\n  }, [userManager, skipSigninCallback, onSigninCallback, onSignoutCallback, matchSignoutCallback]);\n  React2.useEffect(() => {\n    if (!userManager) return void 0;\n    const handleUserLoaded = user => {\n      dispatch({\n        type: \"USER_LOADED\",\n        user\n      });\n    };\n    userManager.events.addUserLoaded(handleUserLoaded);\n    const handleUserUnloaded = () => {\n      dispatch({\n        type: \"USER_UNLOADED\"\n      });\n    };\n    userManager.events.addUserUnloaded(handleUserUnloaded);\n    const handleUserSignedOut = () => {\n      dispatch({\n        type: \"USER_SIGNED_OUT\"\n      });\n    };\n    userManager.events.addUserSignedOut(handleUserSignedOut);\n    const handleSilentRenewError = error => {\n      dispatch({\n        type: \"ERROR\",\n        error: renewSilentError(error)\n      });\n    };\n    userManager.events.addSilentRenewError(handleSilentRenewError);\n    return () => {\n      userManager.events.removeUserLoaded(handleUserLoaded);\n      userManager.events.removeUserUnloaded(handleUserUnloaded);\n      userManager.events.removeUserSignedOut(handleUserSignedOut);\n      userManager.events.removeSilentRenewError(handleSilentRenewError);\n    };\n  }, [userManager]);\n  const removeUser = React2.useCallback(async () => {\n    if (!userManager) unsupportedEnvironment(\"removeUser\");\n    await userManager.removeUser();\n    if (onRemoveUser) await onRemoveUser();\n  }, [userManager, onRemoveUser]);\n  const contextValue = React2.useMemo(() => {\n    return {\n      ...state,\n      ...userManagerContext,\n      removeUser\n    };\n  }, [state, userManagerContext, removeUser]);\n  return /* @__PURE__ */React2.createElement(AuthContext.Provider, {\n    value: contextValue\n  }, children);\n};\n\n// src/useAuth.ts\nimport React3 from \"react\";\nvar useAuth = () => {\n  const context = React3.useContext(AuthContext);\n  if (!context) {\n    console.warn(\"AuthProvider context is undefined, please verify you are calling useAuth() as child of a <AuthProvider> component.\");\n  }\n  return context;\n};\n\n// src/useAutoSignin.ts\nimport React4 from \"react\";\nvar useAutoSignin = ({\n  signinMethod = \"signinRedirect\"\n} = {}) => {\n  const auth = useAuth();\n  const [hasTriedSignin, setHasTriedSignin] = React4.useState(false);\n  const shouldAttemptSignin = React4.useMemo(() => !hasAuthParams() && !auth.isAuthenticated && !auth.activeNavigator && !auth.isLoading && !hasTriedSignin, [auth.activeNavigator, auth.isAuthenticated, auth.isLoading, hasTriedSignin]);\n  React4.useEffect(() => {\n    if (shouldAttemptSignin) {\n      switch (signinMethod) {\n        case \"signinPopup\":\n          void auth.signinPopup();\n          break;\n        case \"signinRedirect\":\n        default:\n          void auth.signinRedirect();\n          break;\n      }\n      setHasTriedSignin(true);\n    }\n  }, [auth, hasTriedSignin, shouldAttemptSignin, signinMethod]);\n  return {\n    isLoading: auth.isLoading,\n    isAuthenticated: auth.isAuthenticated,\n    error: auth.error\n  };\n};\n\n// src/withAuth.tsx\nimport React5 from \"react\";\nfunction withAuth(Component) {\n  const displayName = `withAuth(${Component.displayName || Component.name})`;\n  const C = props => {\n    const auth = useAuth();\n    return /* @__PURE__ */React5.createElement(Component, {\n      ...props,\n      auth\n    });\n  };\n  C.displayName = displayName;\n  return C;\n}\n\n// src/withAuthenticationRequired.tsx\nimport React6 from \"react\";\nvar withAuthenticationRequired = (Component, options = {}) => {\n  const {\n    OnRedirecting = () => /* @__PURE__ */React6.createElement(React6.Fragment, null),\n    onBeforeSignin,\n    signinRedirectArgs\n  } = options;\n  const displayName = `withAuthenticationRequired(${Component.displayName || Component.name})`;\n  const C = props => {\n    const auth = useAuth();\n    React6.useEffect(() => {\n      if (hasAuthParams() || auth.isLoading || auth.activeNavigator || auth.isAuthenticated) {\n        return;\n      }\n      void (async () => {\n        if (onBeforeSignin) await onBeforeSignin();\n        await auth.signinRedirect(signinRedirectArgs);\n      })();\n    }, [auth.isLoading, auth.isAuthenticated, auth]);\n    return auth.isAuthenticated ? /* @__PURE__ */React6.createElement(Component, {\n      ...props\n    }) : OnRedirecting();\n  };\n  C.displayName = displayName;\n  return C;\n};\nexport { AuthContext, AuthProvider, hasAuthParams, useAuth, useAutoSignin, withAuth, withAuthenticationRequired };","map":{"version":3,"names":["React","AuthContext","createContext","displayName","UserManager","React2","initialAuthState","isLoading","isAuthenticated","reducer","state","action","type","user","expired","error","activeNavigator","method","name","message","innerError","TypeError","stack","source","hasAuthParams","location","window","searchParams","URLSearchParams","search","get","hash","replace","signinError","normalizeErrorFn","signoutError","renewSilentError","normalizeError","fallbackMessage","stringFieldOf","Error","element","fieldName","or","value","userManagerContextKeys","navigatorKeys","unsupportedEnvironment","fnName","UserManagerImpl","AuthProvider","props","children","onSigninCallback","skipSigninCallback","matchSignoutCallback","onSignoutCallback","onRemoveUser","userManager","userManagerProp","userManagerSettings","useState","settings","dispatch","useReducer","userManagerContext","useMemo","Object","assign","events","fromEntries","map","key","_a","_b","bind","args","didInitialize","useRef","useEffect","current","signinCallback","getUser","resp","signoutCallback","handleUserLoaded","addUserLoaded","handleUserUnloaded","addUserUnloaded","handleUserSignedOut","addUserSignedOut","handleSilentRenewError","addSilentRenewError","removeUserLoaded","removeUserUnloaded","removeUserSignedOut","removeSilentRenewError","removeUser","useCallback","contextValue","createElement","Provider","React3","useAuth","context","useContext","console","warn","React4","useAutoSignin","signinMethod","auth","hasTriedSignin","setHasTriedSignin","shouldAttemptSignin","signinPopup","signinRedirect","React5","withAuth","Component","C","React6","withAuthenticationRequired","options","OnRedirecting","Fragment","onBeforeSignin","signinRedirectArgs"],"sources":["/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/react-oidc-context/src/AuthContext.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/react-oidc-context/src/AuthProvider.tsx","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/react-oidc-context/src/AuthState.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/react-oidc-context/src/reducer.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/react-oidc-context/src/utils.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/react-oidc-context/src/useAuth.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/react-oidc-context/src/useAutoSignin.ts","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/react-oidc-context/src/withAuth.tsx","/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/react-oidc-context/src/withAuthenticationRequired.tsx"],"sourcesContent":["import React from \"react\";\nimport type {\n    UserManagerSettings, UserManagerEvents, User, SessionStatus,\n    SigninPopupArgs, SigninSilentArgs, SigninRedirectArgs,\n    SignoutRedirectArgs, SignoutPopupArgs, QuerySessionStatusArgs,\n    RevokeTokensTypes, SignoutSilentArgs, SigninResourceOwnerCredentialsArgs,\n} from \"oidc-client-ts\";\n\nimport type { AuthState } from \"./AuthState\";\n\n/**\n * @public\n */\nexport interface AuthContextProps extends AuthState {\n    /**\n     * UserManager functions. See [UserManager](https://github.com/authts/oidc-client-ts) for more details.\n     */\n    readonly settings: UserManagerSettings;\n    readonly events: UserManagerEvents;\n    clearStaleState(): Promise<void>;\n    removeUser(): Promise<void>;\n    signinPopup(args?: SigninPopupArgs): Promise<User>;\n    signinSilent(args?: SigninSilentArgs): Promise<User | null>;\n    signinRedirect(args?: SigninRedirectArgs): Promise<void>;\n    signinResourceOwnerCredentials(args: SigninResourceOwnerCredentialsArgs): Promise<User>;\n    signoutRedirect(args?: SignoutRedirectArgs): Promise<void>;\n    signoutPopup(args?: SignoutPopupArgs): Promise<void>;\n    signoutSilent(args?: SignoutSilentArgs): Promise<void>;\n    querySessionStatus(args?: QuerySessionStatusArgs): Promise<SessionStatus | null>;\n    revokeTokens(types?: RevokeTokensTypes): Promise<void>;\n    startSilentRenew(): void;\n    stopSilentRenew(): void;\n}\n\n/**\n * @public\n */\nexport const AuthContext = React.createContext<AuthContextProps | undefined>(undefined);\nAuthContext.displayName = \"AuthContext\";\n","import type { ProcessResourceOwnerPasswordCredentialsArgs, SignoutResponse } from \"oidc-client-ts\";\nimport { User, UserManager, type UserManagerSettings } from \"oidc-client-ts\";\nimport React from \"react\";\n\nimport { AuthContext } from \"./AuthContext\";\nimport { type ErrorContext, initialAuthState } from \"./AuthState\";\nimport { reducer } from \"./reducer\";\nimport { hasAuthParams, normalizeError, renewSilentError, signinError, signoutError } from \"./utils\";\n\n/**\n * @public\n */\nexport interface AuthProviderBaseProps {\n    /**\n     * The child nodes your Provider has wrapped\n     */\n    children?: React.ReactNode;\n\n    /**\n     * On sign in callback hook. Can be a async function.\n     * Here you can remove the code and state parameters from the url when you are redirected from the authorize page.\n     *\n     * ```jsx\n     * const onSigninCallback = (_user: User | undefined): void => {\n     *     window.history.replaceState(\n     *         {},\n     *         document.title,\n     *         window.location.pathname\n     *     )\n     * }\n     * ```\n     */\n    onSigninCallback?: (user: User | undefined) => Promise<void> | void;\n\n    /**\n     * By default, if the page url has code/state params, this provider will call automatically the `userManager.signinCallback`.\n     * In some cases the code might be for something else (another OAuth SDK perhaps). In these\n     * instances you can instruct the client to ignore them.\n     *\n     * ```jsx\n     * <AuthProvider\n     *   skipSigninCallback={window.location.pathname === \"/stripe-oauth-callback\"}\n     * >\n     * ```\n     */\n    skipSigninCallback?: boolean;\n\n    /**\n     * Match the redirect uri used for logout (e.g. `post_logout_redirect_uri`)\n     * This provider will then call automatically the `userManager.signoutCallback`.\n     *\n     * HINT:\n     * Do not call `userManager.signoutRedirect()` within a `React.useEffect`, otherwise the\n     * logout might be unsuccessful.\n     *\n     * ```jsx\n     * <AuthProvider\n     *   matchSignoutCallback={(args) => {\n     *     window &&\n     *     (window.location.href === args.post_logout_redirect_uri);\n     *   }}\n     * ```\n     */\n    matchSignoutCallback?: (args: UserManagerSettings) => boolean;\n\n    /**\n     * On sign out callback hook. Can be a async function.\n     * Here you can change the url after the user is signed out.\n     * When using this, specifying `matchSignoutCallback` is required.\n     *\n     * ```jsx\n     * const onSignoutCallback = (resp: SignoutResponse | undefined): void => {\n     *     // go to home after logout\n     *     window.location.pathname = \"\"\n     * }\n     * ```\n     */\n    onSignoutCallback?: (resp: SignoutResponse | undefined) => Promise<void> | void;\n\n    /**\n     * On remove user hook. Can be a async function.\n     * Here you can change the url after the user is removed.\n     *\n     * ```jsx\n     * const onRemoveUser = (): void => {\n     *     // go to home after logout\n     *     window.location.pathname = \"\"\n     * }\n     * ```\n     */\n    onRemoveUser?: () => Promise<void> | void;\n}\n\n/**\n * This interface (default) is used to pass `UserManagerSettings` together with `AuthProvider` properties to the provider.\n *\n * @public\n */\nexport interface AuthProviderNoUserManagerProps extends AuthProviderBaseProps, UserManagerSettings {\n    /**\n     * Prevent this property.\n     */\n    userManager?: never;\n}\n\n/**\n * This interface is used to pass directly a `UserManager` instance together with `AuthProvider` properties to the provider.\n *\n * @public\n */\nexport interface AuthProviderUserManagerProps extends AuthProviderBaseProps {\n    /**\n     * Allow passing a custom UserManager instance.\n     */\n    userManager?: UserManager;\n}\n\n/**\n * @public\n */\nexport type AuthProviderProps = AuthProviderNoUserManagerProps | AuthProviderUserManagerProps;\n\nconst userManagerContextKeys = [\n    \"clearStaleState\",\n    \"querySessionStatus\",\n    \"revokeTokens\",\n    \"startSilentRenew\",\n    \"stopSilentRenew\",\n] as const;\nconst navigatorKeys = [\n    \"signinPopup\",\n    \"signinSilent\",\n    \"signinRedirect\",\n    \"signinResourceOwnerCredentials\",\n    \"signoutPopup\",\n    \"signoutRedirect\",\n    \"signoutSilent\",\n] as const;\nconst unsupportedEnvironment = (fnName: string) => () => {\n    throw new Error(\n        `UserManager#${fnName} was called from an unsupported context. If this is a server-rendered page, defer this call with useEffect() or pass a custom UserManager implementation.`,\n    );\n};\nconst UserManagerImpl =\n    typeof window === \"undefined\" ? null : UserManager;\n\n/**\n * Provides the AuthContext to its child components.\n *\n * @public\n */\nexport const AuthProvider = (props: AuthProviderProps): React.JSX.Element => {\n    const {\n        children,\n\n        onSigninCallback,\n        skipSigninCallback,\n\n        matchSignoutCallback,\n        onSignoutCallback,\n\n        onRemoveUser,\n\n        userManager: userManagerProp = null,\n        ...userManagerSettings\n    } = props;\n\n    const [userManager] = React.useState(() => {\n        return userManagerProp ??\n            (UserManagerImpl\n                ? new UserManagerImpl(userManagerSettings as UserManagerSettings)\n                : ({ settings: userManagerSettings } as UserManager));\n    });\n\n    const [state, dispatch] = React.useReducer(reducer, initialAuthState);\n    const userManagerContext = React.useMemo(\n        () =>\n            Object.assign(\n                {\n                    settings: userManager.settings,\n                    events: userManager.events,\n                },\n                Object.fromEntries(\n                    userManagerContextKeys.map((key) => [\n                        key,\n                        userManager[key]?.bind(userManager) ??\n                        unsupportedEnvironment(key),\n                    ]),\n                ) as Pick<UserManager, typeof userManagerContextKeys[number]>,\n                Object.fromEntries(\n                    navigatorKeys.map((key) => [\n                        key,\n                        userManager[key]\n                            ? async (args: ProcessResourceOwnerPasswordCredentialsArgs & never[]) => {\n                                dispatch({\n                                    type: \"NAVIGATOR_INIT\",\n                                    method: key,\n                                });\n                                try {\n                                    return await userManager[key](args);\n                                } catch (error) {\n                                    dispatch({\n                                        type: \"ERROR\",\n                                        error: {\n                                            ...normalizeError(error, `Unknown error while executing ${key}(...).`),\n                                            source: key,\n                                            args: args,\n                                        } as ErrorContext,\n                                    });\n                                    return null;\n                                } finally {\n                                    dispatch({ type: \"NAVIGATOR_CLOSE\" });\n                                }\n                            }\n                            : unsupportedEnvironment(key),\n                    ]),\n                ) as Pick<UserManager, typeof navigatorKeys[number]>,\n            ),\n        [userManager],\n    );\n    const didInitialize = React.useRef(false);\n\n    React.useEffect(() => {\n        if (!userManager || didInitialize.current) {\n            return;\n        }\n        didInitialize.current = true;\n\n        void (async (): Promise<void> => {\n            // sign-in\n            try {\n                let user: User | undefined | null = null;\n\n                // check if returning back from authority server\n                if (hasAuthParams() && !skipSigninCallback) {\n                    user = await userManager.signinCallback();\n                    if (onSigninCallback) await onSigninCallback(user);\n                }\n                user = !user ? await userManager.getUser() : user;\n                dispatch({ type: \"INITIALISED\", user });\n            } catch (error) {\n                dispatch({\n                    type: \"ERROR\",\n                    error: signinError(error),\n                });\n            }\n\n            // sign-out\n            try {\n                if (matchSignoutCallback && matchSignoutCallback(userManager.settings)) {\n                    const resp = await userManager.signoutCallback();\n                    if (onSignoutCallback) await onSignoutCallback(resp);\n                }\n            } catch (error) {\n                dispatch({\n                    type: \"ERROR\",\n                    error: signoutError(error),\n                });\n            }\n        })();\n    }, [userManager, skipSigninCallback, onSigninCallback, onSignoutCallback, matchSignoutCallback]);\n\n    // register to userManager events\n    React.useEffect(() => {\n        if (!userManager) return undefined;\n        // event UserLoaded (e.g. initial load, silent renew success)\n        const handleUserLoaded = (user: User) => {\n            dispatch({ type: \"USER_LOADED\", user });\n        };\n        userManager.events.addUserLoaded(handleUserLoaded);\n\n        // event UserUnloaded (e.g. userManager.removeUser)\n        const handleUserUnloaded = () => {\n            dispatch({ type: \"USER_UNLOADED\" });\n        };\n        userManager.events.addUserUnloaded(handleUserUnloaded);\n\n        // event UserSignedOut (e.g. user was signed out in background (checkSessionIFrame option))\n        const handleUserSignedOut = () => {\n            dispatch({ type: \"USER_SIGNED_OUT\" });\n        };\n        userManager.events.addUserSignedOut(handleUserSignedOut);\n\n        // event SilentRenewError (silent renew error)\n        const handleSilentRenewError = (error: Error) => {\n            dispatch({\n                type: \"ERROR\",\n                error: renewSilentError(error),\n            });\n        };\n        userManager.events.addSilentRenewError(handleSilentRenewError);\n\n        return () => {\n            userManager.events.removeUserLoaded(handleUserLoaded);\n            userManager.events.removeUserUnloaded(handleUserUnloaded);\n            userManager.events.removeUserSignedOut(handleUserSignedOut);\n            userManager.events.removeSilentRenewError(handleSilentRenewError);\n        };\n    }, [userManager]);\n\n    const removeUser = React.useCallback(async () => {\n        if (!userManager) unsupportedEnvironment(\"removeUser\");\n        await userManager.removeUser();\n        if (onRemoveUser) await onRemoveUser();\n    }, [userManager, onRemoveUser]);\n\n    const contextValue = React.useMemo(() => {\n        return {\n            ...state,\n            ...userManagerContext,\n            removeUser,\n        };\n    }, [state, userManagerContext, removeUser]);\n\n    return (\n        <AuthContext.Provider value={contextValue}>\n            {children}\n        </AuthContext.Provider>\n    );\n};\n","import type {\n    SigninPopupArgs,\n    SigninRedirectArgs,\n    SigninResourceOwnerCredentialsArgs,\n    SigninSilentArgs,\n    SignoutPopupArgs,\n    SignoutRedirectArgs,\n    SignoutSilentArgs,\n    User,\n} from \"oidc-client-ts\";\n\n/**\n * The auth state which, when combined with the auth methods, make up the return object of the `useAuth` hook.\n *\n * @public\n */\nexport interface AuthState {\n    /**\n     * See [User](https://authts.github.io/oidc-client-ts/classes/User.html) for more details.\n     */\n    user?: User | null;\n\n    /**\n     * True when the library has been initialized and no navigator request is in progress.\n     */\n    isLoading: boolean;\n\n    /**\n     * True while the user has a valid access token.\n     */\n    isAuthenticated: boolean;\n\n    /**\n     * Tracks the status of most recent signin/signout request method.\n     */\n    activeNavigator?: \"signinRedirect\" | \"signinResourceOwnerCredentials\" | \"signinPopup\" | \"signinSilent\" | \"signoutRedirect\" | \"signoutPopup\" | \"signoutSilent\";\n\n    /**\n     * Was there a signin or silent renew error?\n     */\n    error?: ErrorContext;\n}\n\n/**\n * Represents an error while execution of a signing, renew, ...\n *\n * @public\n */\nexport type ErrorContext = Error & {\n    innerError?: unknown;\n} & ({ source: \"signinCallback\" }\n    | { source: \"signoutCallback\" }\n    | { source: \"renewSilent\" }\n\n    | { source: \"signinPopup\"; args: SigninPopupArgs | undefined }\n    | { source: \"signinSilent\"; args: SigninSilentArgs | undefined }\n    | { source: \"signinRedirect\"; args: SigninRedirectArgs | undefined }\n    | { source: \"signinResourceOwnerCredentials\"; args: SigninResourceOwnerCredentialsArgs | undefined }\n    | { source: \"signoutPopup\"; args: SignoutPopupArgs | undefined }\n    | { source: \"signoutRedirect\"; args: SignoutRedirectArgs | undefined }\n    | { source: \"signoutSilent\"; args: SignoutSilentArgs | undefined }\n\n    | { source: \"unknown\" }\n);\n\n/**\n * The initial auth state.\n */\nexport const initialAuthState: AuthState = {\n    isLoading: true,\n    isAuthenticated: false,\n};\n","import type { User } from \"oidc-client-ts\";\n\nimport type { AuthState, ErrorContext } from \"./AuthState\";\n\ntype Action =\n    | { type: \"INITIALISED\" | \"USER_LOADED\"; user: User | null }\n    | { type: \"USER_UNLOADED\" }\n    | { type: \"USER_SIGNED_OUT\" }\n    | { type: \"NAVIGATOR_INIT\"; method: NonNullable<AuthState[\"activeNavigator\"]> }\n    | { type: \"NAVIGATOR_CLOSE\" }\n    | { type: \"ERROR\"; error: ErrorContext };\n\n/**\n * Handles how that state changes in the `useAuth` hook.\n */\nexport const reducer = (state: AuthState, action: Action): AuthState => {\n    switch (action.type) {\n        case \"INITIALISED\":\n        case \"USER_LOADED\":\n            return {\n                ...state,\n                user: action.user,\n                isLoading: false,\n                isAuthenticated: action.user ? !action.user.expired : false,\n                error: undefined,\n            };\n        case \"USER_SIGNED_OUT\":\n        case \"USER_UNLOADED\":\n            return {\n                ...state,\n                user: undefined,\n                isAuthenticated: false,\n            };\n        case \"NAVIGATOR_INIT\":\n            return {\n                ...state,\n                isLoading: true,\n                activeNavigator: action.method,\n            };\n        case \"NAVIGATOR_CLOSE\":\n            // we intentionally don't handle cases where multiple concurrent navigators are open\n            return {\n                ...state,\n                isLoading: false,\n                activeNavigator: undefined,\n            };\n        case \"ERROR\": {\n            const error = action.error;\n            error[\"toString\"] = () => `${error.name}: ${error.message}`;\n            return {\n                ...state,\n                isLoading: false,\n                error,\n            };\n        }\n        default: {\n            const innerError = new TypeError(`unknown type ${action[\"type\"] as string}`);\n            const error = {\n                name: innerError.name,\n                message: innerError.message,\n                innerError,\n                stack: innerError.stack,\n                source: \"unknown\",\n            } satisfies ErrorContext;\n            error[\"toString\"] = () => `${error.name}: ${error.message}`;\n            return {\n                ...state,\n                isLoading: false,\n                error,\n            };\n        }\n    }\n};\n","import type { ErrorContext } from \"./AuthState\";\n\n/**\n * @public\n */\nexport const hasAuthParams = (location = window.location): boolean => {\n    // response_mode: query\n    let searchParams = new URLSearchParams(location.search);\n    if ((searchParams.get(\"code\") || searchParams.get(\"error\")) &&\n        searchParams.get(\"state\")) {\n        return true;\n    }\n\n    // response_mode: fragment\n    searchParams = new URLSearchParams(location.hash.replace(\"#\", \"?\"));\n    if ((searchParams.get(\"code\") || searchParams.get(\"error\")) &&\n        searchParams.get(\"state\")) {\n        return true;\n    }\n\n    return false;\n};\n\nexport const signinError = normalizeErrorFn(\"signinCallback\", \"Sign-in failed\");\nexport const signoutError = normalizeErrorFn(\"signoutCallback\", \"Sign-out failed\");\nexport const renewSilentError = normalizeErrorFn(\"renewSilent\", \"Renew silent failed\");\n\nexport function normalizeError(error: unknown, fallbackMessage: string): Pick<ErrorContext, \"name\" | \"message\" | \"innerError\" | \"stack\"> {\n    return {\n        name: stringFieldOf(error, \"name\", () => \"Error\"),\n        message: stringFieldOf(error, \"message\", () => fallbackMessage),\n        stack: stringFieldOf(error, \"stack\", () => new Error().stack),\n        innerError: error,\n    };\n}\n\nfunction normalizeErrorFn(source: \"signoutCallback\" | \"signinCallback\" | \"renewSilent\", fallbackMessage: string) {\n    return (error: unknown): ErrorContext => {\n        return {\n            ...normalizeError(error, fallbackMessage),\n            source: source,\n        };\n    };\n}\n\nfunction stringFieldOf(element: unknown, fieldName: string, or: () => string): string;\nfunction stringFieldOf(element: unknown, fieldName: string, or: () => string | undefined): string | undefined;\nfunction stringFieldOf(element: unknown, fieldName: string, or: () => string | undefined): string | undefined {\n    if (element && typeof element === \"object\") {\n        const value = (element as Record<string, unknown>)[fieldName];\n        if (typeof value === \"string\") {\n            return value;\n        }\n    }\n    return or();\n}\n","import React from \"react\";\n\nimport { AuthContext, type AuthContextProps } from \"./AuthContext\";\n\n/**\n * @public\n */\nexport const useAuth = (): AuthContextProps => {\n    const context = React.useContext(AuthContext);\n\n    if (!context) {\n        console.warn(\"AuthProvider context is undefined, please verify you are calling useAuth() as child of a <AuthProvider> component.\");\n    }\n\n    return context as AuthContextProps;\n};\n","import React from \"react\";\nimport { useAuth } from \"./useAuth\";\nimport { hasAuthParams } from \"./utils\";\nimport type { AuthContextProps } from \"./AuthContext\";\nimport type { AuthState } from \"./AuthState\";\n\ntype UseAutoSignInProps = {\n    signinMethod?: keyof Pick<AuthContextProps, \"signinRedirect\" | \"signinPopup\">;\n}\n\ntype UseAutoSignInReturn = Pick<AuthState, \"isAuthenticated\" | \"isLoading\" | \"error\">\n\n/**\n * @public\n *\n * Automatically attempts to sign in a user based on the provided sign-in method and authentication state.\n *\n * This hook manages automatic sign-in behavior for a user. It uses the specified sign-in\n * method, the current authentication state, and ensures the sign-in attempt is made only once\n * in the application context.\n *\n * Does not support the `signinResourceOwnerCredentials` method!\n *\n * @param options - (Optional) Configuration object for the sign-in method. Default to `{ signinMethod: \"signinRedirect\" }`.\n *       Possible values for `signinMethod` are:\n *        - `\"signinRedirect\"`: Redirects the user to the sign-in page (default).\n *        - `\"signinPopup\"`: Signs in the user through a popup.\n *\n * @returns The current status of the authentication process.\n */\nexport const useAutoSignin = ({ signinMethod = \"signinRedirect\" }: UseAutoSignInProps = {}): UseAutoSignInReturn => {\n    const auth = useAuth();\n    const [hasTriedSignin, setHasTriedSignin] = React.useState(false);\n\n    const shouldAttemptSignin = React.useMemo(() => !hasAuthParams() && !auth.isAuthenticated && !auth.activeNavigator && !auth.isLoading &&\n        !hasTriedSignin, [auth.activeNavigator, auth.isAuthenticated, auth.isLoading, hasTriedSignin]);\n\n    React.useEffect(() => {\n        if (shouldAttemptSignin) {\n            switch (signinMethod) {\n                case \"signinPopup\":\n                    void auth.signinPopup();\n                    break;\n                case \"signinRedirect\":\n                default:\n                    void auth.signinRedirect();\n                    break;\n            }\n\n            setHasTriedSignin(true);\n        }\n    }, [auth, hasTriedSignin, shouldAttemptSignin, signinMethod]);\n\n    return {\n        isLoading: auth.isLoading,\n        isAuthenticated: auth.isAuthenticated,\n        error: auth.error,\n    };\n};\n","import React from \"react\";\n\nimport type { AuthContextProps } from \"./AuthContext\";\nimport { useAuth } from \"./useAuth\";\n\n/**\n * A public higher-order component to access the imperative API\n * @public\n */\nexport function withAuth<P>(\n    Component: React.ComponentType<P>,\n): React.ComponentType<Omit<P, keyof AuthContextProps>> {\n    const displayName = `withAuth(${Component.displayName || Component.name})`;\n    const C: React.FC<Omit<P, keyof AuthContextProps>> = (props) => {\n        const auth = useAuth();\n\n        return <Component {...(props as P)} auth={auth} />;\n    };\n\n    C.displayName = displayName;\n\n    return C;\n}\n","import React from \"react\";\nimport type { SigninRedirectArgs } from \"oidc-client-ts\";\n\nimport { useAuth } from \"./useAuth\";\nimport { hasAuthParams } from \"./utils\";\n\n/**\n * @public\n */\nexport interface WithAuthenticationRequiredProps {\n    /**\n     * Show a message when redirected to the signin page.\n     */\n    OnRedirecting?: () => React.JSX.Element;\n\n    /**\n     * Allows executing logic before the user is redirected to the signin page.\n     */\n    onBeforeSignin?: () => Promise<void> | void;\n\n    /**\n     * Pass additional signin redirect arguments.\n     */\n    signinRedirectArgs?: SigninRedirectArgs;\n}\n\n/**\n * A public higher-order component to protect accessing not public content. When you wrap your components in this higher-order\n * component and an anonymous user visits your component, they will be redirected to the login page; after logging in, they\n * will return to the page from which they were redirected.\n *\n * @public\n */\nexport const withAuthenticationRequired = <P extends object>(\n    Component: React.ComponentType<P>,\n    options: WithAuthenticationRequiredProps = {},\n): React.FC<P> => {\n    const { OnRedirecting = (): React.JSX.Element => <></>, onBeforeSignin, signinRedirectArgs } = options;\n    const displayName = `withAuthenticationRequired(${Component.displayName || Component.name})`;\n    const C: React.FC<P> = (props) => {\n        const auth = useAuth();\n\n        React.useEffect(() => {\n            if (hasAuthParams() ||\n                auth.isLoading || auth.activeNavigator || auth.isAuthenticated) {\n                return;\n            }\n            void (async (): Promise<void> => {\n                if (onBeforeSignin) await onBeforeSignin();\n                await auth.signinRedirect(signinRedirectArgs);\n            })();\n        }, [auth.isLoading, auth.isAuthenticated, auth]);\n\n        return auth.isAuthenticated ? <Component {...props} /> : OnRedirecting();\n    };\n\n    C.displayName = displayName;\n\n    return C;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
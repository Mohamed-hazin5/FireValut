{"ast":null,"code":"import { Hub } from '@aws-amplify/core';\nimport { isBrowser, assertTokenProviderConfig, isTokenExpired, AMPLIFY_SYMBOL } from '@aws-amplify/core/internals/utils';\nimport { assertServiceError } from '../../../errors/utils/assertServiceError.mjs';\nimport { AuthError } from '../../../errors/AuthError.mjs';\nimport { oAuthStore } from '../utils/oauth/oAuthStore.mjs';\nimport { addInflightPromise } from '../utils/oauth/inflightPromise.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nclass TokenOrchestrator {\n  constructor() {\n    this.waitForInflightOAuth = isBrowser() ? async () => {\n      if (!(await oAuthStore.loadOAuthInFlight())) {\n        return;\n      }\n      if (this.inflightPromise) {\n        return this.inflightPromise;\n      }\n      // when there is valid oauth config and there is an inflight oauth flow, try\n      // to block async calls that require fetching tokens before the oauth flow completes\n      // e.g. getCurrentUser, fetchAuthSession etc.\n      this.inflightPromise = new Promise((resolve, _reject) => {\n        addInflightPromise(resolve);\n      });\n      return this.inflightPromise;\n    } : async () => {\n      // no-op for non-browser environments\n    };\n  }\n  setAuthConfig(authConfig) {\n    oAuthStore.setAuthConfig(authConfig.Cognito);\n    this.authConfig = authConfig;\n  }\n  setTokenRefresher(tokenRefresher) {\n    this.tokenRefresher = tokenRefresher;\n  }\n  setAuthTokenStore(tokenStore) {\n    this.tokenStore = tokenStore;\n  }\n  getTokenStore() {\n    if (!this.tokenStore) {\n      throw new AuthError({\n        name: 'EmptyTokenStoreException',\n        message: 'TokenStore not set'\n      });\n    }\n    return this.tokenStore;\n  }\n  getTokenRefresher() {\n    if (!this.tokenRefresher) {\n      throw new AuthError({\n        name: 'EmptyTokenRefresherException',\n        message: 'TokenRefresher not set'\n      });\n    }\n    return this.tokenRefresher;\n  }\n  setClientMetadataProvider(clientMetadataProvider) {\n    this.clientMetadataProvider = clientMetadataProvider;\n  }\n  async getTokens(options) {\n    let tokens;\n    try {\n      assertTokenProviderConfig(this.authConfig?.Cognito);\n    } catch (_err) {\n      // Token provider not configured\n      return null;\n    }\n    await this.waitForInflightOAuth();\n    this.inflightPromise = undefined;\n    tokens = await this.getTokenStore().loadTokens();\n    const username = await this.getTokenStore().getLastAuthUser();\n    if (tokens === null) {\n      return null;\n    }\n    const idTokenExpired = !!tokens?.idToken && isTokenExpired({\n      expiresAt: (tokens.idToken?.payload?.exp ?? 0) * 1000,\n      clockDrift: tokens.clockDrift ?? 0\n    });\n    const accessTokenExpired = isTokenExpired({\n      expiresAt: (tokens.accessToken?.payload?.exp ?? 0) * 1000,\n      clockDrift: tokens.clockDrift ?? 0\n    });\n    if (options?.forceRefresh || idTokenExpired || accessTokenExpired) {\n      tokens = await this.refreshTokens({\n        tokens,\n        username,\n        clientMetadata: options?.clientMetadata ?? (await this.clientMetadataProvider?.())\n      });\n      if (tokens === null) {\n        return null;\n      }\n    }\n    return {\n      accessToken: tokens?.accessToken,\n      idToken: tokens?.idToken,\n      signInDetails: tokens?.signInDetails\n    };\n  }\n  async refreshTokens({\n    tokens,\n    username,\n    clientMetadata\n  }) {\n    try {\n      const {\n        signInDetails\n      } = tokens;\n      const newTokens = await this.getTokenRefresher()({\n        tokens,\n        authConfig: this.authConfig,\n        username,\n        clientMetadata\n      });\n      newTokens.signInDetails = signInDetails;\n      await this.setTokens({\n        tokens: newTokens\n      });\n      Hub.dispatch('auth', {\n        event: 'tokenRefresh'\n      }, 'Auth', AMPLIFY_SYMBOL);\n      return newTokens;\n    } catch (err) {\n      return this.handleErrors(err);\n    }\n  }\n  handleErrors(err) {\n    assertServiceError(err);\n    // Only clear tokens for definitive authentication failures\n    // Do NOT clear tokens for transient errors like service issues, rate limits, etc.\n    const shouldClearTokens = this.isAuthenticationError(err);\n    if (shouldClearTokens) {\n      this.clearTokens();\n    }\n    Hub.dispatch('auth', {\n      event: 'tokenRefresh_failure',\n      data: {\n        error: err\n      }\n    }, 'Auth', AMPLIFY_SYMBOL);\n    if (err.name.startsWith('NotAuthorizedException')) {\n      return null;\n    }\n    throw err;\n  }\n  isAuthenticationError(err) {\n    // Only clear tokens for errors that definitively indicate the tokens are invalid\n    // and re-authentication is required. All other errors (service errors, rate limits, etc.)\n    // should preserve the tokens to allow for retry.\n    // See: https://github.com/aws-amplify/amplify-js/issues/14534\n    const authErrorNames = ['NotAuthorizedException',\n    // Refresh token is expired or invalid\n    'TokenRevokedException',\n    // Token was revoked by admin\n    'UserNotFoundException',\n    // User no longer exists\n    'PasswordResetRequiredException',\n    // User must reset password\n    'UserNotConfirmedException',\n    // User account is not confirmed\n    'RefreshTokenReuseException' // Refresh token invalidated by rotation\n    ];\n    return authErrorNames.some(errorName => err?.name?.startsWith?.(errorName));\n  }\n  async setTokens({\n    tokens\n  }) {\n    return this.getTokenStore().storeTokens(tokens);\n  }\n  async clearTokens() {\n    return this.getTokenStore().clearTokens();\n  }\n  getDeviceMetadata(username) {\n    return this.getTokenStore().getDeviceMetadata(username);\n  }\n  clearDeviceMetadata(username) {\n    return this.getTokenStore().clearDeviceMetadata(username);\n  }\n  setOAuthMetadata(metadata) {\n    return this.getTokenStore().setOAuthMetadata(metadata);\n  }\n  getOAuthMetadata() {\n    return this.getTokenStore().getOAuthMetadata();\n  }\n}\nexport { TokenOrchestrator };","map":{"version":3,"names":["TokenOrchestrator","constructor","waitForInflightOAuth","isBrowser","oAuthStore","loadOAuthInFlight","inflightPromise","Promise","resolve","_reject","addInflightPromise","setAuthConfig","authConfig","Cognito","setTokenRefresher","tokenRefresher","setAuthTokenStore","tokenStore","getTokenStore","AuthError","name","message","getTokenRefresher","setClientMetadataProvider","clientMetadataProvider","getTokens","options","tokens","assertTokenProviderConfig","_err","undefined","loadTokens","username","getLastAuthUser","idTokenExpired","idToken","isTokenExpired","expiresAt","payload","exp","clockDrift","accessTokenExpired","accessToken","forceRefresh","refreshTokens","clientMetadata","signInDetails","newTokens","setTokens","Hub","dispatch","event","AMPLIFY_SYMBOL","err","handleErrors","assertServiceError","shouldClearTokens","isAuthenticationError","clearTokens","data","error","startsWith","authErrorNames","some","errorName","storeTokens","getDeviceMetadata","clearDeviceMetadata","setOAuthMetadata","metadata","getOAuthMetadata"],"sources":["/Users/mohamedhazin/Desktop/filevalut/frontend/node_modules/@aws-amplify/auth/src/providers/cognito/tokenProvider/TokenOrchestrator.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Hub, } from '@aws-amplify/core';\nimport { AMPLIFY_SYMBOL, assertTokenProviderConfig, isBrowser, isTokenExpired, } from '@aws-amplify/core/internals/utils';\nimport { assertServiceError } from '../../../errors/utils/assertServiceError';\nimport { AuthError } from '../../../errors/AuthError';\nimport { oAuthStore } from '../utils/oauth/oAuthStore';\nimport { addInflightPromise } from '../utils/oauth/inflightPromise';\nexport class TokenOrchestrator {\n    constructor() {\n        this.waitForInflightOAuth = isBrowser()\n            ? async () => {\n                if (!(await oAuthStore.loadOAuthInFlight())) {\n                    return;\n                }\n                if (this.inflightPromise) {\n                    return this.inflightPromise;\n                }\n                // when there is valid oauth config and there is an inflight oauth flow, try\n                // to block async calls that require fetching tokens before the oauth flow completes\n                // e.g. getCurrentUser, fetchAuthSession etc.\n                this.inflightPromise = new Promise((resolve, _reject) => {\n                    addInflightPromise(resolve);\n                });\n                return this.inflightPromise;\n            }\n            : async () => {\n                // no-op for non-browser environments\n            };\n    }\n    setAuthConfig(authConfig) {\n        oAuthStore.setAuthConfig(authConfig.Cognito);\n        this.authConfig = authConfig;\n    }\n    setTokenRefresher(tokenRefresher) {\n        this.tokenRefresher = tokenRefresher;\n    }\n    setAuthTokenStore(tokenStore) {\n        this.tokenStore = tokenStore;\n    }\n    getTokenStore() {\n        if (!this.tokenStore) {\n            throw new AuthError({\n                name: 'EmptyTokenStoreException',\n                message: 'TokenStore not set',\n            });\n        }\n        return this.tokenStore;\n    }\n    getTokenRefresher() {\n        if (!this.tokenRefresher) {\n            throw new AuthError({\n                name: 'EmptyTokenRefresherException',\n                message: 'TokenRefresher not set',\n            });\n        }\n        return this.tokenRefresher;\n    }\n    setClientMetadataProvider(clientMetadataProvider) {\n        this.clientMetadataProvider = clientMetadataProvider;\n    }\n    async getTokens(options) {\n        let tokens;\n        try {\n            assertTokenProviderConfig(this.authConfig?.Cognito);\n        }\n        catch (_err) {\n            // Token provider not configured\n            return null;\n        }\n        await this.waitForInflightOAuth();\n        this.inflightPromise = undefined;\n        tokens = await this.getTokenStore().loadTokens();\n        const username = await this.getTokenStore().getLastAuthUser();\n        if (tokens === null) {\n            return null;\n        }\n        const idTokenExpired = !!tokens?.idToken &&\n            isTokenExpired({\n                expiresAt: (tokens.idToken?.payload?.exp ?? 0) * 1000,\n                clockDrift: tokens.clockDrift ?? 0,\n            });\n        const accessTokenExpired = isTokenExpired({\n            expiresAt: (tokens.accessToken?.payload?.exp ?? 0) * 1000,\n            clockDrift: tokens.clockDrift ?? 0,\n        });\n        if (options?.forceRefresh || idTokenExpired || accessTokenExpired) {\n            tokens = await this.refreshTokens({\n                tokens,\n                username,\n                clientMetadata: options?.clientMetadata ?? (await this.clientMetadataProvider?.()),\n            });\n            if (tokens === null) {\n                return null;\n            }\n        }\n        return {\n            accessToken: tokens?.accessToken,\n            idToken: tokens?.idToken,\n            signInDetails: tokens?.signInDetails,\n        };\n    }\n    async refreshTokens({ tokens, username, clientMetadata, }) {\n        try {\n            const { signInDetails } = tokens;\n            const newTokens = await this.getTokenRefresher()({\n                tokens,\n                authConfig: this.authConfig,\n                username,\n                clientMetadata,\n            });\n            newTokens.signInDetails = signInDetails;\n            await this.setTokens({ tokens: newTokens });\n            Hub.dispatch('auth', { event: 'tokenRefresh' }, 'Auth', AMPLIFY_SYMBOL);\n            return newTokens;\n        }\n        catch (err) {\n            return this.handleErrors(err);\n        }\n    }\n    handleErrors(err) {\n        assertServiceError(err);\n        // Only clear tokens for definitive authentication failures\n        // Do NOT clear tokens for transient errors like service issues, rate limits, etc.\n        const shouldClearTokens = this.isAuthenticationError(err);\n        if (shouldClearTokens) {\n            this.clearTokens();\n        }\n        Hub.dispatch('auth', {\n            event: 'tokenRefresh_failure',\n            data: { error: err },\n        }, 'Auth', AMPLIFY_SYMBOL);\n        if (err.name.startsWith('NotAuthorizedException')) {\n            return null;\n        }\n        throw err;\n    }\n    isAuthenticationError(err) {\n        // Only clear tokens for errors that definitively indicate the tokens are invalid\n        // and re-authentication is required. All other errors (service errors, rate limits, etc.)\n        // should preserve the tokens to allow for retry.\n        // See: https://github.com/aws-amplify/amplify-js/issues/14534\n        const authErrorNames = [\n            'NotAuthorizedException', // Refresh token is expired or invalid\n            'TokenRevokedException', // Token was revoked by admin\n            'UserNotFoundException', // User no longer exists\n            'PasswordResetRequiredException', // User must reset password\n            'UserNotConfirmedException', // User account is not confirmed\n            'RefreshTokenReuseException', // Refresh token invalidated by rotation\n        ];\n        return authErrorNames.some(errorName => err?.name?.startsWith?.(errorName));\n    }\n    async setTokens({ tokens }) {\n        return this.getTokenStore().storeTokens(tokens);\n    }\n    async clearTokens() {\n        return this.getTokenStore().clearTokens();\n    }\n    getDeviceMetadata(username) {\n        return this.getTokenStore().getDeviceMetadata(username);\n    }\n    clearDeviceMetadata(username) {\n        return this.getTokenStore().clearDeviceMetadata(username);\n    }\n    setOAuthMetadata(metadata) {\n        return this.getTokenStore().setOAuthMetadata(metadata);\n    }\n    getOAuthMetadata() {\n        return this.getTokenStore().getOAuthMetadata();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}